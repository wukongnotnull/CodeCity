(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{649:function(a,e,v){"use strict";v.r(e);var t=v(25),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("h3",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),v("p",[a._v("JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）")]),a._v(" "),v("ul",[v("li",[a._v("数值（number）：整数和小数（比如"),v("code",[a._v("1")]),a._v("和"),v("code",[a._v("3.14")]),a._v("）。")]),a._v(" "),v("li",[a._v("字符串（string）：文本（比如"),v("code",[a._v("Hello World")]),a._v("）。")]),a._v(" "),v("li",[a._v("布尔值（boolean）：表示真伪的两个特殊值，即"),v("code",[a._v("true")]),a._v("（真）和"),v("code",[a._v("false")]),a._v("（假）。")]),a._v(" "),v("li",[v("code",[a._v("undefined")]),a._v("：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。")]),a._v(" "),v("li",[v("code",[a._v("null")]),a._v("：表示空值，即此处的值为空。")]),a._v(" "),v("li",[a._v("对象（object）：各种值组成的集合。")])]),a._v(" "),v("p",[a._v("通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于"),v("code",[a._v("undefined")]),a._v("和"),v("code",[a._v("null")]),a._v("，一般将它们看成两个特殊值。")]),a._v(" "),v("p",[a._v("对象是最复杂的数据类型，又可以分成三个子类型。")]),a._v(" "),v("ul",[v("li",[a._v("狭义的对象（object）")]),a._v(" "),v("li",[a._v("数组（array）")]),a._v(" "),v("li",[a._v("函数（function）")])]),a._v(" "),v("p",[a._v("狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。")]),a._v(" "),v("h3",{attrs:{id:"typeof-运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typeof-运算符"}},[a._v("#")]),a._v(" typeof 运算符")]),a._v(" "),v("p",[a._v("JavaScript 有三种方法，可以确定一个值到底是什么类型。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("typeof")]),a._v("运算符")]),a._v(" "),v("li",[v("code",[a._v("instanceof")]),a._v("运算符")]),a._v(" "),v("li",[v("code",[a._v("Object.prototype.toString")]),a._v("方法")])]),a._v(" "),v("p",[v("code",[a._v("instanceof")]),a._v("运算符和"),v("code",[a._v("Object.prototype.toString")]),a._v("方法，将在后文介绍。这里介绍"),v("code",[a._v("typeof")]),a._v("运算符。")]),a._v(" "),v("p",[v("code",[a._v("typeof")]),a._v("运算符可以返回一个值的数据类型。")]),a._v(" "),v("p",[a._v("数值、字符串、布尔值分别返回"),v("code",[a._v("number")]),a._v("、"),v("code",[a._v("string")]),a._v("、"),v("code",[a._v("boolean")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('typeof 123 // "number"\ntypeof \'123\' // "string"\ntypeof false // "boolean"\n')])])]),v("p",[a._v("函数返回"),v("code",[a._v("function")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('function f() {}\ntypeof f\n// "function"\n')])])]),v("p",[v("code",[a._v("undefined")]),a._v("返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('typeof undefined\n// "undefined"\n')])])]),v("p",[a._v("利用这一点，"),v("code",[a._v("typeof")]),a._v("可以用来检查一个没有声明的变量，而不报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('v\n// ReferenceError: v is not defined\n\ntypeof v\n// "undefined"\n')])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("v")]),a._v("没有用"),v("code",[a._v("var")]),a._v("命令声明，直接使用就会报错。但是，放在"),v("code",[a._v("typeof")]),a._v("后面，就不报错了，而是返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("p",[a._v("实际编程中，这个特点通常用在判断语句。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('// 错误的写法\nif (v) {\n  // ...\n}\n// ReferenceError: v is not defined\n\n// 正确的写法\nif (typeof v === "undefined") {\n  // ...\n}\n')])])]),v("p",[a._v("对象返回"),v("code",[a._v("object")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('typeof window // "object"\ntypeof {} // "object"\ntypeof [] // "object"\n')])])]),v("p",[a._v("上面代码中，空数组（"),v("code",[a._v("[]")]),a._v("）的类型也是"),v("code",[a._v("object")]),a._v("，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，"),v("code",[a._v("instanceof")]),a._v("运算符可以区分数组和对象。"),v("code",[a._v("instanceof")]),a._v("运算符的详细解释，请见《面向对象编程》一章。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var o = {};\nvar a = [];\n\no instanceof Array // false\na instanceof Array // true\n")])])]),v("p",[v("code",[a._v("null")]),a._v("返回"),v("code",[a._v("object")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('typeof null // "object"\n')])])]),v("p",[v("code",[a._v("null")]),a._v("的类型是"),v("code",[a._v("object")]),a._v("，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑"),v("code",[a._v("null")]),a._v("，只把它当作"),v("code",[a._v("object")]),a._v("的一种特殊值。后来"),v("code",[a._v("null")]),a._v("独立出来，作为一种单独的数据类型，为了兼容以前的代码，"),v("code",[a._v("typeof null")]),a._v("返回"),v("code",[a._v("object")]),a._v("就没法改变了。")]),a._v(" "),v("h3",{attrs:{id:"参考链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2011/11/improving-typeof.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Improving the JavaScript typeof operator"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"null-udefined和布尔值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#null-udefined和布尔值"}},[a._v("#")]),a._v(" null,udefined和布尔值")]),a._v(" "),v("h3",{attrs:{id:"null-和-undefined"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined"}},[a._v("#")]),a._v(" null 和 undefined")]),a._v(" "),v("h4",{attrs:{id:"概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[v("code",[a._v("null")]),a._v("与"),v("code",[a._v("undefined")]),a._v("都可以表示“没有”，含义非常相似。将一个变量赋值为"),v("code",[a._v("undefined")]),a._v("或"),v("code",[a._v("null")]),a._v("，老实说，语法效果几乎没区别。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = undefined;\n// 或者\nvar a = null;\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("a")]),a._v("分别被赋值为"),v("code",[a._v("undefined")]),a._v("和"),v("code",[a._v("null")]),a._v("，这两种写法的效果几乎等价。")]),a._v(" "),v("p",[a._v("在"),v("code",[a._v("if")]),a._v("语句中，它们都会被自动转为"),v("code",[a._v("false")]),a._v("，相等运算符（"),v("code",[a._v("==")]),a._v("）甚至直接报告两者相等。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if (!undefined) {\n  console.log('undefined is false');\n}\n// undefined is false\n\nif (!null) {\n  console.log('null is false');\n}\n// null is false\n\nundefined == null\n// true\n")])])]),v("p",[a._v("从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有"),v("code",[a._v("null")]),a._v("，没有"),v("code",[a._v("undefined")]),a._v("！")]),a._v(" "),v("p",[a._v("既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。")]),a._v(" "),v("p",[a._v("1995年 JavaScript 诞生时，最初像 Java 一样，只设置了"),v("code",[a._v("null")]),a._v('表示"无"。根据 C 语言的传统，'),v("code",[a._v("null")]),a._v("可以自动转为"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Number(null) // 0\n5 + null // 5\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("null")]),a._v("转为数字时，自动变成0。")]),a._v(" "),v("p",[a._v("但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，"),v("code",[a._v("null")]),a._v("就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果"),v("code",[a._v("null")]),a._v("自动转为0，很不容易发现错误。")]),a._v(" "),v("p",[a._v("因此，他又设计了一个"),v("code",[a._v("undefined")]),a._v("。区别是这样的："),v("code",[a._v("null")]),a._v("是一个表示“空”的对象，转为数值时为"),v("code",[a._v("0")]),a._v("；"),v("code",[a._v("undefined")]),a._v('是一个表示"此处无定义"的原始值，转为数值时为'),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Number(undefined) // NaN\n5 + undefined // NaN\n")])])]),v("h4",{attrs:{id:"用法和含义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用法和含义"}},[a._v("#")]),a._v(" 用法和含义")]),a._v(" "),v("p",[a._v("对于"),v("code",[a._v("null")]),a._v("和"),v("code",[a._v("undefined")]),a._v("，大致可以像下面这样理解。")]),a._v(" "),v("p",[v("code",[a._v("null")]),a._v("表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入"),v("code",[a._v("null")]),a._v("，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入"),v("code",[a._v("null")]),a._v("，表示未发生错误。")]),a._v(" "),v("p",[v("code",[a._v("undefined")]),a._v("表示“未定义”，下面是返回"),v("code",[a._v("undefined")]),a._v("的典型场景。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 变量声明了，但没有赋值\nvar i;\ni // undefined\n\n// 调用函数时，应该提供的参数没有提供，该参数等于 undefined\nfunction f(x) {\n  return x;\n}\nf() // undefined\n\n// 对象没有赋值的属性\nvar  o = new Object();\no.p // undefined\n\n// 函数没有返回值时，默认返回 undefined\nfunction f() {}\nf() // undefined\n")])])]),v("h3",{attrs:{id:"布尔值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布尔值"}},[a._v("#")]),a._v(" 布尔值")]),a._v(" "),v("p",[a._v("布尔值代表“真”和“假”两个状态。“真”用关键字"),v("code",[a._v("true")]),a._v("表示，“假”用关键字"),v("code",[a._v("false")]),a._v("表示。布尔值只有这两个值。")]),a._v(" "),v("p",[a._v("下列运算符会返回布尔值：")]),a._v(" "),v("ul",[v("li",[a._v("前置逻辑运算符： "),v("code",[a._v("!")]),a._v(" (Not)")]),a._v(" "),v("li",[a._v("相等运算符："),v("code",[a._v("===")]),a._v("，"),v("code",[a._v("!==")]),a._v("，"),v("code",[a._v("==")]),a._v("，"),v("code",[a._v("!=")])]),a._v(" "),v("li",[a._v("比较运算符："),v("code",[a._v(">")]),a._v("，"),v("code",[a._v(">=")]),a._v("，"),v("code",[a._v("<")]),a._v("，"),v("code",[a._v("<=")])])]),a._v(" "),v("p",[a._v("如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为"),v("code",[a._v("false")]),a._v("，其他值都视为"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("undefined")])]),a._v(" "),v("li",[v("code",[a._v("null")])]),a._v(" "),v("li",[v("code",[a._v("false")])]),a._v(" "),v("li",[v("code",[a._v("0")])]),a._v(" "),v("li",[v("code",[a._v("NaN")])]),a._v(" "),v("li",[v("code",[a._v('""')]),a._v("或"),v("code",[a._v("''")]),a._v("（空字符串）")])]),a._v(" "),v("p",[a._v("布尔值往往用于程序流程的控制，请看一个例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if ('') {\n  console.log('true');\n}\n// 没有任何输出\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("if")]),a._v("命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值"),v("code",[a._v("false")]),a._v("，导致程序不会进入代码块，所以没有任何输出。")]),a._v(" "),v("p",[a._v("注意，空数组（"),v("code",[a._v("[]")]),a._v("）和空对象（"),v("code",[a._v("{}")]),a._v("）对应的布尔值，都是"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if ([]) {\n  console.log('true');\n}\n// true\n\nif ({}) {\n  console.log('true');\n}\n// true\n")])])]),v("p",[a._v("更多关于数据类型转换的介绍，参见《数据类型转换》一章。")]),a._v(" "),v("h3",{attrs:{id:"参考链接-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-2"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2013/01/categorizing-values.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Categorizing values in JavaScript"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"数值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值"}},[a._v("#")]),a._v(" 数值")]),a._v(" "),v("h3",{attrs:{id:"概述-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("h4",{attrs:{id:"整数和浮点数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整数和浮点数"}},[a._v("#")]),a._v(" 整数和浮点数")]),a._v(" "),v("p",[a._v("JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，"),v("code",[a._v("1")]),a._v("与"),v("code",[a._v("1.0")]),a._v("是相同的，是同一个数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1 === 1.0 // true\n")])])]),v("p",[a._v("这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。")]),a._v(" "),v("p",[a._v("由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0.1 + 0.2 === 0.3\n// false\n\n0.3 / 0.1\n// 2.9999999999999996\n\n(0.3 - 0.2) === (0.2 - 0.1)\n// false\n")])])]),v("h4",{attrs:{id:"数值精度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值精度"}},[a._v("#")]),a._v(" 数值精度")]),a._v(" "),v("p",[a._v("根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。")]),a._v(" "),v("ul",[v("li",[a._v("第1位：符号位，"),v("code",[a._v("0")]),a._v("表示正数，"),v("code",[a._v("1")]),a._v("表示负数")]),a._v(" "),v("li",[a._v("第2位到第12位（共11位）：指数部分")]),a._v(" "),v("li",[a._v("第13位到第64位（共52位）：小数部分（即有效数字）")])]),a._v(" "),v("p",[a._v("符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。")]),a._v(" "),v("p",[a._v("指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是"),v("code",[a._v("1.xx...xx")]),a._v("的形式，其中"),v("code",[a._v("xx..xx")]),a._v("的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(-1)^符号位 * 1.xx...xx * 2^指数部分\n")])])]),v("p",[a._v("上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。")]),a._v(" "),v("p",[a._v("精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Math.pow(2, 53)\n// 9007199254740992\n\nMath.pow(2, 53) + 1\n// 9007199254740992\n\nMath.pow(2, 53) + 2\n// 9007199254740994\n\nMath.pow(2, 53) + 3\n// 9007199254740996\n\nMath.pow(2, 53) + 4\n// 9007199254740996\n")])])]),v("p",[a._v("上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Math.pow(2, 53)\n// 9007199254740992\n\n// 多出的三个有效数字，将无法保存\n9007199254740992111\n// 9007199254740992000\n")])])]),v("p",[a._v("上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的"),v("code",[a._v("111")]),a._v("）都会无法保存，变成0。")]),a._v(" "),v("h4",{attrs:{id:"数值范围"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值范围"}},[a._v("#")]),a._v(" 数值范围")]),a._v(" "),v("p",[a._v("根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。")]),a._v(" "),v("p",[a._v("如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Math.pow(2, 1024) // Infinity\n")])])]),v("p",[a._v("如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Math.pow(2, -1075) // 0\n")])])]),v("p",[a._v("下面是一个实际的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 0.5;\n\nfor(var i = 0; i < 25; i++) {\n  x = x * x;\n}\n\nx // 0\n")])])]),v("p",[a._v("上面代码中，对"),v("code",[a._v("0.5")]),a._v("连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。")]),a._v(" "),v("p",[a._v("JavaScript 提供"),v("code",[a._v("Number")]),a._v("对象的"),v("code",[a._v("MAX_VALUE")]),a._v("和"),v("code",[a._v("MIN_VALUE")]),a._v("属性，返回可以表示的具体的最大值和最小值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Number.MAX_VALUE // 1.7976931348623157e+308\nNumber.MIN_VALUE // 5e-324\n")])])]),v("h3",{attrs:{id:"数值的表示法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值的表示法"}},[a._v("#")]),a._v(" 数值的表示法")]),a._v(" "),v("p",[a._v("JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如"),v("code",[a._v("35")]),a._v("（十进制）和"),v("code",[a._v("0xFF")]),a._v("（十六进制）。")]),a._v(" "),v("p",[a._v("数值也可以采用科学计数法表示，下面是几个科学计数法的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("123e3 // 123000\n123e-3 // 0.123\n-3.1E+12\n.1e-23\n")])])]),v("p",[a._v("科学计数法允许字母"),v("code",[a._v("e")]),a._v("或"),v("code",[a._v("E")]),a._v("的后面，跟着一个整数，表示这个数值的指数部分。")]),a._v(" "),v("p",[a._v("以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。")]),a._v(" "),v("p",[v("strong",[a._v("（1）小数点前的数字多于21位。")])]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1234567890123456789012\n// 1.2345678901234568e+21\n\n123456789012345678901\n// 123456789012345680000\n")])])]),v("p",[v("strong",[a._v("（2）小数点后的零多于5个。")])]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 小数点后紧跟5个以上的零，\n// 就自动转为科学计数法\n0.0000003 // 3e-7\n\n// 否则，就保持原来的字面形式\n0.000003 // 0.000003\n")])])]),v("h3",{attrs:{id:"数值的进制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值的进制"}},[a._v("#")]),a._v(" 数值的进制")]),a._v(" "),v("p",[a._v("使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。")]),a._v(" "),v("ul",[v("li",[a._v("十进制：没有前导0的数值。")]),a._v(" "),v("li",[a._v("八进制：有前缀"),v("code",[a._v("0o")]),a._v("或"),v("code",[a._v("0O")]),a._v("的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。")]),a._v(" "),v("li",[a._v("十六进制：有前缀"),v("code",[a._v("0x")]),a._v("或"),v("code",[a._v("0X")]),a._v("的数值。")]),a._v(" "),v("li",[a._v("二进制：有前缀"),v("code",[a._v("0b")]),a._v("或"),v("code",[a._v("0B")]),a._v("的数值。")])]),a._v(" "),v("p",[a._v("默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0xff // 255\n0o377 // 255\n0b11 // 3\n")])])]),v("p",[a._v("如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0xzz // 报错\n0o88 // 报错\n0b22 // 报错\n")])])]),v("p",[a._v("上面代码中，十六进制出现了字母"),v("code",[a._v("z")]),a._v("、八进制出现数字"),v("code",[a._v("8")]),a._v("、二进制出现数字"),v("code",[a._v("2")]),a._v("，因此报错。")]),a._v(" "),v("p",[a._v("通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字"),v("code",[a._v("8")]),a._v("和"),v("code",[a._v("9")]),a._v("，则该数值被视为十进制。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0888 // 888\n0777 // 511\n")])])]),v("p",[a._v("前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。")]),a._v(" "),v("h3",{attrs:{id:"特殊数值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特殊数值"}},[a._v("#")]),a._v(" 特殊数值")]),a._v(" "),v("p",[a._v("JavaScript 提供了几个特殊的数值。")]),a._v(" "),v("h4",{attrs:{id:"正零和负零"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#正零和负零"}},[a._v("#")]),a._v(" 正零和负零")]),a._v(" "),v("p",[a._v("前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连"),v("code",[a._v("0")]),a._v("也不例外。")]),a._v(" "),v("p",[a._v("JavaScript 内部实际上存在2个"),v("code",[a._v("0")]),a._v("：一个是"),v("code",[a._v("+0")]),a._v("，一个是"),v("code",[a._v("-0")]),a._v("，区别就是64位浮点数表示法的符号位不同。它们是等价的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("-0 === +0 // true\n0 === -0 // true\n0 === +0 // true\n")])])]),v("p",[a._v("几乎所有场合，正零和负零都会被当作正常的"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("+0 // 0\n-0 // 0\n(-0).toString() // '0'\n(+0).toString() // '0'\n")])])]),v("p",[a._v("唯一有区别的场合是，"),v("code",[a._v("+0")]),a._v("或"),v("code",[a._v("-0")]),a._v("当作分母，返回的值是不相等的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(1 / +0) === (1 / -0) // false\n")])])]),v("p",[a._v("上面的代码之所以出现这样结果，是因为除以正零得到"),v("code",[a._v("+Infinity")]),a._v("，除以负零得到"),v("code",[a._v("-Infinity")]),a._v("，这两者是不相等的（关于"),v("code",[a._v("Infinity")]),a._v("详见下文）。")]),a._v(" "),v("h4",{attrs:{id:"nan"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nan"}},[a._v("#")]),a._v(" NaN")]),a._v(" "),v("p",[v("strong",[a._v("（1）含义")])]),a._v(" "),v("p",[v("code",[a._v("NaN")]),a._v("是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("5 - 'x' // NaN\n")])])]),v("p",[a._v("上面代码运行时，会自动将字符串"),v("code",[a._v("x")]),a._v("转为数值，但是由于"),v("code",[a._v("x")]),a._v("不是数值，所以最后得到结果为"),v("code",[a._v("NaN")]),a._v("，表示它是“非数字”（"),v("code",[a._v("NaN")]),a._v("）。")]),a._v(" "),v("p",[a._v("另外，一些数学函数的运算结果会出现"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Math.acos(2) // NaN\nMath.log(-1) // NaN\nMath.sqrt(-1) // NaN\n")])])]),v("p",[v("code",[a._v("0")]),a._v("除以"),v("code",[a._v("0")]),a._v("也会得到"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 / 0 // NaN\n")])])]),v("p",[a._v("需要注意的是，"),v("code",[a._v("NaN")]),a._v("不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于"),v("code",[a._v("Number")]),a._v("，使用"),v("code",[a._v("typeof")]),a._v("运算符可以看得很清楚。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("typeof NaN // 'number'\n")])])]),v("p",[v("strong",[a._v("（2）运算规则")])]),a._v(" "),v("p",[v("code",[a._v("NaN")]),a._v("不等于任何值，包括它本身。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("NaN === NaN // false\n")])])]),v("p",[a._v("数组的"),v("code",[a._v("indexOf")]),a._v("方法内部使用的是严格相等运算符，所以该方法对"),v("code",[a._v("NaN")]),a._v("不成立。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("[NaN].indexOf(NaN) // -1\n")])])]),v("p",[v("code",[a._v("NaN")]),a._v("在布尔运算时被当作"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Boolean(NaN) // false\n")])])]),v("p",[v("code",[a._v("NaN")]),a._v("与任何数（包括它自己）的运算，得到的都是"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("NaN + 32 // NaN\nNaN - 32 // NaN\nNaN * 32 // NaN\nNaN / 32 // NaN\n")])])]),v("h4",{attrs:{id:"infinity"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#infinity"}},[a._v("#")]),a._v(" Infinity")]),a._v(" "),v("p",[v("strong",[a._v("（1）含义")])]),a._v(" "),v("p",[v("code",[a._v("Infinity")]),a._v("表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 场景一\nMath.pow(2, 1024)\n// Infinity\n\n// 场景二\n0 / 0 // NaN\n1 / 0 // Infinity\n")])])]),v("p",[a._v("上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回"),v("code",[a._v("Infinity")]),a._v("。第二个场景是"),v("code",[a._v("0")]),a._v("除以"),v("code",[a._v("0")]),a._v("会得到"),v("code",[a._v("NaN")]),a._v("，而非0数值除以"),v("code",[a._v("0")]),a._v("，会返回"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("p",[v("code",[a._v("Infinity")]),a._v("有正负之分，"),v("code",[a._v("Infinity")]),a._v("表示正的无穷，"),v("code",[a._v("-Infinity")]),a._v("表示负的无穷。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Infinity === -Infinity // false\n\n1 / -0 // -Infinity\n-1 / -0 // Infinity\n")])])]),v("p",[a._v("上面代码中，非零正数除以"),v("code",[a._v("-0")]),a._v("，会得到"),v("code",[a._v("-Infinity")]),a._v("，负数除以"),v("code",[a._v("-0")]),a._v("，会得到"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("p",[a._v("由于数值正向溢出（overflow）、负向溢出（underflow）和被"),v("code",[a._v("0")]),a._v("除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。")]),a._v(" "),v("p",[v("code",[a._v("Infinity")]),a._v("大于一切数值（除了"),v("code",[a._v("NaN")]),a._v("），"),v("code",[a._v("-Infinity")]),a._v("小于一切数值（除了"),v("code",[a._v("NaN")]),a._v("）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Infinity > 1000 // true\n-Infinity < -1000 // true\n")])])]),v("p",[v("code",[a._v("Infinity")]),a._v("与"),v("code",[a._v("NaN")]),a._v("比较，总是返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Infinity > NaN // false\n-Infinity > NaN // false\n\nInfinity < NaN // false\n-Infinity < NaN // false\n")])])]),v("p",[v("strong",[a._v("（2）运算规则")])]),a._v(" "),v("p",[v("code",[a._v("Infinity")]),a._v("的四则运算，符合无穷的数学计算规则。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("5 * Infinity // Infinity\n5 - Infinity // -Infinity\nInfinity / 5 // Infinity\n5 / Infinity // 0\n")])])]),v("p",[a._v("0乘以"),v("code",[a._v("Infinity")]),a._v("，返回"),v("code",[a._v("NaN")]),a._v("；0除以"),v("code",[a._v("Infinity")]),a._v("，返回"),v("code",[a._v("0")]),a._v("；"),v("code",[a._v("Infinity")]),a._v("除以0，返回"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("0 * Infinity // NaN\n0 / Infinity // 0\nInfinity / 0 // Infinity\n")])])]),v("p",[v("code",[a._v("Infinity")]),a._v("加上或乘以"),v("code",[a._v("Infinity")]),a._v("，返回的还是"),v("code",[a._v("Infinity")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Infinity + Infinity // Infinity\nInfinity * Infinity // Infinity\n")])])]),v("p",[v("code",[a._v("Infinity")]),a._v("减去或除以"),v("code",[a._v("Infinity")]),a._v("，得到"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Infinity - Infinity // NaN\nInfinity / Infinity // NaN\n")])])]),v("p",[v("code",[a._v("Infinity")]),a._v("与"),v("code",[a._v("null")]),a._v("计算时，"),v("code",[a._v("null")]),a._v("会转成0，等同于与"),v("code",[a._v("0")]),a._v("的计算。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("null * Infinity // NaN\nnull / Infinity // 0\nInfinity / null // Infinity\n")])])]),v("p",[v("code",[a._v("Infinity")]),a._v("与"),v("code",[a._v("undefined")]),a._v("计算，返回的都是"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("undefined + Infinity // NaN\nundefined - Infinity // NaN\nundefined * Infinity // NaN\nundefined / Infinity // NaN\nInfinity / undefined // NaN\n")])])]),v("h3",{attrs:{id:"与数值相关的全局方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与数值相关的全局方法"}},[a._v("#")]),a._v(" 与数值相关的全局方法")]),a._v(" "),v("h4",{attrs:{id:"parseint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parseint"}},[a._v("#")]),a._v(" parseInt()")]),a._v(" "),v("p",[v("strong",[a._v("（1）基本用法")])]),a._v(" "),v("p",[v("code",[a._v("parseInt")]),a._v("方法用于将字符串转为整数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('123') // 123\n")])])]),v("p",[a._v("如果字符串头部有空格，空格会被自动去除。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('   81') // 81\n")])])]),v("p",[a._v("如果"),v("code",[a._v("parseInt")]),a._v("的参数不是字符串，则会先转为字符串再转换。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt(1.23) // 1\n// 等同于\nparseInt('1.23') // 1\n")])])]),v("p",[a._v("字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('8a') // 8\nparseInt('12**') // 12\nparseInt('12.34') // 12\nparseInt('15e2') // 15\nparseInt('15px') // 15\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("parseInt")]),a._v("的参数都是字符串，结果只返回字符串头部可以转为数字的部分。")]),a._v(" "),v("p",[a._v("如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('abc') // NaN\nparseInt('.3') // NaN\nparseInt('') // NaN\nparseInt('+') // NaN\nparseInt('+1') // 1\n")])])]),v("p",[a._v("所以，"),v("code",[a._v("parseInt")]),a._v("的返回值只有两种可能，要么是一个十进制整数，要么是"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("p",[a._v("如果字符串以"),v("code",[a._v("0x")]),a._v("或"),v("code",[a._v("0X")]),a._v("开头，"),v("code",[a._v("parseInt")]),a._v("会将其按照十六进制数解析。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('0x10') // 16\n")])])]),v("p",[a._v("如果字符串以"),v("code",[a._v("0")]),a._v("开头，将其按照10进制解析。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('011') // 11\n")])])]),v("p",[a._v("对于那些会自动转为科学计数法的数字，"),v("code",[a._v("parseInt")]),a._v("会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt(1000000000000000000000.5) // 1\n// 等同于\nparseInt('1e+21') // 1\n\nparseInt(0.0000008) // 8\n// 等同于\nparseInt('8e-7') // 8\n")])])]),v("p",[v("strong",[a._v("（2）进制转换")])]),a._v(" "),v("p",[v("code",[a._v("parseInt")]),a._v("方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，"),v("code",[a._v("parseInt")]),a._v("的第二个参数为10，即默认是十进制转十进制。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('1000') // 1000\n// 等同于\nparseInt('1000', 10) // 1000\n")])])]),v("p",[a._v("下面是转换指定进制的数的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('1000', 2) // 8\nparseInt('1000', 6) // 216\nparseInt('1000', 8) // 512\n")])])]),v("p",[a._v("上面代码中，二进制、六进制、八进制的"),v("code",[a._v("1000")]),a._v("，分别等于十进制的8、216和512。这意味着，可以用"),v("code",[a._v("parseInt")]),a._v("方法进行进制的转换。")]),a._v(" "),v("p",[a._v("如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回"),v("code",[a._v("NaN")]),a._v("。如果第二个参数是"),v("code",[a._v("0")]),a._v("、"),v("code",[a._v("undefined")]),a._v("和"),v("code",[a._v("null")]),a._v("，则直接忽略。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('10', 37) // NaN\nparseInt('10', 1) // NaN\nparseInt('10', 0) // 10\nparseInt('10', null) // 10\nparseInt('10', undefined) // 10\n")])])]),v("p",[a._v("如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt('1546', 2) // 1\nparseInt('546', 2) // NaN\n")])])]),v("p",[a._v("上面代码中，对于二进制来说，"),v("code",[a._v("1")]),a._v("是有意义的字符，"),v("code",[a._v("5")]),a._v("、"),v("code",[a._v("4")]),a._v("、"),v("code",[a._v("6")]),a._v("都是无意义的字符，所以第一行返回1，第二行返回"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("p",[a._v("前面说过，如果"),v("code",[a._v("parseInt")]),a._v("的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt(0x11, 36) // 43\nparseInt(0x11, 2) // 1\n\n// 等同于\nparseInt(String(0x11), 36)\nparseInt(String(0x11), 2)\n\n// 等同于\nparseInt('17', 36)\nparseInt('17', 2)\n")])])]),v("p",[a._v("上面代码中，十六进制的"),v("code",[a._v("0x11")]),a._v("会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串"),v("code",[a._v("17")]),a._v("，最后返回结果"),v("code",[a._v("43")]),a._v("和"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("p",[a._v("这种处理方式，对于八进制的前缀0，尤其需要注意。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseInt(011, 2) // NaN\n\n// 等同于\nparseInt(String(011), 2)\n\n// 等同于\nparseInt(String(9), 2)\n")])])]),v("p",[a._v("上面代码中，第一行的"),v("code",[a._v("011")]),a._v("会被先转为字符串"),v("code",[a._v("9")]),a._v("，因为"),v("code",[a._v("9")]),a._v("不是二进制的有效字符，所以返回"),v("code",[a._v("NaN")]),a._v("。如果直接计算"),v("code",[a._v("parseInt('011', 2)")]),a._v("，"),v("code",[a._v("011")]),a._v("则是会被当作二进制处理，返回3。")]),a._v(" "),v("p",[a._v("JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个"),v("code",[a._v("0")]),a._v("。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。")]),a._v(" "),v("h4",{attrs:{id:"parsefloat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parsefloat"}},[a._v("#")]),a._v(" parseFloat()")]),a._v(" "),v("p",[v("code",[a._v("parseFloat")]),a._v("方法用于将一个字符串转为浮点数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat('3.14') // 3.14\n")])])]),v("p",[a._v("如果字符串符合科学计数法，则会进行相应的转换。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat('314e-2') // 3.14\nparseFloat('0.0314E+2') // 3.14\n")])])]),v("p",[a._v("如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat('3.14more non-digit characters') // 3.14\n")])])]),v("p",[v("code",[a._v("parseFloat")]),a._v("方法会自动过滤字符串前导的空格。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat('\\t\\v\\r12.34\\n ') // 12.34\n")])])]),v("p",[a._v("如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat([]) // NaN\nparseFloat('FF2') // NaN\nparseFloat('') // NaN\n")])])]),v("p",[a._v("上面代码中，尤其值得注意，"),v("code",[a._v("parseFloat")]),a._v("会将空字符串转为"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("p",[a._v("这些特点使得"),v("code",[a._v("parseFloat")]),a._v("的转换结果不同于"),v("code",[a._v("Number")]),a._v("函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("parseFloat(true)  // NaN\nNumber(true) // 1\n\nparseFloat(null) // NaN\nNumber(null) // 0\n\nparseFloat('') // NaN\nNumber('') // 0\n\nparseFloat('123.45#') // 123.45\nNumber('123.45#') // NaN\n")])])]),v("h4",{attrs:{id:"isnan"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#isnan"}},[a._v("#")]),a._v(" isNaN()")]),a._v(" "),v("p",[v("code",[a._v("isNaN")]),a._v("方法可以用来判断一个值是否为"),v("code",[a._v("NaN")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("isNaN(NaN) // true\nisNaN(123) // false\n")])])]),v("p",[a._v("但是，"),v("code",[a._v("isNaN")]),a._v("只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成"),v("code",[a._v("NaN")]),a._v("，所以最后返回"),v("code",[a._v("true")]),a._v("，这一点要特别引起注意。也就是说，"),v("code",[a._v("isNaN")]),a._v("为"),v("code",[a._v("true")]),a._v("的值，有可能不是"),v("code",[a._v("NaN")]),a._v("，而是一个字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("isNaN('Hello') // true\n// 相当于\nisNaN(Number('Hello')) // true\n")])])]),v("p",[a._v("出于同样的原因，对于对象和数组，"),v("code",[a._v("isNaN")]),a._v("也返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("isNaN({}) // true\n// 等同于\nisNaN(Number({})) // true\n\nisNaN(['xzy']) // true\n// 等同于\nisNaN(Number(['xzy'])) // true\n")])])]),v("p",[a._v("但是，对于空数组和只有一个数值成员的数组，"),v("code",[a._v("isNaN")]),a._v("返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("isNaN([]) // false\nisNaN([123]) // false\nisNaN(['123']) // false\n")])])]),v("p",[a._v("上面代码之所以返回"),v("code",[a._v("false")]),a._v("，原因是这些数组能被"),v("code",[a._v("Number")]),a._v("函数转成数值，请参见《数据类型转换》一章。")]),a._v(" "),v("p",[a._v("因此，使用"),v("code",[a._v("isNaN")]),a._v("之前，最好判断一下数据类型。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function myIsNaN(value) {\n  return typeof value === 'number' && isNaN(value);\n}\n")])])]),v("p",[a._v("判断"),v("code",[a._v("NaN")]),a._v("更可靠的方法是，利用"),v("code",[a._v("NaN")]),a._v("为唯一不等于自身的值的这个特点，进行判断。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function myIsNaN(value) {\n  return value !== value;\n}\n")])])]),v("h4",{attrs:{id:"isfinite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#isfinite"}},[a._v("#")]),a._v(" isFinite()")]),a._v(" "),v("p",[v("code",[a._v("isFinite")]),a._v("方法返回一个布尔值，表示某个值是否为正常的数值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("isFinite(Infinity) // false\nisFinite(-Infinity) // false\nisFinite(NaN) // false\nisFinite(undefined) // false\nisFinite(null) // true\nisFinite(-1) // true\n")])])]),v("p",[a._v("除了"),v("code",[a._v("Infinity")]),a._v("、"),v("code",[a._v("-Infinity")]),a._v("、"),v("code",[a._v("NaN")]),a._v("和"),v("code",[a._v("undefined")]),a._v("这几个值会返回"),v("code",[a._v("false")]),a._v("，"),v("code",[a._v("isFinite")]),a._v("对于其他的数值都会返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"参考链接-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-3"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Dr. Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2012/04/number-encoding.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("How numbers are encoded in JavaScript"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Humphry, "),v("a",{attrs:{href:"http://blog.segmentfault.com/humphry/1190000000407658",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript 中 Number 的一些表示上/下限"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"字符串"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[a._v("#")]),a._v(" 字符串")]),a._v(" "),v("h3",{attrs:{id:"概述-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("h4",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),v("p",[a._v("字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'abc'\n\"abc\"\n")])])]),v("p",[a._v("单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('\'key = "value"\'\n"It\'s a long journey"\n')])])]),v("p",[a._v("上面两个都是合法的字符串。")]),a._v(" "),v("p",[a._v("如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('\'Did she say \\\'Hello\\\'?\'\n// "Did she say \'Hello\'?"\n\n"Did she say \\"Hello\\"?"\n// "Did she say "Hello"?"\n')])])]),v("p",[a._v("由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。")]),a._v(" "),v("p",[a._v("字符串默认只能写在一行内，分成多行将会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n")])])]),v("p",[a._v("上面代码将一个字符串分成三行，JavaScript 就会报错。")]),a._v(" "),v("p",[a._v("如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var longString = 'Long \\\nlong \\\nlong \\\nstring';\n\nlongString\n// \"Long long long string\"\n")])])]),v("p",[a._v("上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。")]),a._v(" "),v("p",[a._v("连接运算符（"),v("code",[a._v("+")]),a._v("）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var longString = 'Long '\n  + 'long '\n  + 'long '\n  + 'string';\n")])])]),v("p",[a._v("如果想输出多行字符串，有一种利用多行注释的变通方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(function () { /*\nline 1\nline 2\nline 3\n*/}).toString().split('\\n').slice(1, -1).join('\\n')\n// \"line 1\n// line 2\n// line 3\"\n")])])]),v("p",[a._v("上面的例子中，输出的字符串就是多行。")]),a._v(" "),v("h4",{attrs:{id:"转义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#转义"}},[a._v("#")]),a._v(" 转义")]),a._v(" "),v("p",[a._v("反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。")]),a._v(" "),v("p",[a._v("需要用反斜杠转义的特殊字符，主要有下面这些。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("\\0")]),a._v(" ：null（"),v("code",[a._v("\\u0000")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\b")]),a._v(" ：后退键（"),v("code",[a._v("\\u0008")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\f")]),a._v(" ：换页符（"),v("code",[a._v("\\u000C")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\n")]),a._v(" ：换行符（"),v("code",[a._v("\\u000A")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\r")]),a._v(" ：回车键（"),v("code",[a._v("\\u000D")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\t")]),a._v(" ：制表符（"),v("code",[a._v("\\u0009")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\v")]),a._v(" ：垂直制表符（"),v("code",[a._v("\\u000B")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\'")]),a._v(" ：单引号（"),v("code",[a._v("\\u0027")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v('\\"')]),a._v(" ：双引号（"),v("code",[a._v("\\u0022")]),a._v("）")]),a._v(" "),v("li",[v("code",[a._v("\\\\")]),a._v(" ：反斜杠（"),v("code",[a._v("\\u005C")]),a._v("）")])]),a._v(" "),v("p",[a._v("上面这些字符前面加上反斜杠，都表示特殊含义。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("console.log('1\\n2')\n// 1\n// 2\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("\\n")]),a._v("表示换行，输出的时候就分成了两行。")]),a._v(" "),v("p",[a._v("反斜杠还有三种特殊用法。")]),a._v(" "),v("p",[a._v("（1）"),v("code",[a._v("\\HHH")])]),a._v(" "),v("p",[a._v("反斜杠后面紧跟三个八进制数（"),v("code",[a._v("000")]),a._v("到"),v("code",[a._v("377")]),a._v("），代表一个字符。"),v("code",[a._v("HHH")]),a._v("对应该字符的 Unicode 码点，比如"),v("code",[a._v("\\251")]),a._v("表示版权符号。显然，这种方法只能输出256种字符。")]),a._v(" "),v("p",[a._v("（2）"),v("code",[a._v("\\xHH")])]),a._v(" "),v("p",[v("code",[a._v("\\x")]),a._v("后面紧跟两个十六进制数（"),v("code",[a._v("00")]),a._v("到"),v("code",[a._v("FF")]),a._v("），代表一个字符。"),v("code",[a._v("HH")]),a._v("对应该字符的 Unicode 码点，比如"),v("code",[a._v("\\xA9")]),a._v("表示版权符号。这种方法也只能输出256种字符。")]),a._v(" "),v("p",[a._v("（3）"),v("code",[a._v("\\uXXXX")])]),a._v(" "),v("p",[v("code",[a._v("\\u")]),a._v("后面紧跟四个十六进制数（"),v("code",[a._v("0000")]),a._v("到"),v("code",[a._v("FFFF")]),a._v("），代表一个字符。"),v("code",[a._v("XXXX")]),a._v("对应该字符的 Unicode 码点，比如"),v("code",[a._v("\\u00A9")]),a._v("表示版权符号。")]),a._v(" "),v("p",[a._v("下面是这三种字符特殊写法的例子。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'\\251' // \"©\"\n'\\xA9' // \"©\"\n'\\u00A9' // \"©\"\n\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n")])])]),v("p",[a._v("如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'\\a'\n// \"a\"\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("a")]),a._v("是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。")]),a._v(" "),v("p",[a._v("如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('"Prev \\\\ Next"\n// "Prev \\ Next"\n')])])]),v("h4",{attrs:{id:"字符串与数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串与数组"}},[a._v("#")]),a._v(" 字符串与数组")]),a._v(" "),v("p",[a._v("字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('var s = \'hello\';\ns[0] // "h"\ns[1] // "e"\ns[4] // "o"\n\n// 直接对字符串使用方括号运算符\n\'hello\'[1] // "e"\n')])])]),v("p",[a._v("如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'abc'[3] // undefined\n'abc'[-1] // undefined\n'abc'['x'] // undefined\n")])])]),v("p",[a._v("但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var s = 'hello';\n\ndelete s[0];\ns // \"hello\"\n\ns[1] = 'a';\ns // \"hello\"\n\ns[5] = '!';\ns // \"hello\"\n")])])]),v("p",[a._v("上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。")]),a._v(" "),v("h4",{attrs:{id:"length-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#length-属性"}},[a._v("#")]),a._v(" length 属性")]),a._v(" "),v("p",[v("code",[a._v("length")]),a._v("属性返回字符串的长度，该属性也是无法改变的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var s = 'hello';\ns.length // 5\n\ns.length = 3;\ns.length // 5\n\ns.length = 7;\ns.length // 5\n")])])]),v("p",[a._v("上面代码表示字符串的"),v("code",[a._v("length")]),a._v("属性无法改变，但是不会报错。")]),a._v(" "),v("h3",{attrs:{id:"字符集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符集"}},[a._v("#")]),a._v(" 字符集")]),a._v(" "),v("p",[a._v("JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。")]),a._v(" "),v("p",[a._v("JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成"),v("code",[a._v("\\uxxxx")]),a._v("的形式，其中"),v("code",[a._v("xxxx")]),a._v("代表该字符的 Unicode 码点。比如，"),v("code",[a._v("\\u00A9")]),a._v("代表版权符号。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var s = '\\u00A9';\ns // \"©\"\n")])])]),v("p",[a._v("解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f\\u006F\\u006F = 'abc';\nfoo // \"abc\"\n")])])]),v("p",[a._v("上面代码中，第一行的变量名"),v("code",[a._v("foo")]),a._v("是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。")]),a._v(" "),v("p",[a._v("我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。")]),a._v(" "),v("p",[a._v("但是，UTF-16 有两种长度：对于码点在"),v("code",[a._v("U+0000")]),a._v("到"),v("code",[a._v("U+FFFF")]),a._v("之间的字符，长度为16位（即2个字节）；对于码点在"),v("code",[a._v("U+10000")]),a._v("到"),v("code",[a._v("U+10FFFF")]),a._v("之间的字符，长度为32位（即4个字节），而且前两个字节在"),v("code",[a._v("0xD800")]),a._v("到"),v("code",[a._v("0xDBFF")]),a._v("之间，后两个字节在"),v("code",[a._v("0xDC00")]),a._v("到"),v("code",[a._v("0xDFFF")]),a._v("之间。举例来说，码点"),v("code",[a._v("U+1D306")]),a._v("对应的字符为"),v("code",[a._v("𝌆，")]),a._v("它写成 UTF-16 就是"),v("code",[a._v("0xD834 0xDF06")]),a._v("。")]),a._v(" "),v("p",[a._v("JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到"),v("code",[a._v("U+FFFF")]),a._v("，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符"),v("code",[a._v("𝌆")]),a._v("，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("'𝌆'.length // 2\n")])])]),v("p",[a._v("上面代码中，JavaScript 认为"),v("code",[a._v("𝌆")]),a._v("的长度为2，而不是1。")]),a._v(" "),v("p",[a._v("总结一下，对于码点在"),v("code",[a._v("U+10000")]),a._v("到"),v("code",[a._v("U+10FFFF")]),a._v("之间的字符，JavaScript 总是认为它们是两个字符（"),v("code",[a._v("length")]),a._v("属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。")]),a._v(" "),v("h3",{attrs:{id:"base64-转码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#base64-转码"}},[a._v("#")]),a._v(" Base64 转码")]),a._v(" "),v("p",[a._v("有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。")]),a._v(" "),v("p",[a._v("所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、"),v("code",[a._v("+")]),a._v("和"),v("code",[a._v("/")]),a._v("这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。")]),a._v(" "),v("p",[a._v("JavaScript 原生提供两个 Base64 相关的方法。")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("btoa()")]),a._v("：任意值转为 Base64 编码")]),a._v(" "),v("li",[v("code",[a._v("atob()")]),a._v("：Base64 编码转为原来的值")])]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var string = 'Hello World!';\nbtoa(string) // \"SGVsbG8gV29ybGQh\"\natob('SGVsbG8gV29ybGQh') // \"Hello World!\"\n")])])]),v("p",[a._v("注意，这两个方法不适合非 ASCII 码的字符，会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("btoa('你好') // 报错\n")])])]),v("p",[a._v("要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function b64Encode(str) {\n  return btoa(encodeURIComponent(str));\n}\n\nfunction b64Decode(str) {\n  return decodeURIComponent(atob(str));\n}\n\nb64Encode('你好') // \"JUU0JUJEJUEwJUU1JUE1JUJE\"\nb64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // \"你好\"\n")])])]),v("h3",{attrs:{id:"参考链接-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-4"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Mathias Bynens, "),v("a",{attrs:{href:"https://mathiasbynens.be/notes/javascript-encoding",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript’s internal character encoding: UCS-2 or UTF-16?"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Mathias Bynens, "),v("a",{attrs:{href:"https://mathiasbynens.be/notes/javascript-unicode",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript has a Unicode problem"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Mozilla Developer Network, "),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa",target:"_blank",rel:"noopener noreferrer"}},[a._v("Window.btoa"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[a._v("#")]),a._v(" 对象")]),a._v(" "),v("h3",{attrs:{id:"概述-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-5"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("h4",{attrs:{id:"生成方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生成方法"}},[a._v("#")]),a._v(" 生成方法")]),a._v(" "),v("p",[a._v("对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。")]),a._v(" "),v("p",[a._v("什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  foo: 'Hello',\n  bar: 'World'\n};\n")])])]),v("p",[a._v("上面代码中，大括号就定义了一个对象，它被赋值给变量"),v("code",[a._v("obj")]),a._v("，所以变量"),v("code",[a._v("obj")]),a._v("就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是"),v("code",[a._v("foo: 'Hello'")]),a._v("，其中"),v("code",[a._v("foo")]),a._v("是“键名”（成员的名称），字符串"),v("code",[a._v("Hello")]),a._v("是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是"),v("code",[a._v("bar: 'World'")]),a._v("，"),v("code",[a._v("bar")]),a._v("是键名，"),v("code",[a._v("World")]),a._v("是键值。两个键值对之间用逗号分隔。")]),a._v(" "),v("h4",{attrs:{id:"键名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#键名"}},[a._v("#")]),a._v(" 键名")]),a._v(" "),v("p",[a._v("对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  'foo': 'Hello',\n  'bar': 'World'\n};\n")])])]),v("p",[a._v("如果键名是数值，会被自动转为字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  1: 'a',\n  3.2: 'b',\n  1e2: true,\n  1e-2: true,\n  .234: true,\n  0xFF: true\n};\n\nobj\n// Object {\n//   1: \"a\",\n//   3.2: \"b\",\n//   100: true,\n//   0.01: true,\n//   0.234: true,\n//   255: true\n// }\n\nobj['100'] // true\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("的所有键名虽然看上去像数值，实际上都被自动转成了字符串。")]),a._v(" "),v("p",[a._v("如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 报错\nvar obj = {\n  1p: 'Hello World'\n};\n\n// 不报错\nvar obj = {\n  '1p': 'Hello World',\n  'h w': 'Hello World',\n  'p+q': 'Hello World'\n};\n")])])]),v("p",[a._v("上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。")]),a._v(" "),v("p",[a._v("对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  p: function (x) {\n    return 2 * x;\n  }\n};\n\nobj.p(1) // 2\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("的属性"),v("code",[a._v("p")]),a._v("，就指向一个函数。")]),a._v(" "),v("p",[a._v("如果属性的值还是一个对象，就形成了链式引用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var o1 = {};\nvar o2 = { bar: 'hello' };\n\no1.foo = o2;\no1.foo.bar // \"hello\"\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("o1")]),a._v("的属性"),v("code",[a._v("foo")]),a._v("指向对象"),v("code",[a._v("o2")]),a._v("，就可以链式引用"),v("code",[a._v("o2")]),a._v("的属性。")]),a._v(" "),v("p",[a._v("对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  p: 123,\n  m: function () { ... },\n}\n")])])]),v("p",[a._v("上面的代码中，"),v("code",[a._v("m")]),a._v("属性后面的那个逗号，有没有都可以。")]),a._v(" "),v("p",[a._v("属性可以动态创建，不必在对象声明时就指定。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\nobj.foo = 123;\nobj.foo // 123\n")])])]),v("p",[a._v("上面代码中，直接对"),v("code",[a._v("obj")]),a._v("对象的"),v("code",[a._v("foo")]),a._v("属性赋值，结果就在运行时创建了"),v("code",[a._v("foo")]),a._v("属性。")]),a._v(" "),v("h4",{attrs:{id:"对象的引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象的引用"}},[a._v("#")]),a._v(" 对象的引用")]),a._v(" "),v("p",[a._v("如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var o1 = {};\nvar o2 = o1;\n\no1.a = 1;\no2.a // 1\n\no2.b = 2;\no1.b // 2\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("o1")]),a._v("和"),v("code",[a._v("o2")]),a._v("指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。")]),a._v(" "),v("p",[a._v("此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var o1 = {};\nvar o2 = o1;\n\no1 = 1;\no2 // {}\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("o1")]),a._v("和"),v("code",[a._v("o2")]),a._v("指向同一个对象，然后"),v("code",[a._v("o1")]),a._v("的值变为1，这时不会对"),v("code",[a._v("o2")]),a._v("产生影响，"),v("code",[a._v("o2")]),a._v("还是指向原来的那个对象。")]),a._v(" "),v("p",[a._v("但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = 1;\nvar y = x;\n\nx = 2;\ny // 1\n")])])]),v("p",[a._v("上面的代码中，当"),v("code",[a._v("x")]),a._v("的值发生变化后，"),v("code",[a._v("y")]),a._v("的值并不变，这就表示"),v("code",[a._v("y")]),a._v("和"),v("code",[a._v("x")]),a._v("并不是指向同一个内存地址。")]),a._v(" "),v("h4",{attrs:{id:"表达式还是语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表达式还是语句"}},[a._v("#")]),a._v(" 表达式还是语句？")]),a._v(" "),v("p",[a._v("对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("{ foo: 123 }\n")])])]),v("p",[a._v("JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含"),v("code",[a._v("foo")]),a._v("属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签"),v("code",[a._v("foo")]),a._v("，指向表达式"),v("code",[a._v("123")]),a._v("。")]),a._v(" "),v("p",[a._v("为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("{ console.log(123) } // 123\n")])])]),v("p",[a._v("上面的语句是一个代码块，而且只有解释为代码块，才能执行。")]),a._v(" "),v("p",[a._v("如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("({ foo: 123 }) // 正确\n({ console.log(123) }) // 报错\n")])])]),v("p",[a._v("这种差异在"),v("code",[a._v("eval")]),a._v("语句（作用是对字符串求值）中反映得最明显。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval('{foo: 123}') // 123\neval('({foo: 123})') // {foo: 123}\n")])])]),v("p",[a._v("上面代码中，如果没有圆括号，"),v("code",[a._v("eval")]),a._v("将其理解为一个代码块；加上圆括号以后，就理解成一个对象。")]),a._v(" "),v("h3",{attrs:{id:"属性的操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的操作"}},[a._v("#")]),a._v(" 属性的操作")]),a._v(" "),v("h4",{attrs:{id:"属性的读取"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的读取"}},[a._v("#")]),a._v(" 属性的读取")]),a._v(" "),v("p",[a._v("读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  p: 'Hello World'\n};\n\nobj.p // \"Hello World\"\nobj['p'] // \"Hello World\"\n")])])]),v("p",[a._v("上面代码分别采用点运算符和方括号运算符，读取属性"),v("code",[a._v("p")]),a._v("。")]),a._v(" "),v("p",[a._v("请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var foo = 'bar';\n\nvar obj = {\n  foo: 1,\n  bar: 2\n};\n\nobj.foo  // 1\nobj[foo]  // 2\n")])])]),v("p",[a._v("上面代码中，引用对象"),v("code",[a._v("obj")]),a._v("的"),v("code",[a._v("foo")]),a._v("属性时，如果使用点运算符，"),v("code",[a._v("foo")]),a._v("就是字符串；如果使用方括号运算符，但是不使用引号，那么"),v("code",[a._v("foo")]),a._v("就是一个变量，指向字符串"),v("code",[a._v("bar")]),a._v("。")]),a._v(" "),v("p",[a._v("方括号运算符内部还可以使用表达式。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("obj['hello' + ' world']\nobj[3 + 3]\n")])])]),v("p",[a._v("数字键可以不加引号，因为会自动转成字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  0.7: 'Hello World'\n};\n\nobj['0.7'] // \"Hello World\"\nobj[0.7] // \"Hello World\"\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("的数字键"),v("code",[a._v("0.7")]),a._v("，加不加引号都可以，因为会被自动转为字符串。")]),a._v(" "),v("p",[a._v("注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  123: 'hello world'\n};\n\nobj.123 // 报错\nobj[123] // \"hello world\"\n")])])]),v("p",[a._v("上面代码的第一个表达式，对数值键名"),v("code",[a._v("123")]),a._v("使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。")]),a._v(" "),v("h4",{attrs:{id:"属性的赋值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的赋值"}},[a._v("#")]),a._v(" 属性的赋值")]),a._v(" "),v("p",[a._v("点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\n\nobj.foo = 'Hello';\nobj['bar'] = 'World';\n")])])]),v("p",[a._v("上面代码中，分别使用点运算符和方括号运算符，对属性赋值。")]),a._v(" "),v("p",[a._v("JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = { p: 1 };\n\n// 等价于\n\nvar obj = {};\nobj.p = 1;\n")])])]),v("h4",{attrs:{id:"属性的查看"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的查看"}},[a._v("#")]),a._v(" 属性的查看")]),a._v(" "),v("p",[a._v("查看一个对象本身的所有属性，可以使用"),v("code",[a._v("Object.keys")]),a._v("方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  key1: 1,\n  key2: 2\n};\n\nObject.keys(obj);\n// ['key1', 'key2']\n")])])]),v("h4",{attrs:{id:"属性的删除-delete-命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的删除-delete-命令"}},[a._v("#")]),a._v(" 属性的删除：delete 命令")]),a._v(" "),v("p",[v("code",[a._v("delete")]),a._v("命令用于删除对象的属性，删除成功后返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('var obj = { p: 1 };\nObject.keys(obj) // ["p"]\n\ndelete obj.p // true\nobj.p // undefined\nObject.keys(obj) // []\n')])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("delete")]),a._v("命令删除对象"),v("code",[a._v("obj")]),a._v("的"),v("code",[a._v("p")]),a._v("属性。删除后，再读取"),v("code",[a._v("p")]),a._v("属性就会返回"),v("code",[a._v("undefined")]),a._v("，而且"),v("code",[a._v("Object.keys")]),a._v("方法的返回值也不再包括该属性。")]),a._v(" "),v("p",[a._v("注意，删除一个不存在的属性，"),v("code",[a._v("delete")]),a._v("不报错，而且返回"),v("code",[a._v("true")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\ndelete obj.p // true\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("并没有"),v("code",[a._v("p")]),a._v("属性，但是"),v("code",[a._v("delete")]),a._v("命令照样返回"),v("code",[a._v("true")]),a._v("。因此，不能根据"),v("code",[a._v("delete")]),a._v("命令的结果，认定某个属性是存在的。")]),a._v(" "),v("p",[a._v("只有一种情况，"),v("code",[a._v("delete")]),a._v("命令会返回"),v("code",[a._v("false")]),a._v("，那就是该属性存在，且不得删除。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = Object.defineProperty({}, 'p', {\n  value: 123,\n  configurable: false\n});\n\nobj.p // 123\ndelete obj.p // false\n")])])]),v("p",[a._v("上面代码之中，对象"),v("code",[a._v("obj")]),a._v("的"),v("code",[a._v("p")]),a._v("属性是不能删除的，所以"),v("code",[a._v("delete")]),a._v("命令返回"),v("code",[a._v("false")]),a._v("（关于"),v("code",[a._v("Object.defineProperty")]),a._v("方法的介绍，请看《标准库》的 Object 对象一章）。")]),a._v(" "),v("p",[a._v("另外，需要注意的是，"),v("code",[a._v("delete")]),a._v("命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\ndelete obj.toString // true\nobj.toString // function toString() { [native code] }\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("toString")]),a._v("是对象"),v("code",[a._v("obj")]),a._v("继承的属性，虽然"),v("code",[a._v("delete")]),a._v("命令返回"),v("code",[a._v("true")]),a._v("，但该属性并没有被删除，依然存在。这个例子还说明，即使"),v("code",[a._v("delete")]),a._v("返回"),v("code",[a._v("true")]),a._v("，该属性依然可能读取到值。")]),a._v(" "),v("h4",{attrs:{id:"属性是否存在-in-运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性是否存在-in-运算符"}},[a._v("#")]),a._v(" 属性是否存在：in 运算符")]),a._v(" "),v("p",[v("code",[a._v("in")]),a._v("运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回"),v("code",[a._v("true")]),a._v("，否则返回"),v("code",[a._v("false")]),a._v("。它的左边是一个字符串，表示属性名，右边是一个对象。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = { p: 1 };\n'p' in obj // true\n'toString' in obj // true\n")])])]),v("p",[v("code",[a._v("in")]),a._v("运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象"),v("code",[a._v("obj")]),a._v("本身并没有"),v("code",[a._v("toString")]),a._v("属性，但是"),v("code",[a._v("in")]),a._v("运算符会返回"),v("code",[a._v("true")]),a._v("，因为这个属性是继承的。")]),a._v(" "),v("p",[a._v("这时，可以使用对象的"),v("code",[a._v("hasOwnProperty")]),a._v("方法判断一下，是否为对象自身的属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\nif ('toString' in obj) {\n  console.log(obj.hasOwnProperty('toString')) // false\n}\n")])])]),v("h4",{attrs:{id:"属性的遍历-for-in-循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性的遍历-for-in-循环"}},[a._v("#")]),a._v(" 属性的遍历：for...in 循环")]),a._v(" "),v("p",[v("code",[a._v("for...in")]),a._v("循环用来遍历一个对象的全部属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {a: 1, b: 2, c: 3};\n\nfor (var i in obj) {\n  console.log('键名：', i);\n  console.log('键值：', obj[i]);\n}\n// 键名： a\n// 键值： 1\n// 键名： b\n// 键值： 2\n// 键名： c\n// 键值： 3\n")])])]),v("p",[v("code",[a._v("for...in")]),a._v("循环有两个使用注意点。")]),a._v(" "),v("ul",[v("li",[a._v("它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。")]),a._v(" "),v("li",[a._v("它不仅遍历对象自身的属性，还遍历继承的属性。")])]),a._v(" "),v("p",[a._v("举例来说，对象都继承了"),v("code",[a._v("toString")]),a._v("属性，但是"),v("code",[a._v("for...in")]),a._v("循环不会遍历到这个属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\n\n// toString 属性是存在的\nobj.toString // toString() { [native code] }\n\nfor (var p in obj) {\n  console.log(p);\n} // 没有任何输出\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("继承了"),v("code",[a._v("toString")]),a._v("属性，该属性不会被"),v("code",[a._v("for...in")]),a._v("循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。")]),a._v(" "),v("p",[a._v("如果继承的属性是可遍历的，那么就会被"),v("code",[a._v("for...in")]),a._v("循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用"),v("code",[a._v("for...in")]),a._v("的时候，应该结合使用"),v("code",[a._v("hasOwnProperty")]),a._v("方法，在循环内部判断一下，某个属性是否为对象自身的属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var person = { name: '老张' };\n\nfor (var key in person) {\n  if (person.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// name\n")])])]),v("h3",{attrs:{id:"with-语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-语句"}},[a._v("#")]),a._v(" with 语句")]),a._v(" "),v("p",[v("code",[a._v("with")]),a._v("语句的格式如下：")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("with (对象) {\n  语句;\n}\n")])])]),v("p",[a._v("它的作用是操作同一个对象的多个属性时，提供一些书写的方便。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 例一\nvar obj = {\n  p1: 1,\n  p2: 2,\n};\nwith (obj) {\n  p1 = 4;\n  p2 = 5;\n}\n// 等同于\nobj.p1 = 4;\nobj.p2 = 5;\n\n// 例二\nwith (document.links[0]){\n  console.log(href);\n  console.log(title);\n  console.log(style);\n}\n// 等同于\nconsole.log(document.links[0].href);\nconsole.log(document.links[0].title);\nconsole.log(document.links[0].style);\n")])])]),v("p",[a._v("注意，如果"),v("code",[a._v("with")]),a._v("区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {};\nwith (obj) {\n  p1 = 4;\n  p2 = 5;\n}\n\nobj.p1 // undefined\np1 // 4\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("并没有"),v("code",[a._v("p1")]),a._v("属性，对"),v("code",[a._v("p1")]),a._v("赋值等于创造了一个全局变量"),v("code",[a._v("p1")]),a._v("。正确的写法应该是，先定义对象"),v("code",[a._v("obj")]),a._v("的属性"),v("code",[a._v("p1")]),a._v("，然后在"),v("code",[a._v("with")]),a._v("区块内操作它。")]),a._v(" "),v("p",[a._v("这是因为"),v("code",[a._v("with")]),a._v("区块没有改变作用域，它的内部依然是当前作用域。这造成了"),v("code",[a._v("with")]),a._v("语句的一个很大的弊病，就是绑定对象不明确。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("with (obj) {\n  console.log(x);\n}\n")])])]),v("p",[a._v("单纯从上面的代码块，根本无法判断"),v("code",[a._v("x")]),a._v("到底是全局变量，还是对象"),v("code",[a._v("obj")]),a._v("的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用"),v("code",[a._v("with")]),a._v("语句，可以考虑用一个临时变量代替"),v("code",[a._v("with")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("with(obj1.obj2.obj3) {\n  console.log(p1 + p2);\n}\n\n// 可以写成\nvar temp = obj1.obj2.obj3;\nconsole.log(temp.p1 + temp.p2);\n")])])]),v("h3",{attrs:{id:"参考链接-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-5"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Dr. Axel Rauschmayer，"),v("a",{attrs:{href:"http://www.2ality.com/2012/10/javascript-properties.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Object properties in JavaScript"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Lakshan Perera, "),v("a",{attrs:{href:"http://www.laktek.com/2012/12/29/revisiting-javascript-objects/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Revisiting JavaScript Objects"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Angus Croll, "),v("a",{attrs:{href:"https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/",target:"_blank",rel:"noopener noreferrer"}},[a._v("The Secret Life of JavaScript Primitives"),v("OutboundLink")],1),a._v("i")]),a._v(" "),v("li",[a._v("Dr. Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2011/06/with-statement.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript’s with statement and why it’s deprecated"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[a._v("#")]),a._v(" 函数")]),a._v(" "),v("p",[a._v("函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。")]),a._v(" "),v("h3",{attrs:{id:"概述-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-6"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("h4",{attrs:{id:"函数的声明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的声明"}},[a._v("#")]),a._v(" 函数的声明")]),a._v(" "),v("p",[a._v("JavaScript 有三种声明函数的方法。")]),a._v(" "),v("p",[v("strong",[a._v("（1）function 命令")])]),a._v(" "),v("p",[v("code",[a._v("function")]),a._v("命令声明的代码区块，就是一个函数。"),v("code",[a._v("function")]),a._v("命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function print(s) {\n  console.log(s);\n}\n")])])]),v("p",[a._v("上面的代码命名了一个"),v("code",[a._v("print")]),a._v("函数，以后使用"),v("code",[a._v("print()")]),a._v("这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。")]),a._v(" "),v("p",[v("strong",[a._v("（2）函数表达式")])]),a._v(" "),v("p",[a._v("除了用"),v("code",[a._v("function")]),a._v("命令声明函数，还可以采用变量赋值的写法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var print = function(s) {\n  console.log(s);\n};\n")])])]),v("p",[a._v("这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。")]),a._v(" "),v("p",[a._v("采用函数表达式声明函数时，"),v("code",[a._v("function")]),a._v("命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var print = function x(){\n  console.log(typeof x);\n};\n\nx\n// ReferenceError: x is not defined\n\nprint()\n// function\n")])])]),v("p",[a._v("上面代码在函数表达式中，加入了函数名"),v("code",[a._v("x")]),a._v("。这个"),v("code",[a._v("x")]),a._v("只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function f() {};\n")])])]),v("p",[a._v("需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。")]),a._v(" "),v("p",[v("strong",[a._v("（3）Function 构造函数")])]),a._v(" "),v("p",[a._v("第三种声明函数的方式是"),v("code",[a._v("Function")]),a._v("构造函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var add = new Function(\n  'x',\n  'y',\n  'return x + y'\n);\n\n// 等同于\nfunction add(x, y) {\n  return x + y;\n}\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("Function")]),a._v("构造函数接受三个参数，除了最后一个参数是"),v("code",[a._v("add")]),a._v("函数的“函数体”，其他参数都是"),v("code",[a._v("add")]),a._v("函数的参数。")]),a._v(" "),v("p",[a._v("你可以传递任意数量的参数给"),v("code",[a._v("Function")]),a._v("构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var foo = new Function(\n  'return \"hello world\";'\n);\n\n// 等同于\nfunction foo() {\n  return 'hello world';\n}\n")])])]),v("p",[v("code",[a._v("Function")]),a._v("构造函数可以不使用"),v("code",[a._v("new")]),a._v("命令，返回结果完全一样。")]),a._v(" "),v("p",[a._v("总的来说，这种声明函数的方式非常不直观，几乎无人使用。")]),a._v(" "),v("h4",{attrs:{id:"函数的重复声明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的重复声明"}},[a._v("#")]),a._v(" 函数的重复声明")]),a._v(" "),v("p",[a._v("如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f() {\n  console.log(1);\n}\nf() // 2\n\nfunction f() {\n  console.log(2);\n}\nf() // 2\n")])])]),v("p",[a._v("上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。")]),a._v(" "),v("h4",{attrs:{id:"圆括号运算符-return-语句和递归"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#圆括号运算符-return-语句和递归"}},[a._v("#")]),a._v(" 圆括号运算符，return 语句和递归")]),a._v(" "),v("p",[a._v("调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function add(x, y) {\n  return x + y;\n}\n\nadd(1, 1) // 2\n")])])]),v("p",[a._v("上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。")]),a._v(" "),v("p",[a._v("函数体内部的"),v("code",[a._v("return")]),a._v("语句，表示返回。JavaScript 引擎遇到"),v("code",[a._v("return")]),a._v("语句，就直接返回"),v("code",[a._v("return")]),a._v("后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，"),v("code",[a._v("return")]),a._v("语句所带的那个表达式，就是函数的返回值。"),v("code",[a._v("return")]),a._v("语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("p",[a._v("函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function fib(num) {\n  if (num === 0) return 0;\n  if (num === 1) return 1;\n  return fib(num - 2) + fib(num - 1);\n}\n\nfib(6) // 8\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("fib")]),a._v("函数内部又调用了"),v("code",[a._v("fib")]),a._v("，计算得到斐波那契数列的第6个元素是8。")]),a._v(" "),v("h4",{attrs:{id:"第一等公民"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一等公民"}},[a._v("#")]),a._v(" 第一等公民")]),a._v(" "),v("p",[a._v("JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。")]),a._v(" "),v("p",[a._v("由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function add(x, y) {\n  return x + y;\n}\n\n// 将函数赋值给一个变量\nvar operator = add;\n\n// 将函数作为参数和返回值\nfunction a(op){\n  return op;\n}\na(add)(1, 1)\n// 2\n")])])]),v("h4",{attrs:{id:"函数名的提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数名的提升"}},[a._v("#")]),a._v(" 函数名的提升")]),a._v(" "),v("p",[a._v("JavaScript 引擎将函数名视同变量名，所以采用"),v("code",[a._v("function")]),a._v("命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("f();\n\nfunction f() {}\n")])])]),v("p",[a._v("表面上，上面代码好像在声明之前就调用了函数"),v("code",[a._v("f")]),a._v("。但是实际上，由于“变量提升”，函数"),v("code",[a._v("f")]),a._v("被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("f();\nvar f = function (){};\n// TypeError: undefined is not a function\n")])])]),v("p",[a._v("上面的代码等同于下面的形式。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f;\nf();\nf = function () {};\n")])])]),v("p",[a._v("上面代码第二行，调用"),v("code",[a._v("f")]),a._v("的时候，"),v("code",[a._v("f")]),a._v("只是被声明了，还没有被赋值，等于"),v("code",[a._v("undefined")]),a._v("，所以会报错。")]),a._v(" "),v("p",[a._v("注意，如果像下面例子那样，采用"),v("code",[a._v("function")]),a._v("命令和"),v("code",[a._v("var")]),a._v("赋值语句声明同一个函数，由于存在函数提升，最后会采用"),v("code",[a._v("var")]),a._v("赋值语句的定义。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function () {\n  console.log('1');\n}\n\nfunction f() {\n  console.log('2');\n}\n\nf() // 1\n")])])]),v("p",[a._v("上面例子中，表面上后面声明的函数"),v("code",[a._v("f")]),a._v("，应该覆盖前面的"),v("code",[a._v("var")]),a._v("赋值语句，但是由于存在函数提升，实际上正好反过来。")]),a._v(" "),v("h3",{attrs:{id:"函数的属性和方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的属性和方法"}},[a._v("#")]),a._v(" 函数的属性和方法")]),a._v(" "),v("h4",{attrs:{id:"name-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#name-属性"}},[a._v("#")]),a._v(" name 属性")]),a._v(" "),v("p",[a._v("函数的"),v("code",[a._v("name")]),a._v("属性返回函数的名字。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('function f1() {}\nf1.name // "f1"\n')])])]),v("p",[a._v("如果是通过变量赋值定义的函数，那么"),v("code",[a._v("name")]),a._v("属性返回变量名。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('var f2 = function () {};\nf2.name // "f2"\n')])])]),v("p",[a._v("但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么"),v("code",[a._v("name")]),a._v("属性返回"),v("code",[a._v("function")]),a._v("关键字之后的那个函数名。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f3 = function myName() {};\nf3.name // 'myName'\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("f3.name")]),a._v("返回函数表达式的名字。注意，真正的函数名还是"),v("code",[a._v("f3")]),a._v("，而"),v("code",[a._v("myName")]),a._v("这个名字只在函数体内部可用。")]),a._v(" "),v("p",[v("code",[a._v("name")]),a._v("属性的一个用处，就是获取参数函数的名字。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var myFunc = function () {};\n\nfunction test(f) {\n  console.log(f.name);\n}\n\ntest(myFunc) // myFunc\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("test")]),a._v("内部通过"),v("code",[a._v("name")]),a._v("属性，就可以知道传入的参数是什么函数。")]),a._v(" "),v("h4",{attrs:{id:"length-属性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#length-属性-2"}},[a._v("#")]),a._v(" length 属性")]),a._v(" "),v("p",[a._v("函数的"),v("code",[a._v("length")]),a._v("属性返回函数预期传入的参数个数，即函数定义之中的参数个数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, b) {}\nf.length // 2\n")])])]),v("p",[a._v("上面代码定义了空函数"),v("code",[a._v("f")]),a._v("，它的"),v("code",[a._v("length")]),a._v("属性就是定义时的参数个数。不管调用时输入了多少个参数，"),v("code",[a._v("length")]),a._v("属性始终等于2。")]),a._v(" "),v("p",[v("code",[a._v("length")]),a._v("属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。")]),a._v(" "),v("h4",{attrs:{id:"tostring"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[a._v("#")]),a._v(" toString()")]),a._v(" "),v("p",[a._v("函数的"),v("code",[a._v("toString()")]),a._v("方法返回一个字符串，内容是函数的源码。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f() {\n  a();\n  b();\n  c();\n}\n\nf.toString()\n// function f() {\n//  a();\n//  b();\n//  c();\n// }\n")])])]),v("p",[a._v("上面示例中，函数"),v("code",[a._v("f")]),a._v("的"),v("code",[a._v("toString()")]),a._v("方法返回了"),v("code",[a._v("f")]),a._v("的源码，包含换行符在内。")]),a._v(" "),v("p",[a._v("对于那些原生的函数，"),v("code",[a._v("toString()")]),a._v("方法返回"),v("code",[a._v("function (){[native code]}")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('Math.sqrt.toString()\n// "function sqrt() { [native code] }"\n')])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("Math.sqrt()")]),a._v("是 JavaScript 引擎提供的原生函数，"),v("code",[a._v("toString()")]),a._v("方法就返回原生代码的提示。")]),a._v(" "),v("p",[a._v("函数内部的注释也可以返回。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('function f() {/*\n  这是一个\n  多行注释\n*/}\n\nf.toString()\n// "function f(){/*\n//   这是一个\n//   多行注释\n// */}"\n')])])]),v("p",[a._v("利用这一点，可以变相实现多行字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var multiline = function (fn) {\n  var arr = fn.toString().split('\\n');\n  return arr.slice(1, arr.length - 1).join('\\n');\n};\n\nfunction f() {/*\n  这是一个\n  多行注释\n*/}\n\nmultiline(f);\n// \" 这是一个\n//   多行注释\"\n")])])]),v("p",[a._v("上面示例中，函数"),v("code",[a._v("f")]),a._v("内部有一个多行注释，"),v("code",[a._v("toString()")]),a._v("方法拿到"),v("code",[a._v("f")]),a._v("的源码后，去掉首尾两行，就得到了一个多行字符串。")]),a._v(" "),v("h3",{attrs:{id:"函数作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[a._v("#")]),a._v(" 函数作用域")]),a._v(" "),v("h4",{attrs:{id:"定义-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),v("p",[a._v("作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。")]),a._v(" "),v("p",[a._v("对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var v = 1;\n\nfunction f() {\n  console.log(v);\n}\n\nf()\n// 1\n")])])]),v("p",[a._v("上面的代码表明，函数"),v("code",[a._v("f")]),a._v("内部可以读取全局变量"),v("code",[a._v("v")]),a._v("。")]),a._v(" "),v("p",[a._v("在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(){\n  var v = 1;\n}\n\nv // ReferenceError: v is not defined\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("v")]),a._v("在函数内部定义，所以是一个局部变量，函数之外就无法读取。")]),a._v(" "),v("p",[a._v("函数内部定义的变量，会在该作用域内覆盖同名全局变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var v = 1;\n\nfunction f(){\n  var v = 2;\n  console.log(v);\n}\n\nf() // 2\nv // 1\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("v")]),a._v("同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量"),v("code",[a._v("v")]),a._v("覆盖了全局变量"),v("code",[a._v("v")]),a._v("。")]),a._v(" "),v("p",[a._v("注意，对于"),v("code",[a._v("var")]),a._v("命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if (true) {\n  var x = 5;\n}\nconsole.log(x);  // 5\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("x")]),a._v("在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。")]),a._v(" "),v("h4",{attrs:{id:"函数内部的变量提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数内部的变量提升"}},[a._v("#")]),a._v(" 函数内部的变量提升")]),a._v(" "),v("p",[a._v("与全局作用域一样，函数作用域内部也会产生“变量提升”现象。"),v("code",[a._v("var")]),a._v("命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function foo(x) {\n  if (x > 100) {\n    var tmp = x - 100;\n  }\n}\n\n// 等同于\nfunction foo(x) {\n  var tmp;\n  if (x > 100) {\n    tmp = x - 100;\n  };\n}\n")])])]),v("h4",{attrs:{id:"函数本身的作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数本身的作用域"}},[a._v("#")]),a._v(" 函数本身的作用域")]),a._v(" "),v("p",[a._v("函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1;\nvar x = function () {\n  console.log(a);\n};\n\nfunction f() {\n  var a = 2;\n  x();\n}\n\nf() // 1\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("x")]),a._v("是在函数"),v("code",[a._v("f")]),a._v("的外部声明的，所以它的作用域绑定外层，内部变量"),v("code",[a._v("a")]),a._v("不会到函数"),v("code",[a._v("f")]),a._v("体内取值，所以输出"),v("code",[a._v("1")]),a._v("，而不是"),v("code",[a._v("2")]),a._v("。")]),a._v(" "),v("p",[a._v("总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。")]),a._v(" "),v("p",[a._v("很容易犯错的一点是，如果函数"),v("code",[a._v("A")]),a._v("调用函数"),v("code",[a._v("B")]),a._v("，却没考虑到函数"),v("code",[a._v("B")]),a._v("不会引用函数"),v("code",[a._v("A")]),a._v("的内部变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var x = function () {\n  console.log(a);\n};\n\nfunction y(f) {\n  var a = 2;\n  f();\n}\n\ny(x)\n// ReferenceError: a is not defined\n")])])]),v("p",[a._v("上面代码将函数"),v("code",[a._v("x")]),a._v("作为参数，传入函数"),v("code",[a._v("y")]),a._v("。但是，函数"),v("code",[a._v("x")]),a._v("是在函数"),v("code",[a._v("y")]),a._v("体外声明的，作用域绑定外层，因此找不到函数"),v("code",[a._v("y")]),a._v("的内部变量"),v("code",[a._v("a")]),a._v("，导致报错。")]),a._v(" "),v("p",[a._v("同样的，函数体内部声明的函数，作用域绑定函数体内部。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function foo() {\n  var x = 1;\n  function bar() {\n    console.log(x);\n  }\n  return bar;\n}\n\nvar x = 2;\nvar f = foo();\nf() // 1\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("foo")]),a._v("内部声明了一个函数"),v("code",[a._v("bar")]),a._v("，"),v("code",[a._v("bar")]),a._v("的作用域绑定"),v("code",[a._v("foo")]),a._v("。当我们在"),v("code",[a._v("foo")]),a._v("外部取出"),v("code",[a._v("bar")]),a._v("执行时，变量"),v("code",[a._v("x")]),a._v("指向的是"),v("code",[a._v("foo")]),a._v("内部的"),v("code",[a._v("x")]),a._v("，而不是"),v("code",[a._v("foo")]),a._v("外部的"),v("code",[a._v("x")]),a._v("。正是这种机制，构成了下文要讲解的“闭包”现象。")]),a._v(" "),v("h3",{attrs:{id:"参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[a._v("#")]),a._v(" 参数")]),a._v(" "),v("h4",{attrs:{id:"概述-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-7"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("p",[a._v("函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function square(x) {\n  return x * x;\n}\n\nsquare(2) // 4\nsquare(3) // 9\n")])])]),v("p",[a._v("上式的"),v("code",[a._v("x")]),a._v("就是"),v("code",[a._v("square")]),a._v("函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。")]),a._v(" "),v("h4",{attrs:{id:"参数的省略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参数的省略"}},[a._v("#")]),a._v(" 参数的省略")]),a._v(" "),v("p",[a._v("函数参数不是必需的，JavaScript 允许省略参数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, b) {\n  return a;\n}\n\nf(1, 2, 3) // 1\nf(1) // 1\nf() // undefined\n\nf.length // 2\n")])])]),v("p",[a._v("上面代码的函数"),v("code",[a._v("f")]),a._v("定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为"),v("code",[a._v("undefined")]),a._v("。需要注意的是，函数的"),v("code",[a._v("length")]),a._v("属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。")]),a._v(" "),v("p",[a._v("但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, b) {\n  return a;\n}\n\nf( , 1) // SyntaxError: Unexpected token ,(…)\nf(undefined, 1) // undefined\n")])])]),v("p",[a._v("上面代码中，如果省略第一个参数，就会报错。")]),a._v(" "),v("h4",{attrs:{id:"传递方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传递方式"}},[a._v("#")]),a._v(" 传递方式")]),a._v(" "),v("p",[a._v("函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var p = 2;\n\nfunction f(p) {\n  p = 3;\n}\nf(p);\n\np // 2\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("p")]),a._v("是一个原始类型的值，传入函数"),v("code",[a._v("f")]),a._v("的方式是传值传递。因此，在函数内部，"),v("code",[a._v("p")]),a._v("的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。")]),a._v(" "),v("p",[a._v("但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = { p: 1 };\n\nfunction f(o) {\n  o.p = 2;\n}\nf(obj);\n\nobj.p // 2\n")])])]),v("p",[a._v("上面代码中，传入函数"),v("code",[a._v("f")]),a._v("的是参数对象"),v("code",[a._v("obj")]),a._v("的地址。因此，在函数内部修改"),v("code",[a._v("obj")]),a._v("的属性"),v("code",[a._v("p")]),a._v("，会影响到原始值。")]),a._v(" "),v("p",[a._v("注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = [1, 2, 3];\n\nfunction f(o) {\n  o = [2, 3, 4];\n}\nf(obj);\n\nobj // [1, 2, 3]\n")])])]),v("p",[a._v("上面代码中，在函数"),v("code",[a._v("f()")]),a._v("内部，参数对象"),v("code",[a._v("obj")]),a._v("被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（"),v("code",[a._v("o")]),a._v("）的值实际是参数"),v("code",[a._v("obj")]),a._v("的地址，重新对"),v("code",[a._v("o")]),a._v("赋值导致"),v("code",[a._v("o")]),a._v("指向另一个地址，保存在原地址上的值当然不受影响。")]),a._v(" "),v("h4",{attrs:{id:"同名参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同名参数"}},[a._v("#")]),a._v(" 同名参数")]),a._v(" "),v("p",[a._v("如果有同名的参数，则取最后出现的那个值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, a) {\n  console.log(a);\n}\n\nf(1, 2) // 2\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f()")]),a._v("有两个参数，且参数名都是"),v("code",[a._v("a")]),a._v("。取值的时候，以后面的"),v("code",[a._v("a")]),a._v("为准，即使后面的"),v("code",[a._v("a")]),a._v("没有值或被省略，也是以其为准。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, a) {\n  console.log(a);\n}\n\nf(1) // undefined\n")])])]),v("p",[a._v("调用函数"),v("code",[a._v("f()")]),a._v("的时候，没有提供第二个参数，"),v("code",[a._v("a")]),a._v("的取值就变成了"),v("code",[a._v("undefined")]),a._v("。这时，如果要获得第一个"),v("code",[a._v("a")]),a._v("的值，可以使用"),v("code",[a._v("arguments")]),a._v("对象。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f(a, a) {\n  console.log(arguments[0]);\n}\n\nf(1) // 1\n")])])]),v("h4",{attrs:{id:"arguments-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arguments-对象"}},[a._v("#")]),a._v(" arguments 对象")]),a._v(" "),v("p",[v("strong",[a._v("（1）定义")])]),a._v(" "),v("p",[a._v("由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是"),v("code",[a._v("arguments")]),a._v("对象的由来。")]),a._v(" "),v("p",[v("code",[a._v("arguments")]),a._v("对象包含了函数运行时的所有参数，"),v("code",[a._v("arguments[0]")]),a._v("就是第一个参数，"),v("code",[a._v("arguments[1]")]),a._v("就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n}\n\nf(1, 2, 3)\n// 1\n// 2\n// 3\n")])])]),v("p",[a._v("正常模式下，"),v("code",[a._v("arguments")]),a._v("对象可以在运行时修改。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 5\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f()")]),a._v("调用时传入的参数，在函数内部被修改成"),v("code",[a._v("3")]),a._v("和"),v("code",[a._v("2")]),a._v("。")]),a._v(" "),v("p",[a._v("严格模式下，"),v("code",[a._v("arguments")]),a._v("对象与函数参数不具有联动关系。也就是说，修改"),v("code",[a._v("arguments")]),a._v("对象不会影响到实际的函数参数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function(a, b) {\n  'use strict'; // 开启严格模式\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 2\n")])])]),v("p",[a._v("上面代码中，函数体内是严格模式，这时修改"),v("code",[a._v("arguments")]),a._v("对象，不会影响到真实参数"),v("code",[a._v("a")]),a._v("和"),v("code",[a._v("b")]),a._v("。")]),a._v(" "),v("p",[a._v("通过"),v("code",[a._v("arguments")]),a._v("对象的"),v("code",[a._v("length")]),a._v("属性，可以判断函数调用时到底带几个参数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f() {\n  return arguments.length;\n}\n\nf(1, 2, 3) // 3\nf(1) // 1\nf() // 0\n")])])]),v("p",[v("strong",[a._v("（2）与数组的关系")])]),a._v(" "),v("p",[a._v("需要注意的是，虽然"),v("code",[a._v("arguments")]),a._v("很像数组，但它是一个对象。数组专有的方法（比如"),v("code",[a._v("slice")]),a._v("和"),v("code",[a._v("forEach")]),a._v("），不能在"),v("code",[a._v("arguments")]),a._v("对象上直接使用。")]),a._v(" "),v("p",[a._v("如果要让"),v("code",[a._v("arguments")]),a._v("对象使用数组方法，真正的解决方法是将"),v("code",[a._v("arguments")]),a._v("转为真正的数组。下面是两种常用的转换方法："),v("code",[a._v("slice")]),a._v("方法和逐一填入新数组。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var args = Array.prototype.slice.call(arguments);\n\n// 或者\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n")])])]),v("p",[v("strong",[a._v("（3）callee 属性")])]),a._v(" "),v("p",[v("code",[a._v("arguments")]),a._v("对象带有一个"),v("code",[a._v("callee")]),a._v("属性，返回它所对应的原函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function () {\n  console.log(arguments.callee === f);\n}\n\nf() // true\n")])])]),v("p",[a._v("可以通过"),v("code",[a._v("arguments.callee")]),a._v("，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。")]),a._v(" "),v("h3",{attrs:{id:"函数的其他知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数的其他知识点"}},[a._v("#")]),a._v(" 函数的其他知识点")]),a._v(" "),v("h4",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),v("p",[a._v("闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。")]),a._v(" "),v("p",[a._v("理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var n = 999;\n\nfunction f1() {\n  console.log(n);\n}\nf1() // 999\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f1")]),a._v("可以读取全局变量"),v("code",[a._v("n")]),a._v("。")]),a._v(" "),v("p",[a._v("但是，正常情况下，函数外部无法读取函数内部声明的变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f1() {\n  var n = 999;\n}\n\nconsole.log(n)\n// Uncaught ReferenceError: n is not defined(\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f1")]),a._v("内部声明的变量"),v("code",[a._v("n")]),a._v("，函数外是无法读取的。")]),a._v(" "),v("p",[a._v("如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f1() {\n  var n = 999;\n  function f2() {\n　　console.log(n); // 999\n  }\n}\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f2")]),a._v("就在函数"),v("code",[a._v("f1")]),a._v("内部，这时"),v("code",[a._v("f1")]),a._v("内部的所有局部变量，对"),v("code",[a._v("f2")]),a._v("都是可见的。但是反过来就不行，"),v("code",[a._v("f2")]),a._v("内部的局部变量，对"),v("code",[a._v("f1")]),a._v('就是不可见的。这就是 JavaScript 语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。')]),a._v(" "),v("p",[a._v("既然"),v("code",[a._v("f2")]),a._v("可以读取"),v("code",[a._v("f1")]),a._v("的局部变量，那么只要把"),v("code",[a._v("f2")]),a._v("作为返回值，我们不就可以在"),v("code",[a._v("f1")]),a._v("外部读取它的内部变量了吗！")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function f1() {\n  var n = 999;\n  function f2() {\n    console.log(n);\n  }\n  return f2;\n}\n\nvar result = f1();\nresult(); // 999\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f1")]),a._v("的返回值就是函数"),v("code",[a._v("f2")]),a._v("，由于"),v("code",[a._v("f2")]),a._v("可以读取"),v("code",[a._v("f1")]),a._v("的内部变量，所以就可以在外部获得"),v("code",[a._v("f1")]),a._v("的内部变量了。")]),a._v(" "),v("p",[a._v("闭包就是函数"),v("code",[a._v("f2")]),a._v("，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如"),v("code",[a._v("f2")]),a._v("记住了它诞生的环境"),v("code",[a._v("f1")]),a._v("，所以从"),v("code",[a._v("f2")]),a._v("可以得到"),v("code",[a._v("f1")]),a._v("的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。")]),a._v(" "),v("p",[a._v("闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function createIncrementor(start) {\n  return function () {\n    return start++;\n  };\n}\n\nvar inc = createIncrementor(5);\n\ninc() // 5\ninc() // 6\ninc() // 7\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("start")]),a._v("是函数"),v("code",[a._v("createIncrementor")]),a._v("的内部变量。通过闭包，"),v("code",[a._v("start")]),a._v("的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包"),v("code",[a._v("inc")]),a._v("使得函数"),v("code",[a._v("createIncrementor")]),a._v("的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。")]),a._v(" "),v("p",[a._v("为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的"),v("code",[a._v("inc")]),a._v("）用到了外层变量（"),v("code",[a._v("start")]),a._v("），导致外层函数（"),v("code",[a._v("createIncrementor")]),a._v("）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。")]),a._v(" "),v("p",[a._v("闭包的另一个用处，是封装对象的私有属性和私有方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function Person(name) {\n  var _age;\n  function setAge(n) {\n    _age = n;\n  }\n  function getAge() {\n    return _age;\n  }\n\n  return {\n    name: name,\n    getAge: getAge,\n    setAge: setAge\n  };\n}\n\nvar p1 = Person('张三');\np1.setAge(25);\np1.getAge() // 25\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("Person")]),a._v("的内部变量"),v("code",[a._v("_age")]),a._v("，通过闭包"),v("code",[a._v("getAge")]),a._v("和"),v("code",[a._v("setAge")]),a._v("，变成了返回对象"),v("code",[a._v("p1")]),a._v("的私有变量。")]),a._v(" "),v("p",[a._v("注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。")]),a._v(" "),v("h4",{attrs:{id:"立即调用的函数表达式-iife"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#立即调用的函数表达式-iife"}},[a._v("#")]),a._v(" 立即调用的函数表达式（IIFE）")]),a._v(" "),v("p",[a._v("根据 JavaScript 的语法，圆括号"),v("code",[a._v("()")]),a._v("跟在函数名之后，表示调用该函数。比如，"),v("code",[a._v("print()")]),a._v("就表示调用"),v("code",[a._v("print")]),a._v("函数。")]),a._v(" "),v("p",[a._v("有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function(){ /* code */ }();\n// SyntaxError: Unexpected token (\n")])])]),v("p",[a._v("产生这个错误的原因是，"),v("code",[a._v("function")]),a._v("这个关键字既可以当作语句，也可以当作表达式。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 语句\nfunction f() {}\n\n// 表达式\nvar f = function f() {}\n")])])]),v("p",[a._v("当作表达式时，函数可以定义后直接加圆括号调用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var f = function f(){ return 1}();\nf // 1\n")])])]),v("p",[a._v("上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是"),v("code",[a._v("function")]),a._v("作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。")]),a._v(" "),v("p",[a._v("为了避免解析的歧义，JavaScript 规定，如果"),v("code",[a._v("function")]),a._v("关键字出现在行首，一律解释成语句。因此，引擎看到行首是"),v("code",[a._v("function")]),a._v("关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。")]),a._v(" "),v("p",[a._v("函数定义后立即调用的解决方法，就是不要让"),v("code",[a._v("function")]),a._v("出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n")])])]),v("p",[a._v("上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。")]),a._v(" "),v("p",[a._v("注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 报错\n(function(){ /* code */ }())\n(function(){ /* code */ }())\n")])])]),v("p",[a._v("上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。")]),a._v(" "),v("p",[a._v("推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var i = function(){ return 10; }();\ntrue && function(){ /* code */ }();\n0, function(){ /* code */ }();\n")])])]),v("p",[a._v("甚至像下面这样写，也是可以的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("!function () { /* code */ }();\n~function () { /* code */ }();\n-function () { /* code */ }();\n+function () { /* code */ }();\n")])])]),v("p",[a._v("通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 写法一\nvar tmp = newData;\nprocessData(tmp);\nstoreData(tmp);\n\n// 写法二\n(function () {\n  var tmp = newData;\n  processData(tmp);\n  storeData(tmp);\n}());\n")])])]),v("p",[a._v("上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。")]),a._v(" "),v("h3",{attrs:{id:"eval-命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eval-命令"}},[a._v("#")]),a._v(" eval 命令")]),a._v(" "),v("h4",{attrs:{id:"基本用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[a._v("#")]),a._v(" 基本用法")]),a._v(" "),v("p",[v("code",[a._v("eval")]),a._v("命令接受一个字符串作为参数，并将这个字符串当作语句执行。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval('var a = 1;');\na // 1\n")])])]),v("p",[a._v("上面代码将字符串当作语句运行，生成了变量"),v("code",[a._v("a")]),a._v("。")]),a._v(" "),v("p",[a._v("如果参数字符串无法当作语句运行，那么就会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval('3x') // Uncaught SyntaxError: Invalid or unexpected token\n")])])]),v("p",[a._v("放在"),v("code",[a._v("eval")]),a._v("中的字符串，应该有独自存在的意义，不能用来与"),v("code",[a._v("eval")]),a._v("以外的命令配合使用。举例来说，下面的代码将会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval('return;'); // Uncaught SyntaxError: Illegal return statement\n")])])]),v("p",[a._v("上面代码会报错，因为"),v("code",[a._v("return")]),a._v("不能单独使用，必须在函数中使用。")]),a._v(" "),v("p",[a._v("如果"),v("code",[a._v("eval")]),a._v("的参数不是字符串，那么会原样返回。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval(123) // 123\n")])])]),v("p",[v("code",[a._v("eval")]),a._v("没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1;\neval('a = 2');\n\na // 2\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("eval")]),a._v("命令修改了外部变量"),v("code",[a._v("a")]),a._v("的值。由于这个原因，"),v("code",[a._v("eval")]),a._v("有安全风险。")]),a._v(" "),v("p",[a._v("为了防止这种风险，JavaScript 规定，如果使用严格模式，"),v("code",[a._v("eval")]),a._v("内部声明的变量，不会影响到外部作用域。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(function f() {\n  'use strict';\n  eval('var foo = 123');\n  console.log(foo);  // ReferenceError: foo is not defined\n})()\n")])])]),v("p",[a._v("上面代码中，函数"),v("code",[a._v("f")]),a._v("内部是严格模式，这时"),v("code",[a._v("eval")]),a._v("内部声明的"),v("code",[a._v("foo")]),a._v("变量，就不会影响到外部。")]),a._v(" "),v("p",[a._v("不过，即使在严格模式下，"),v("code",[a._v("eval")]),a._v("依然可以读写当前作用域的变量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("(function f() {\n  'use strict';\n  var foo = 1;\n  eval('foo = 2');\n  console.log(foo);  // 2\n})()\n")])])]),v("p",[a._v("上面代码中，严格模式下，"),v("code",[a._v("eval")]),a._v("内部还是改写了外部变量，可见安全风险依然存在。")]),a._v(" "),v("p",[a._v("总之，"),v("code",[a._v("eval")]),a._v("的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，"),v("code",[a._v("eval")]),a._v("最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的"),v("code",[a._v("JSON.parse")]),a._v("方法。")]),a._v(" "),v("h4",{attrs:{id:"eval-的别名调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eval-的别名调用"}},[a._v("#")]),a._v(" eval 的别名调用")]),a._v(" "),v("p",[a._v("前面说过"),v("code",[a._v("eval")]),a._v("不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是"),v("code",[a._v("eval")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var m = eval;\nm('var x = 1');\nx // 1\n")])])]),v("p",[a._v("上面代码中，变量"),v("code",[a._v("m")]),a._v("是"),v("code",[a._v("eval")]),a._v("的别名。静态代码分析阶段，引擎分辨不出"),v("code",[a._v("m('var x = 1')")]),a._v("执行的是"),v("code",[a._v("eval")]),a._v("命令。")]),a._v(" "),v("p",[a._v("为了保证"),v("code",[a._v("eval")]),a._v("的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行"),v("code",[a._v("eval")]),a._v("，"),v("code",[a._v("eval")]),a._v("内部一律是全局作用域。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = 1;\n\nfunction f() {\n  var a = 2;\n  var e = eval;\n  e('console.log(a)');\n}\n\nf() // 1\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("eval")]),a._v("是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的"),v("code",[a._v("a")]),a._v("为全局变量。这样的话，引擎就能确认"),v("code",[a._v("e()")]),a._v("不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。")]),a._v(" "),v("p",[v("code",[a._v("eval")]),a._v("的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨"),v("code",[a._v("eval()")]),a._v("这一种形式是直接调用。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("eval.call(null, '...')\nwindow.eval('...')\n(1, eval)('...')\n(eval, eval)('...')\n")])])]),v("p",[a._v("上面这些形式都是"),v("code",[a._v("eval")]),a._v("的别名调用，作用域都是全局作用域。")]),a._v(" "),v("h3",{attrs:{id:"参考链接-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-6"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Ben Alman, "),v("a",{attrs:{href:"http://benalman.com/news/2010/11/immediately-invoked-function-expression/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Immediately-Invoked Function Expression (IIFE)"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Mark Daggett, "),v("a",{attrs:{href:"http://markdaggett.com/blog/2013/02/15/functions-explained/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Functions Explained"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Juriy Zaytsev, "),v("a",{attrs:{href:"https://kangax.github.com/nfe/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Named function expressions demystified"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Marco Rogers polotek, "),v("a",{attrs:{href:"http://docs.nodejitsu.com/articles/javascript-conventions/what-is-the-arguments-object",target:"_blank",rel:"noopener noreferrer"}},[a._v("What is the arguments object?"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Juriy Zaytsev, "),v("a",{attrs:{href:"http://perfectionkills.com/global-eval-what-are-the-options/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Global eval. What are the options?"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2014/01/eval.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Evaluating JavaScript code via eval() and new Function()"),v("OutboundLink")],1)])]),a._v(" "),v("h2",{attrs:{id:"数值-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数值-2"}},[a._v("#")]),a._v(" 数值")]),a._v(" "),v("h3",{attrs:{id:"定义-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义-3"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),v("p",[a._v("数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = ['a', 'b', 'c'];\n")])])]),v("p",[a._v("上面代码中的"),v("code",[a._v("a")]),a._v("、"),v("code",[a._v("b")]),a._v("、"),v("code",[a._v("c")]),a._v("就构成一个数组，两端的方括号是数组的标志。"),v("code",[a._v("a")]),a._v("是0号位置，"),v("code",[a._v("b")]),a._v("是1号位置，"),v("code",[a._v("c")]),a._v("是2号位置。")]),a._v(" "),v("p",[a._v("除了在定义时赋值，数组也可以先定义后赋值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [];\n\narr[0] = 'a';\narr[1] = 'b';\narr[2] = 'c';\n")])])]),v("p",[a._v("任何类型的数据，都可以放入数组。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [\n  {a: 1},\n  [1, 2, 3],\n  function() {return true;}\n];\n\narr[0] // Object {a: 1}\narr[1] // [1, 2, 3]\narr[2] // function (){return true;}\n")])])]),v("p",[a._v("上面数组"),v("code",[a._v("arr")]),a._v("的3个成员依次是对象、数组、函数。")]),a._v(" "),v("p",[a._v("如果数组的元素还是数组，就形成了多维数组。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [[1, 2], [3, 4]];\na[0][1] // 2\na[1][1] // 4\n")])])]),v("h3",{attrs:{id:"数组的本质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组的本质"}},[a._v("#")]),a._v(" 数组的本质")]),a._v(" "),v("p",[a._v("本质上，数组属于一种特殊的对象。"),v("code",[a._v("typeof")]),a._v("运算符会返回数组的类型是"),v("code",[a._v("object")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('typeof [1, 2, 3] // "object"\n')])])]),v("p",[a._v("上面代码表明，"),v("code",[a._v("typeof")]),a._v("运算符认为数组的类型就是对象。")]),a._v(" "),v("p",[a._v("数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = ['a', 'b', 'c'];\n\nObject.keys(arr)\n// [\"0\", \"1\", \"2\"]\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("Object.keys")]),a._v("方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。")]),a._v(" "),v("p",[a._v("由于数组成员的键名是固定的（默认总是0、1、2...），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = ['a', 'b', 'c'];\n\narr['0'] // 'a'\narr[0] // 'a'\n")])])]),v("p",[a._v("上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。")]),a._v(" "),v("p",[a._v("注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [];\n\na[1.00] = 6;\na[1] // 6\n")])])]),v("p",[a._v("上面代码中，由于"),v("code",[a._v("1.00")]),a._v("转成字符串是"),v("code",[a._v("1")]),a._v("，所以通过数字键"),v("code",[a._v("1")]),a._v("可以读取值。")]),a._v(" "),v("p",[a._v("上一章说过，对象有两种读取成员的方法：点结构（"),v("code",[a._v("object.key")]),a._v("）和方括号结构（"),v("code",[a._v("object[key]")]),a._v("）。但是，对于数值的键名，不能使用点结构。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [1, 2, 3];\narr.0 // SyntaxError\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("arr.0")]),a._v("的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号"),v("code",[a._v("arr[0]")]),a._v("表示（方括号是运算符，可以接受数值）。")]),a._v(" "),v("h3",{attrs:{id:"length-属性-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#length-属性-3"}},[a._v("#")]),a._v(" length 属性")]),a._v(" "),v("p",[a._v("数组的"),v("code",[a._v("length")]),a._v("属性，返回数组的成员数量。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("['a', 'b', 'c'].length // 3\n")])])]),v("p",[a._v("JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说"),v("code",[a._v("length")]),a._v("属性的最大值就是 4294967295。")]),a._v(" "),v("p",[a._v("只要是数组，就一定有"),v("code",[a._v("length")]),a._v("属性。该属性是一个动态的值，等于键名中的最大整数加上"),v("code",[a._v("1")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = ['a', 'b'];\narr.length // 2\n\narr[2] = 'c';\narr.length // 3\n\narr[9] = 'd';\narr.length // 10\n\narr[1000] = 'e';\narr.length // 1001\n")])])]),v("p",[a._v("上面代码表示，数组的数字键不需要连续，"),v("code",[a._v("length")]),a._v("属性的值总是比最大的那个整数键大"),v("code",[a._v("1")]),a._v("。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。")]),a._v(" "),v("p",[v("code",[a._v("length")]),a._v("属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到"),v("code",[a._v("length")]),a._v("设置的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [ 'a', 'b', 'c' ];\narr.length // 3\n\narr.length = 2;\narr // [\"a\", \"b\"]\n")])])]),v("p",[a._v("上面代码表示，当数组的"),v("code",[a._v("length")]),a._v("属性设为2（即最大的整数键只能是1）那么整数键2（值为"),v("code",[a._v("c")]),a._v("）就已经不在数组中了，被自动删除了。")]),a._v(" "),v("p",[a._v("清空数组的一个有效方法，就是将"),v("code",[a._v("length")]),a._v("属性设为0。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [ 'a', 'b', 'c' ];\n\narr.length = 0;\narr // []\n")])])]),v("p",[a._v("如果人为设置"),v("code",[a._v("length")]),a._v("大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = ['a'];\n\na.length = 3;\na[1] // undefined\n")])])]),v("p",[a._v("上面代码表示，当"),v("code",[a._v("length")]),a._v("属性设为大于数组个数时，读取新增的位置都会返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("p",[a._v("如果人为设置"),v("code",[a._v("length")]),a._v("为不合法的值，JavaScript 会报错。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// 设置负值\n[].length = -1\n// RangeError: Invalid array length\n\n// 数组元素个数大于等于2的32次方\n[].length = Math.pow(2, 32)\n// RangeError: Invalid array length\n\n// 设置字符串\n[].length = 'abc'\n// RangeError: Invalid array length\n")])])]),v("p",[a._v("值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响"),v("code",[a._v("length")]),a._v("属性的值。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [];\n\na['p'] = 'abc';\na.length // 0\n\na[2.1] = 'abc';\na.length // 0\n")])])]),v("p",[a._v("上面代码将数组的键分别设为字符串和小数，结果都不影响"),v("code",[a._v("length")]),a._v("属性。因为，"),v("code",[a._v("length")]),a._v("属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以"),v("code",[a._v("length")]),a._v("属性保持为"),v("code",[a._v("0")]),a._v("。")]),a._v(" "),v("p",[a._v("如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [];\narr[-1] = 'a';\narr[Math.pow(2, 32)] = 'b';\n\narr.length // 0\narr[-1] // \"a\"\narr[4294967296] // \"b\"\n")])])]),v("p",[a._v("上面代码中，我们为数组"),v("code",[a._v("arr")]),a._v("添加了两个不合法的数字键，结果"),v("code",[a._v("length")]),a._v("属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。")]),a._v(" "),v("h3",{attrs:{id:"in-运算符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#in-运算符"}},[a._v("#")]),a._v(" in 运算符")]),a._v(" "),v("p",[a._v("检查某个键名是否存在的运算符"),v("code",[a._v("in")]),a._v("，适用于对象，也适用于数组。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [ 'a', 'b', 'c' ];\n2 in arr  // true\n'2' in arr // true\n4 in arr // false\n")])])]),v("p",[a._v("上面代码表明，数组存在键名为"),v("code",[a._v("2")]),a._v("的键。由于键名都是字符串，所以数值"),v("code",[a._v("2")]),a._v("会自动转成字符串。")]),a._v(" "),v("p",[a._v("注意，如果数组的某个位置是空位，"),v("code",[a._v("in")]),a._v("运算符返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = [];\narr[100] = 'a';\n\n100 in arr // true\n1 in arr // false\n")])])]),v("p",[a._v("上面代码中，数组"),v("code",[a._v("arr")]),a._v("只有一个成员"),v("code",[a._v("arr[100]")]),a._v("，其他位置的键名都会返回"),v("code",[a._v("false")]),a._v("。")]),a._v(" "),v("h3",{attrs:{id:"for-in-循环和数组的遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#for-in-循环和数组的遍历"}},[a._v("#")]),a._v(" for...in 循环和数组的遍历")]),a._v(" "),v("p",[v("code",[a._v("for...in")]),a._v("循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, 2, 3];\n\nfor (var i in a) {\n  console.log(a[i]);\n}\n// 1\n// 2\n// 3\n")])])]),v("p",[a._v("但是，"),v("code",[a._v("for...in")]),a._v("不仅会遍历数组所有的数字键，还会遍历非数字键。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, 2, 3];\na.foo = true;\n\nfor (var key in a) {\n  console.log(key);\n}\n// 0\n// 1\n// 2\n// foo\n")])])]),v("p",[a._v("上面代码在遍历数组时，也遍历到了非整数键"),v("code",[a._v("foo")]),a._v("。所以，不推荐使用"),v("code",[a._v("for...in")]),a._v("遍历数组。")]),a._v(" "),v("p",[a._v("数组的遍历可以考虑使用"),v("code",[a._v("for")]),a._v("循环或"),v("code",[a._v("while")]),a._v("循环。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, 2, 3];\n\n// for循环\nfor(var i = 0; i < a.length; i++) {\n  console.log(a[i]);\n}\n\n// while循环\nvar i = 0;\nwhile (i < a.length) {\n  console.log(a[i]);\n  i++;\n}\n\nvar l = a.length;\nwhile (l--) {\n  console.log(a[l]);\n}\n")])])]),v("p",[a._v("上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。")]),a._v(" "),v("p",[a._v("数组的"),v("code",[a._v("forEach")]),a._v("方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var colors = ['red', 'green', 'blue'];\ncolors.forEach(function (color) {\n  console.log(color);\n});\n// red\n// green\n// blue\n")])])]),v("h3",{attrs:{id:"数组的空位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组的空位"}},[a._v("#")]),a._v(" 数组的空位")]),a._v(" "),v("p",[a._v("当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, , 1];\na.length // 3\n")])])]),v("p",[a._v("上面代码表明，数组的空位不影响"),v("code",[a._v("length")]),a._v("属性。虽然这个位置没有值，引擎依然认为这个位置是有效的。")]),a._v(" "),v("p",[a._v("需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, 2, 3,];\n\na.length // 3\na // [1, 2, 3]\n")])])]),v("p",[a._v("上面代码中，数组最后一个成员后面有一个逗号，这不影响"),v("code",[a._v("length")]),a._v("属性的值，与没有这个逗号时效果一样。")]),a._v(" "),v("p",[a._v("数组的空位是可以读取的，返回"),v("code",[a._v("undefined")]),a._v("。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [, , ,];\na[1] // undefined\n")])])]),v("p",[a._v("使用"),v("code",[a._v("delete")]),a._v("命令删除一个数组成员，会形成空位，并且不会影响"),v("code",[a._v("length")]),a._v("属性。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [1, 2, 3];\ndelete a[1];\n\na[1] // undefined\na.length // 3\n")])])]),v("p",[a._v("上面代码用"),v("code",[a._v("delete")]),a._v("命令删除了数组的第二个元素，这个位置就形成了空位，但是对"),v("code",[a._v("length")]),a._v("属性没有影响。也就是说，"),v("code",[a._v("length")]),a._v("属性不过滤空位。所以，使用"),v("code",[a._v("length")]),a._v("属性进行数组遍历，一定要非常小心。")]),a._v(" "),v("p",[a._v("数组的某个位置是空位，与某个位置是"),v("code",[a._v("undefined")]),a._v("，是不一样的。如果是空位，使用数组的"),v("code",[a._v("forEach")]),a._v("方法、"),v("code",[a._v("for...in")]),a._v("结构、以及"),v("code",[a._v("Object.keys")]),a._v("方法进行遍历，空位都会被跳过。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [, , ,];\n\na.forEach(function (x, i) {\n  console.log(i + '. ' + x);\n})\n// 不产生任何输出\n\nfor (var i in a) {\n  console.log(i);\n}\n// 不产生任何输出\n\nObject.keys(a)\n// []\n")])])]),v("p",[a._v("如果某个位置是"),v("code",[a._v("undefined")]),a._v("，遍历的时候就不会被跳过。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var a = [undefined, undefined, undefined];\n\na.forEach(function (x, i) {\n  console.log(i + '. ' + x);\n});\n// 0. undefined\n// 1. undefined\n// 2. undefined\n\nfor (var i in a) {\n  console.log(i);\n}\n// 0\n// 1\n// 2\n\nObject.keys(a)\n// ['0', '1', '2']\n")])])]),v("p",[a._v("这就是说，空位就是数组没有这个元素，所以不会被遍历到，而"),v("code",[a._v("undefined")]),a._v("则表示数组有这个元素，值是"),v("code",[a._v("undefined")]),a._v("，所以遍历不会跳过。")]),a._v(" "),v("h3",{attrs:{id:"类似数组的对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类似数组的对象"}},[a._v("#")]),a._v(" 类似数组的对象")]),a._v(" "),v("p",[a._v("如果一个对象的所有键名都是正整数或零，并且有"),v("code",[a._v("length")]),a._v("属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3\n};\n\nobj[0] // 'a'\nobj[1] // 'b'\nobj.length // 3\nobj.push('d') // TypeError: obj.push is not a function\n")])])]),v("p",[a._v("上面代码中，对象"),v("code",[a._v("obj")]),a._v("就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象"),v("code",[a._v("obj")]),a._v("没有数组的"),v("code",[a._v("push")]),a._v("方法，使用该方法就会报错。")]),a._v(" "),v("p",[a._v("“类似数组的对象”的根本特征，就是具有"),v("code",[a._v("length")]),a._v("属性。只要有"),v("code",[a._v("length")]),a._v("属性，就可以认为这个对象类似于数组。但是有一个问题，这种"),v("code",[a._v("length")]),a._v("属性不是动态值，不会随着成员的变化而变化。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var obj = {\n  length: 0\n};\nobj[3] = 'd';\nobj.length // 0\n")])])]),v("p",[a._v("上面代码为对象"),v("code",[a._v("obj")]),a._v("添加了一个数字键，但是"),v("code",[a._v("length")]),a._v("属性没变。这就说明了"),v("code",[a._v("obj")]),a._v("不是数组。")]),a._v(" "),v("p",[a._v("典型的“类似数组的对象”是函数的"),v("code",[a._v("arguments")]),a._v("对象，以及大多数 DOM 元素集，还有字符串。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// arguments对象\nfunction args() { return arguments }\nvar arrayLike = args('a', 'b');\n\narrayLike[0] // 'a'\narrayLike.length // 2\narrayLike instanceof Array // false\n\n// DOM元素集\nvar elts = document.getElementsByTagName('h3');\nelts.length // 3\nelts instanceof Array // false\n\n// 字符串\n'abc'[1] // 'b'\n'abc'.length // 3\n'abc' instanceof Array // false\n")])])]),v("p",[a._v("上面代码包含三个例子，它们都不是数组（"),v("code",[a._v("instanceof")]),a._v("运算符返回"),v("code",[a._v("false")]),a._v("），但是看上去都非常像数组。")]),a._v(" "),v("p",[a._v("数组的"),v("code",[a._v("slice")]),a._v("方法可以将“类似数组的对象”变成真正的数组。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = Array.prototype.slice.call(arrayLike);\n")])])]),v("p",[a._v("除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过"),v("code",[a._v("call()")]),a._v("把数组的方法放到对象上面。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("function print(value, index) {\n  console.log(index + ' : ' + value);\n}\n\nArray.prototype.forEach.call(arrayLike, print);\n")])])]),v("p",[a._v("上面代码中，"),v("code",[a._v("arrayLike")]),a._v("代表一个类似数组的对象，本来是不可以使用数组的"),v("code",[a._v("forEach()")]),a._v("方法的，但是通过"),v("code",[a._v("call()")]),a._v("，可以把"),v("code",[a._v("forEach()")]),a._v("嫁接到"),v("code",[a._v("arrayLike")]),a._v("上面调用。")]),a._v(" "),v("p",[a._v("下面的例子就是通过这种方法，在"),v("code",[a._v("arguments")]),a._v("对象上面调用"),v("code",[a._v("forEach")]),a._v("方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("// forEach 方法\nfunction logArgs() {\n  Array.prototype.forEach.call(arguments, function (elem, i) {\n    console.log(i + '. ' + elem);\n  });\n}\n\n// 等同于 for 循环\nfunction logArgs() {\n  for (var i = 0; i < arguments.length; i++) {\n    console.log(i + '. ' + arguments[i]);\n  }\n}\n")])])]),v("p",[a._v("字符串也是类似数组的对象，所以也可以用"),v("code",[a._v("Array.prototype.forEach.call")]),a._v("遍历。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("Array.prototype.forEach.call('abc', function (chr) {\n  console.log(chr);\n});\n// a\n// b\n// c\n")])])]),v("p",[a._v("注意，这种方法比直接使用数组原生的"),v("code",[a._v("forEach")]),a._v("要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的"),v("code",[a._v("forEach")]),a._v("方法。")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("var arr = Array.prototype.slice.call('abc');\narr.forEach(function (chr) {\n  console.log(chr);\n});\n// a\n// b\n// c\n")])])]),v("h3",{attrs:{id:"参考链接-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-7"}},[a._v("#")]),a._v(" 参考链接")]),a._v(" "),v("ul",[v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2012/12/arrays.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Arrays in JavaScript"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Axel Rauschmayer, "),v("a",{attrs:{href:"http://www.2ality.com/2012/06/dense-arrays.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript: sparse arrays vs. dense arrays"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Felix Bohm, "),v("a",{attrs:{href:"http://net.tutsplus.com/tutorials/javascript-ajax/what-they-didnt-tell-you-about-es5s-array-extras/",target:"_blank",rel:"noopener noreferrer"}},[a._v("What They Didn’t Tell You About ES5′s Array Extras"),v("OutboundLink")],1)]),a._v(" "),v("li",[a._v("Juriy Zaytsev, "),v("a",{attrs:{href:"http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/",target:"_blank",rel:"noopener noreferrer"}},[a._v("How ECMAScript 5 still does not allow to subclass an array"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);