(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{650:function(e,a,t){"use strict";t.r(a);var n=t(25),v=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"语法专题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法专题"}},[e._v("#")]),e._v(" 语法专题")]),e._v(" "),t("h2",{attrs:{id:"数据类型的转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型的转换"}},[e._v("#")]),e._v(" 数据类型的转换")]),e._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("p",[e._v("JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var x = y ? 1 : 'a';\n")])])]),t("p",[e._v("上面代码中，变量"),t("code",[e._v("x")]),e._v("到底是数值还是字符串，取决于另一个变量"),t("code",[e._v("y")]),e._v("的值。"),t("code",[e._v("y")]),e._v("为"),t("code",[e._v("true")]),e._v("时，"),t("code",[e._v("x")]),e._v("是一个数值；"),t("code",[e._v("y")]),e._v("为"),t("code",[e._v("false")]),e._v("时，"),t("code",[e._v("x")]),e._v("是一个字符串。这意味着，"),t("code",[e._v("x")]),e._v("的类型没法在编译阶段就知道，必须等到运行时才能知道。")]),e._v(" "),t("p",[e._v("虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'4' - '3' // 1\n")])])]),t("p",[e._v("上面代码中，虽然是两个字符串相减，但是依然会得到结果数值"),t("code",[e._v("1")]),e._v("，原因就在于 JavaScript 将运算子自动转为了数值。")]),e._v(" "),t("p",[e._v("本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。")]),e._v(" "),t("h3",{attrs:{id:"强制转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强制转换"}},[e._v("#")]),e._v(" 强制转换")]),e._v(" "),t("p",[e._v("强制转换主要指使用"),t("code",[e._v("Number()")]),e._v("、"),t("code",[e._v("String()")]),e._v("和"),t("code",[e._v("Boolean()")]),e._v("三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。")]),e._v(" "),t("h4",{attrs:{id:"number"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#number"}},[e._v("#")]),e._v(" Number()")]),e._v(" "),t("p",[e._v("使用"),t("code",[e._v("Number")]),e._v("函数，可以将任意类型的值转化成数值。")]),e._v(" "),t("p",[e._v("下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。")]),e._v(" "),t("p",[t("strong",[e._v("（1）原始类型值")])]),e._v(" "),t("p",[e._v("原始类型值的转换规则如下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 数值：转换后还是原来的值\nNumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nNumber('324') // 324\n\n// 字符串：如果不可以被解析为数值，返回 NaN\nNumber('324abc') // NaN\n\n// 空字符串转为0\nNumber('') // 0\n\n// 布尔值：true 转成 1，false 转成 0\nNumber(true) // 1\nNumber(false) // 0\n\n// undefined：转成 NaN\nNumber(undefined) // NaN\n\n// null：转成0\nNumber(null) // 0\n")])])]),t("p",[t("code",[e._v("Number")]),e._v("函数将字符串转为数值，要比"),t("code",[e._v("parseInt")]),e._v("函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为"),t("code",[e._v("NaN")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("parseInt('42 cats') // 42\nNumber('42 cats') // NaN\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("parseInt")]),e._v("逐个解析字符，而"),t("code",[e._v("Number")]),e._v("函数整体转换字符串的类型。")]),e._v(" "),t("p",[e._v("另外，"),t("code",[e._v("parseInt")]),e._v("和"),t("code",[e._v("Number")]),e._v("函数都会自动过滤一个字符串前导和后缀的空格。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("parseInt('\\t\\v\\r12.34\\n') // 12\nNumber('\\t\\v\\r12.34\\n') // 12.34\n")])])]),t("p",[t("strong",[e._v("（2）对象")])]),e._v(" "),t("p",[e._v("简单的规则是，"),t("code",[e._v("Number")]),e._v("方法的参数是对象时，将返回"),t("code",[e._v("NaN")]),e._v("，除非是包含单个数值的数组。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Number({a: 1}) // NaN\nNumber([1, 2, 3]) // NaN\nNumber([5]) // 5\n")])])]),t("p",[e._v("之所以会这样，是因为"),t("code",[e._v("Number")]),e._v("背后的转换规则比较复杂。")]),e._v(" "),t("p",[e._v("第一步，调用对象自身的"),t("code",[e._v("valueOf")]),e._v("方法。如果返回原始类型的值，则直接对该值使用"),t("code",[e._v("Number")]),e._v("函数，不再进行后续步骤。")]),e._v(" "),t("p",[e._v("第二步，如果"),t("code",[e._v("valueOf")]),e._v("方法返回的还是对象，则改为调用对象自身的"),t("code",[e._v("toString")]),e._v("方法。如果"),t("code",[e._v("toString")]),e._v("方法返回原始类型的值，则对该值使用"),t("code",[e._v("Number")]),e._v("函数，不再进行后续步骤。")]),e._v(" "),t("p",[e._v("第三步，如果"),t("code",[e._v("toString")]),e._v("方法返回的是对象，就报错。")]),e._v(" "),t("p",[e._v("请看下面的例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {x: 1};\nNumber(obj) // NaN\n\n// 等同于\nif (typeof obj.valueOf() === 'object') {\n  Number(obj.toString());\n} else {\n  Number(obj.valueOf());\n}\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("Number")]),e._v("函数将"),t("code",[e._v("obj")]),e._v("对象转为数值。背后发生了一连串的操作，首先调用"),t("code",[e._v("obj.valueOf")]),e._v("方法, 结果返回对象本身；于是，继续调用"),t("code",[e._v("obj.toString")]),e._v("方法，这时返回字符串"),t("code",[e._v("[object Object]")]),e._v("，对这个字符串使用"),t("code",[e._v("Number")]),e._v("函数，得到"),t("code",[e._v("NaN")]),e._v("。")]),e._v(" "),t("p",[e._v("默认情况下，对象的"),t("code",[e._v("valueOf")]),e._v("方法返回对象本身，所以一般总是会调用"),t("code",[e._v("toString")]),e._v("方法，而"),t("code",[e._v("toString")]),e._v("方法返回对象的类型字符串（比如"),t("code",[e._v("[object Object]")]),e._v("）。所以，会有下面的结果。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Number({}) // NaN\n")])])]),t("p",[e._v("如果"),t("code",[e._v("toString")]),e._v("方法返回的不是原始类型的值，结果就会报错。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {\n  valueOf: function () {\n    return {};\n  },\n  toString: function () {\n    return {};\n  }\n};\n\nNumber(obj)\n// TypeError: Cannot convert object to primitive value\n")])])]),t("p",[e._v("上面代码的"),t("code",[e._v("valueOf")]),e._v("和"),t("code",[e._v("toString")]),e._v("方法，返回的都是对象，所以转成数值时会报错。")]),e._v(" "),t("p",[e._v("从上例还可以看到，"),t("code",[e._v("valueOf")]),e._v("和"),t("code",[e._v("toString")]),e._v("方法，都是可以自定义的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Number({\n  valueOf: function () {\n    return 2;\n  }\n})\n// 2\n\nNumber({\n  toString: function () {\n    return 3;\n  }\n})\n// 3\n\nNumber({\n  valueOf: function () {\n    return 2;\n  },\n  toString: function () {\n    return 3;\n  }\n})\n// 2\n")])])]),t("p",[e._v("上面代码对三个对象使用"),t("code",[e._v("Number")]),e._v("函数。第一个对象返回"),t("code",[e._v("valueOf")]),e._v("方法的值，第二个对象返回"),t("code",[e._v("toString")]),e._v("方法的值，第三个对象表示"),t("code",[e._v("valueOf")]),e._v("方法先于"),t("code",[e._v("toString")]),e._v("方法执行。")]),e._v(" "),t("h4",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[e._v("#")]),e._v(" String()")]),e._v(" "),t("p",[t("code",[e._v("String")]),e._v("函数可以将任意类型的值转化成字符串，转换规则如下。")]),e._v(" "),t("p",[t("strong",[e._v("（1）原始类型值")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("数值")]),e._v("：转为相应的字符串。")]),e._v(" "),t("li",[t("strong",[e._v("字符串")]),e._v("：转换后还是原来的值。")]),e._v(" "),t("li",[t("strong",[e._v("布尔值")]),e._v("："),t("code",[e._v("true")]),e._v("转为字符串"),t("code",[e._v('"true"')]),e._v("，"),t("code",[e._v("false")]),e._v("转为字符串"),t("code",[e._v('"false"')]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("undefined")]),e._v("：转为字符串"),t("code",[e._v('"undefined"')]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("null")]),e._v("：转为字符串"),t("code",[e._v('"null"')]),e._v("。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('String(123) // "123"\nString(\'abc\') // "abc"\nString(true) // "true"\nString(undefined) // "undefined"\nString(null) // "null"\n')])])]),t("p",[t("strong",[e._v("（2）对象")])]),e._v(" "),t("p",[t("code",[e._v("String")]),e._v("方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('String({a: 1}) // "[object Object]"\nString([1, 2, 3]) // "1,2,3"\n')])])]),t("p",[t("code",[e._v("String")]),e._v("方法背后的转换规则，与"),t("code",[e._v("Number")]),e._v("方法基本相同，只是互换了"),t("code",[e._v("valueOf")]),e._v("方法和"),t("code",[e._v("toString")]),e._v("方法的执行顺序。")]),e._v(" "),t("ol",[t("li",[e._v("先调用对象自身的"),t("code",[e._v("toString")]),e._v("方法。如果返回原始类型的值，则对该值使用"),t("code",[e._v("String")]),e._v("函数，不再进行以下步骤。")]),e._v(" "),t("li",[e._v("如果"),t("code",[e._v("toString")]),e._v("方法返回的是对象，再调用原对象的"),t("code",[e._v("valueOf")]),e._v("方法。如果"),t("code",[e._v("valueOf")]),e._v("方法返回原始类型的值，则对该值使用"),t("code",[e._v("String")]),e._v("函数，不再进行以下步骤。")]),e._v(" "),t("li",[e._v("如果"),t("code",[e._v("valueOf")]),e._v("方法返回的是对象，就报错。")])]),e._v(" "),t("p",[e._v("下面是一个例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('String({a: 1})\n// "[object Object]"\n\n// 等同于\nString({a: 1}.toString())\n// "[object Object]"\n')])])]),t("p",[e._v("上面代码先调用对象的"),t("code",[e._v("toString")]),e._v("方法，发现返回的是字符串"),t("code",[e._v("[object Object]")]),e._v("，就不再调用"),t("code",[e._v("valueOf")]),e._v("方法了。")]),e._v(" "),t("p",[e._v("如果"),t("code",[e._v("toString")]),e._v("法和"),t("code",[e._v("valueOf")]),e._v("方法，返回的都是对象，就会报错。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {\n  valueOf: function () {\n    return {};\n  },\n  toString: function () {\n    return {};\n  }\n};\n\nString(obj)\n// TypeError: Cannot convert object to primitive value\n")])])]),t("p",[e._v("下面是通过自定义"),t("code",[e._v("toString")]),e._v("方法，改变返回值的例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('String({\n  toString: function () {\n    return 3;\n  }\n})\n// "3"\n\nString({\n  valueOf: function () {\n    return 2;\n  }\n})\n// "[object Object]"\n\nString({\n  valueOf: function () {\n    return 2;\n  },\n  toString: function () {\n    return 3;\n  }\n})\n// "3"\n')])])]),t("p",[e._v("上面代码对三个对象使用"),t("code",[e._v("String")]),e._v("函数。第一个对象返回"),t("code",[e._v("toString")]),e._v("方法的值（数值3），第二个对象返回的还是"),t("code",[e._v("toString")]),e._v("方法的值（"),t("code",[e._v("[object Object]")]),e._v("），第三个对象表示"),t("code",[e._v("toString")]),e._v("方法先于"),t("code",[e._v("valueOf")]),e._v("方法执行。")]),e._v(" "),t("h4",{attrs:{id:"boolean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#boolean"}},[e._v("#")]),e._v(" Boolean()")]),e._v(" "),t("p",[t("code",[e._v("Boolean()")]),e._v("函数可以将任意类型的值转为布尔值。")]),e._v(" "),t("p",[e._v("它的转换规则相对简单：除了以下五个值的转换结果为"),t("code",[e._v("false")]),e._v("，其他的值全部为"),t("code",[e._v("true")]),e._v("。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("undefined")])]),e._v(" "),t("li",[t("code",[e._v("null")])]),e._v(" "),t("li",[t("code",[e._v("0")]),e._v("（包含"),t("code",[e._v("-0")]),e._v("和"),t("code",[e._v("+0")]),e._v("）")]),e._v(" "),t("li",[t("code",[e._v("NaN")])]),e._v(" "),t("li",[t("code",[e._v("''")]),e._v("（空字符串）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Boolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean(NaN) // false\nBoolean('') // false\n")])])]),t("p",[e._v("当然，"),t("code",[e._v("true")]),e._v("和"),t("code",[e._v("false")]),e._v("这两个布尔值不会发生变化。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Boolean(true) // true\nBoolean(false) // false\n")])])]),t("p",[e._v("注意，所有对象（包括空对象）的转换结果都是"),t("code",[e._v("true")]),e._v("，甚至连"),t("code",[e._v("false")]),e._v("对应的布尔对象"),t("code",[e._v("new Boolean(false)")]),e._v("也是"),t("code",[e._v("true")]),e._v("（详见《原始类型值的包装对象》一章）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Boolean({}) // true\nBoolean([]) // true\nBoolean(new Boolean(false)) // true\n")])])]),t("p",[e._v("所有对象的布尔值都是"),t("code",[e._v("true")]),e._v("，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于"),t("code",[e._v("obj1 && obj2")]),e._v("这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为"),t("code",[e._v("true")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"自动转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动转换"}},[e._v("#")]),e._v(" 自动转换")]),e._v(" "),t("p",[e._v("下面介绍自动转换，它是以强制转换为基础的。")]),e._v(" "),t("p",[e._v("遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。")]),e._v(" "),t("p",[e._v("第一种情况，不同类型的数据互相运算。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("123 + 'abc' // \"123abc\"\n")])])]),t("p",[e._v("第二种情况，对非布尔值类型的数据求布尔值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if ('abc') {\n  console.log('hello')\n}  // \"hello\"\n")])])]),t("p",[e._v("第三种情况，对非数值类型的值使用一元运算符（即"),t("code",[e._v("+")]),e._v("和"),t("code",[e._v("-")]),e._v("）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n")])])]),t("p",[e._v("自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用"),t("code",[e._v("String()")]),e._v("函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。")]),e._v(" "),t("p",[e._v("由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用"),t("code",[e._v("Boolean()")]),e._v("、"),t("code",[e._v("Number()")]),e._v("和"),t("code",[e._v("String()")]),e._v("函数进行显式转换。")]),e._v(" "),t("h4",{attrs:{id:"自动转换为布尔值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动转换为布尔值"}},[e._v("#")]),e._v(" 自动转换为布尔值")]),e._v(" "),t("p",[e._v("JavaScript 遇到预期为布尔值的地方（比如"),t("code",[e._v("if")]),e._v("语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用"),t("code",[e._v("Boolean()")]),e._v("函数。")]),e._v(" "),t("p",[e._v("因此除了以下五个值，其他都是自动转为"),t("code",[e._v("true")]),e._v("。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("undefined")])]),e._v(" "),t("li",[t("code",[e._v("null")])]),e._v(" "),t("li",[t("code",[e._v("+0")]),e._v("或"),t("code",[e._v("-0")])]),e._v(" "),t("li",[t("code",[e._v("NaN")])]),e._v(" "),t("li",[t("code",[e._v("''")]),e._v("（空字符串）")])]),e._v(" "),t("p",[e._v("下面这个例子中，条件部分的每个值都相当于"),t("code",[e._v("false")]),e._v("，使用否定运算符后，就变成了"),t("code",[e._v("true")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if ( !undefined\n  && !null\n  && !0\n  && !NaN\n  && !''\n) {\n  console.log('true');\n} // true\n")])])]),t("p",[e._v("下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是"),t("code",[e._v("Boolean()")]),e._v("函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 写法一\nexpression ? true : false\n\n// 写法二\n!! expression\n")])])]),t("h4",{attrs:{id:"自动转换为字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动转换为字符串"}},[e._v("#")]),e._v(" 自动转换为字符串")]),e._v(" "),t("p",[e._v("JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。")]),e._v(" "),t("p",[e._v("字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'5' + 1 // '51'\n'5' + true // \"5true\"\n'5' + false // \"5false\"\n'5' + {} // \"5[object Object]\"\n'5' + [] // \"5\"\n'5' + function (){} // \"5function (){}\"\n'5' + undefined // \"5undefined\"\n'5' + null // \"5null\"\n")])])]),t("p",[e._v("这种自动转换很容易出错。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {\n  width: '100'\n};\n\nobj.width + 20 // \"10020\"\n")])])]),t("p",[e._v("上面代码中，开发者可能期望返回"),t("code",[e._v("120")]),e._v("，但是由于自动转换，实际上返回了一个字符"),t("code",[e._v("10020")]),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"自动转换为数值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动转换为数值"}},[e._v("#")]),e._v(" 自动转换为数值")]),e._v(" "),t("p",[e._v("JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用"),t("code",[e._v("Number()")]),e._v("函数。")]),e._v(" "),t("p",[e._v("除了加法运算符（"),t("code",[e._v("+")]),e._v("）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'5' - '2' // 3\n'5' * '2' // 10\ntrue - 1  // 0\nfalse - 1 // -1\n'1' - 1   // 0\n'5' * []    // 0\nfalse / '5' // 0\n'abc' - 1   // NaN\nnull + 1 // 1\nundefined + 1 // NaN\n")])])]),t("p",[e._v("上面代码中，运算符两侧的运算子，都被转成了数值。")]),e._v(" "),t("blockquote",[t("p",[e._v("注意："),t("code",[e._v("null")]),e._v("转为数值时为"),t("code",[e._v("0")]),e._v("，而"),t("code",[e._v("undefined")]),e._v("转为数值时为"),t("code",[e._v("NaN")]),e._v("。")])]),e._v(" "),t("p",[e._v("一元运算符也会把运算子转成数值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("+'abc' // NaN\n-'abc' // NaN\n+true // 1\n-false // 0\n")])])]),t("h3",{attrs:{id:"参考链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),t("ul",[t("li",[e._v("Axel Rauschmayer, "),t("a",{attrs:{href:"http://www.2ality.com/2012/01/object-plus-object.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("What is {} + {} in JavaScript?"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Axel Rauschmayer, "),t("a",{attrs:{href:"http://www.2ality.com/2013/04/quirk-implicit-conversion.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript quirk 1: implicit conversion of values"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Benjie Gillam, "),t("a",{attrs:{href:"http://www.benjiegillam.com/2013/06/quantum-javascript/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Quantum JavaScript?"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"错误处理机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#错误处理机制"}},[e._v("#")]),e._v(" 错误处理机制")]),e._v(" "),t("h3",{attrs:{id:"error-实例对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#error-实例对象"}},[e._v("#")]),e._v(" Error 实例对象")]),e._v(" "),t("p",[e._v("JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供"),t("code",[e._v("Error")]),e._v("构造函数，所有抛出的错误都是这个构造函数的实例。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var err = new Error('出错了');\nerr.message // \"出错了\"\n")])])]),t("p",[e._v("上面代码中，我们调用"),t("code",[e._v("Error()")]),e._v("构造函数，生成一个实例对象"),t("code",[e._v("err")]),e._v("。"),t("code",[e._v("Error()")]),e._v("构造函数接受一个参数，表示错误提示，可以从实例的"),t("code",[e._v("message")]),e._v("属性读到这个参数。抛出"),t("code",[e._v("Error")]),e._v("实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。")]),e._v(" "),t("p",[e._v("JavaScript 语言标准只提到，"),t("code",[e._v("Error")]),e._v("实例对象必须有"),t("code",[e._v("message")]),e._v("属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对"),t("code",[e._v("Error")]),e._v("实例还提供"),t("code",[e._v("name")]),e._v("和"),t("code",[e._v("stack")]),e._v("属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("message")]),e._v("：错误提示信息")]),e._v(" "),t("li",[t("strong",[e._v("name")]),e._v("：错误名称（非标准属性）")]),e._v(" "),t("li",[t("strong",[e._v("stack")]),e._v("：错误的堆栈（非标准属性）")])]),e._v(" "),t("p",[e._v("使用"),t("code",[e._v("name")]),e._v("和"),t("code",[e._v("message")]),e._v("这两个属性，可以对发生什么错误有一个大概的了解。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (error.name) {\n  console.log(error.name + ': ' + error.message);\n}\n")])])]),t("p",[t("code",[e._v("stack")]),e._v("属性用来查看错误发生时的堆栈。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function throwit() {\n  throw new Error('');\n}\n\nfunction catchit() {\n  try {\n    throwit();\n  } catch(e) {\n    console.log(e.stack); // print stack trace\n  }\n}\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n")])])]),t("p",[e._v("上面代码中，错误堆栈的最内层是"),t("code",[e._v("throwit")]),e._v("函数，然后是"),t("code",[e._v("catchit")]),e._v("函数，最后是函数的运行环境。")]),e._v(" "),t("h3",{attrs:{id:"原生错误类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原生错误类型"}},[e._v("#")]),e._v(" 原生错误类型")]),e._v(" "),t("p",[t("code",[e._v("Error")]),e._v("实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在"),t("code",[e._v("Error")]),e._v("的6个派生对象。")]),e._v(" "),t("h4",{attrs:{id:"syntaxerror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syntaxerror-对象"}},[e._v("#")]),e._v(" SyntaxError 对象")]),e._v(" "),t("p",[t("code",[e._v("SyntaxError")]),e._v("对象是解析代码时发生的语法错误。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log 'hello');\n// Uncaught SyntaxError: Unexpected string\n")])])]),t("p",[e._v("上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出"),t("code",[e._v("SyntaxError")]),e._v("。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。")]),e._v(" "),t("h4",{attrs:{id:"referenceerror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#referenceerror-对象"}},[e._v("#")]),e._v(" ReferenceError 对象")]),e._v(" "),t("p",[t("code",[e._v("ReferenceError")]),e._v("对象是引用一个不存在的变量时发生的错误。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n")])])]),t("p",[e._v("另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n")])])]),t("p",[e._v("上面代码对函数"),t("code",[e._v("console.log")]),e._v("的运行结果赋值，结果引发了"),t("code",[e._v("ReferenceError")]),e._v("错误。")]),e._v(" "),t("h4",{attrs:{id:"rangeerror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rangeerror-对象"}},[e._v("#")]),e._v(" RangeError 对象")]),e._v(" "),t("p",[t("code",[e._v("RangeError")]),e._v("对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是"),t("code",[e._v("Number")]),e._v("对象的方法参数超出范围，以及函数堆栈超过最大值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n")])])]),t("h4",{attrs:{id:"typeerror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typeerror-对象"}},[e._v("#")]),e._v(" TypeError 对象")]),e._v(" "),t("p",[t("code",[e._v("TypeError")]),e._v("对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用"),t("code",[e._v("new")]),e._v("命令，就会抛出这种错误，因为"),t("code",[e._v("new")]),e._v("命令的参数应该是一个构造函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new 123\n// Uncaught TypeError: 123 is not a constructor\n\nvar obj = {};\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n")])])]),t("p",[e._v("上面代码的第二种情况，调用对象不存在的方法，也会抛出"),t("code",[e._v("TypeError")]),e._v("错误，因为"),t("code",[e._v("obj.unknownMethod")]),e._v("的值是"),t("code",[e._v("undefined")]),e._v("，而不是一个函数。")]),e._v(" "),t("h4",{attrs:{id:"urierror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#urierror-对象"}},[e._v("#")]),e._v(" URIError 对象")]),e._v(" "),t("p",[t("code",[e._v("URIError")]),e._v("对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及"),t("code",[e._v("encodeURI()")]),e._v("、"),t("code",[e._v("decodeURI()")]),e._v("、"),t("code",[e._v("encodeURIComponent()")]),e._v("、"),t("code",[e._v("decodeURIComponent()")]),e._v("、"),t("code",[e._v("escape()")]),e._v("和"),t("code",[e._v("unescape()")]),e._v("这六个函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("decodeURI('%2')\n// URIError: URI malformed\n")])])]),t("h4",{attrs:{id:"evalerror-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evalerror-对象"}},[e._v("#")]),e._v(" EvalError 对象")]),e._v(" "),t("p",[t("code",[e._v("eval")]),e._v("函数没有被正确执行时，会抛出"),t("code",[e._v("EvalError")]),e._v("错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。")]),e._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("以上这6种派生错误，连同原始的"),t("code",[e._v("Error")]),e._v("对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var err1 = new Error('出错了！');\nvar err2 = new RangeError('出错了，变量超出有效范围！');\nvar err3 = new TypeError('出错了，变量类型无效！');\n\nerr1.message // \"出错了！\"\nerr2.message // \"出错了，变量超出有效范围！\"\nerr3.message // \"出错了，变量类型无效！\"\n")])])]),t("h3",{attrs:{id:"自定义错误"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义错误"}},[e._v("#")]),e._v(" 自定义错误")]),e._v(" "),t("p",[e._v("除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n")])])]),t("p",[e._v("上面代码自定义一个错误对象"),t("code",[e._v("UserError")]),e._v("，让它继承"),t("code",[e._v("Error")]),e._v("对象。然后，就可以生成这种自定义类型的错误了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new UserError('这是自定义的错误！');\n")])])]),t("h3",{attrs:{id:"throw-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#throw-语句"}},[e._v("#")]),e._v(" throw 语句")]),e._v(" "),t("p",[t("code",[e._v("throw")]),e._v("语句的作用是手动中断程序执行，抛出一个错误。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var x = -1;\n\nif (x <= 0) {\n  throw new Error('x 必须为正数');\n}\n// Uncaught Error: x 必须为正数\n")])])]),t("p",[e._v("上面代码中，如果变量"),t("code",[e._v("x")]),e._v("小于等于"),t("code",[e._v("0")]),e._v("，就手动抛出一个错误，告诉用户"),t("code",[e._v("x")]),e._v("的值不正确，整个程序就会在这里中断执行。可以看到，"),t("code",[e._v("throw")]),e._v("抛出的错误就是它的参数，这里是一个"),t("code",[e._v("Error")]),e._v("对象的实例。")]),e._v(" "),t("p",[t("code",[e._v("throw")]),e._v("也可以抛出自定义错误。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function UserError(message) {\n  this.message = message || '默认信息';\n  this.name = 'UserError';\n}\n\nthrow new UserError('出错了！');\n// Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("throw")]),e._v("抛出的是一个"),t("code",[e._v("UserError")]),e._v("实例。")]),e._v(" "),t("p",[e._v("实际上，"),t("code",[e._v("throw")]),e._v("可以抛出任何类型的值。也就是说，它的参数可以是任何值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 抛出一个字符串\nthrow 'Error！';\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow {\n  toString: function () {\n    return 'Error!';\n  }\n};\n// Uncaught {toString: ƒ}\n")])])]),t("p",[e._v("对于 JavaScript 引擎来说，遇到"),t("code",[e._v("throw")]),e._v("语句，程序就中止了。引擎会接收到"),t("code",[e._v("throw")]),e._v("抛出的信息，可能是一个错误实例，也可能是其他类型的值。")]),e._v(" "),t("h3",{attrs:{id:"try-catch-结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#try-catch-结构"}},[e._v("#")]),e._v(" try...catch 结构")]),e._v(" "),t("p",[e._v("一旦发生错误，程序就中止执行了。JavaScript 提供了"),t("code",[e._v("try...catch")]),e._v("结构，允许对错误进行处理，选择是否往下执行。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n  throw new Error('出错了!');\n} catch (e) {\n  console.log(e.name + \": \" + e.message);\n  console.log(e.stack);\n}\n// Error: 出错了!\n//   at <anonymous>:3:9\n//   ...\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("try")]),e._v("代码块抛出错误（上例用的是"),t("code",[e._v("throw")]),e._v("语句），JavaScript 引擎就立即把代码的执行，转到"),t("code",[e._v("catch")]),e._v("代码块，或者说错误被"),t("code",[e._v("catch")]),e._v("代码块捕获了。"),t("code",[e._v("catch")]),e._v("接受一个参数，表示"),t("code",[e._v("try")]),e._v("代码块抛出的值。")]),e._v(" "),t("p",[e._v("如果你不确定某些代码是否会报错，就可以把它们放在"),t("code",[e._v("try...catch")]),e._v("代码块之中，便于进一步对错误进行处理。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n  f();\n} catch(e) {\n  // 处理错误\n}\n")])])]),t("p",[e._v("上面代码中，如果函数"),t("code",[e._v("f")]),e._v("执行报错，就会进行"),t("code",[e._v("catch")]),e._v("代码块，接着对错误进行处理。")]),e._v(" "),t("p",[t("code",[e._v("catch")]),e._v("代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('try {\n  throw "出错了";\n} catch (e) {\n  console.log(111);\n}\nconsole.log(222);\n// 111\n// 222\n')])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("try")]),e._v("代码块抛出的错误，被"),t("code",[e._v("catch")]),e._v("代码块捕获后，程序会继续向下执行。")]),e._v(" "),t("p",[t("code",[e._v("catch")]),e._v("代码块之中，还可以再抛出错误，甚至使用嵌套的"),t("code",[e._v("try...catch")]),e._v("结构。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var n = 100;\n\ntry {\n  throw n;\n} catch (e) {\n  if (e <= 50) {\n    // ...\n  } else {\n    throw e;\n  }\n}\n// Uncaught 100\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("catch")]),e._v("代码之中又抛出了一个错误。")]),e._v(" "),t("p",[e._v("为了捕捉不同类型的错误，"),t("code",[e._v("catch")]),e._v("代码块之中可以加入判断语句。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('try {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + ": " + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + ": " + e.message);\n  }\n  // ...\n}\n')])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("catch")]),e._v("捕获错误之后，会判断错误类型（"),t("code",[e._v("EvalError")]),e._v("还是"),t("code",[e._v("RangeError")]),e._v("），进行不同的处理。")]),e._v(" "),t("h3",{attrs:{id:"finally-代码块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finally-代码块"}},[e._v("#")]),e._v(" finally 代码块")]),e._v(" "),t("p",[t("code",[e._v("try...catch")]),e._v("结构允许在最后添加一个"),t("code",[e._v("finally")]),e._v("代码块，表示不管是否出现错误，都必需在最后运行的语句。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function cleansUp() {\n  try {\n    throw new Error('出错了……');\n    console.log('此行不会执行');\n  } finally {\n    console.log('完成清理工作');\n  }\n}\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (<anonymous>:3:11)\n//    at <anonymous>:10:1\n")])])]),t("p",[e._v("上面代码中，由于没有"),t("code",[e._v("catch")]),e._v("语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行"),t("code",[e._v("finally")]),e._v("代码块，然后再向用户提示报错信息。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log('FINALLY');\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("try")]),e._v("代码块没有发生错误，而且里面还包括"),t("code",[e._v("return")]),e._v("语句，但是"),t("code",[e._v("finally")]),e._v("代码块依然会执行。而且，这个函数的返回值还是"),t("code",[e._v("result")]),e._v("。")]),e._v(" "),t("p",[e._v("下面的例子说明，"),t("code",[e._v("return")]),e._v("语句的执行是排在"),t("code",[e._v("finally")]),e._v("代码之前，只是等"),t("code",[e._v("finally")]),e._v("代码执行完毕后才返回。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n")])])]),t("p",[e._v("上面代码说明，"),t("code",[e._v("return")]),e._v("语句里面的"),t("code",[e._v("count")]),e._v("的值，是在"),t("code",[e._v("finally")]),e._v("代码块运行之前就获取了。")]),e._v(" "),t("p",[e._v("下面是"),t("code",[e._v("finally")]),e._v("代码块用法的典型场景。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("openFile();\n\ntry {\n  writeFile(Data);\n} catch(e) {\n  handleError(e);\n} finally {\n  closeFile();\n}\n")])])]),t("p",[e._v("上面代码首先打开一个文件，然后在"),t("code",[e._v("try")]),e._v("代码块中写入文件，如果没有发生错误，则运行"),t("code",[e._v("finally")]),e._v("代码块关闭文件；一旦发生错误，则先使用"),t("code",[e._v("catch")]),e._v("代码块处理错误，再使用"),t("code",[e._v("finally")]),e._v("代码块关闭文件。")]),e._v(" "),t("p",[e._v("下面的例子充分反映了"),t("code",[e._v("try...catch...finally")]),e._v("这三者之间的执行顺序。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function f() {\n  try {\n    console.log(0);\n    throw 'bug';\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("catch")]),e._v("代码块结束执行之前，会先执行"),t("code",[e._v("finally")]),e._v("代码块。")]),e._v(" "),t("p",[t("code",[e._v("catch")]),e._v("代码块之中，触发转入"),t("code",[e._v("finally")]),e._v("代码块的标志，不仅有"),t("code",[e._v("return")]),e._v("语句，还有"),t("code",[e._v("throw")]),e._v("语句。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n")])])]),t("p",[e._v("上面代码中，进入"),t("code",[e._v("catch")]),e._v("代码块之后，一遇到"),t("code",[e._v("throw")]),e._v("语句，就会去执行"),t("code",[e._v("finally")]),e._v("代码块，其中有"),t("code",[e._v("return false")]),e._v("语句，因此就直接返回了，不再会回去执行"),t("code",[e._v("catch")]),e._v("代码块剩下的部分了。")]),e._v(" "),t("p",[t("code",[e._v("try")]),e._v("代码块内部，还可以再使用"),t("code",[e._v("try")]),e._v("代码块。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("try {\n  try {\n    consle.log('Hello world!'); // 报错\n  }\n  finally {\n    console.log('Finally');\n  }\n  console.log('Will I run?');\n} catch(error) {\n  console.error(error.message);\n}\n// Finally\n// consle is not defined\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("try")]),e._v("里面还有一个"),t("code",[e._v("try")]),e._v("。内层的"),t("code",[e._v("try")]),e._v("报错（"),t("code",[e._v("console")]),e._v("拼错了），这时会执行内层的"),t("code",[e._v("finally")]),e._v("代码块，然后抛出错误，被外层的"),t("code",[e._v("catch")]),e._v("捕获。")]),e._v(" "),t("h3",{attrs:{id:"参考连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考连接"}},[e._v("#")]),e._v(" 参考连接")]),e._v(" "),t("ul",[t("li",[e._v("Jani Hartikainen, "),t("a",{attrs:{href:"https://davidwalsh.name/fix-javascript-errors",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Errors and How to Fix Them"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"编程风格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编程风格"}},[e._v("#")]),e._v(" 编程风格")]),e._v(" "),t("h3",{attrs:{id:"概述-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("p",[e._v("“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格。")]),e._v(" "),t("p",[e._v("有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序。")]),e._v(" "),t("p",[e._v("所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 JavaScript 这种语法自由度很高的语言尤其重要。")]),e._v(" "),t("p",[e._v("必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格。")]),e._v(" "),t("h3",{attrs:{id:"缩进"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缩进"}},[e._v("#")]),e._v(" 缩进")]),e._v(" "),t("p",[e._v("行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。")]),e._v(" "),t("p",[e._v("Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一。")]),e._v(" "),t("p",[e._v("无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键。")]),e._v(" "),t("h3",{attrs:{id:"区块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区块"}},[e._v("#")]),e._v(" 区块")]),e._v(" "),t("p",[e._v("如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (a)\n  b();\n  c();\n")])])]),t("p",[e._v("上面代码的原意可能是下面这样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (a) {\n  b();\n  c();\n}\n")])])]),t("p",[e._v("但是，实际效果却是下面这样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (a) {\n  b();\n}\n  c();\n")])])]),t("p",[e._v("因此，建议总是使用大括号表示区块。")]),e._v(" "),t("p",[e._v("另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("block\n{\n  // ...\n}\n")])])]),t("p",[e._v("另一种是起首的大括号跟在关键字的后面。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("block {\n  // ...\n}\n")])])]),t("p",[e._v("一般来说，这两种写法都可以接受。但是，JavaScript 要使用后一种，因为 JavaScript 会自动添加句末的分号，导致一些难以察觉的错误。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("return\n{\n  key: value\n};\n\n// 相当于\nreturn;\n{\n  key: value\n};\n")])])]),t("p",[e._v("上面的代码的原意，是要返回一个对象，但实际上返回的是"),t("code",[e._v("undefined")]),e._v("，因为 JavaScript 自动在"),t("code",[e._v("return")]),e._v("语句后面添加了分号。为了避免这一类错误，需要写成下面这样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("return {\n  key : value\n};\n")])])]),t("p",[e._v("因此，表示区块起首的大括号，不要另起一行。")]),e._v(" "),t("h3",{attrs:{id:"圆括号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#圆括号"}},[e._v("#")]),e._v(" 圆括号")]),e._v(" "),t("p",[e._v("圆括号（parentheses）在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 圆括号表示函数的调用\nconsole.log('abc');\n\n// 圆括号表示表达式的组合\n(1 + 2) * 3\n")])])]),t("p",[e._v("建议可以用空格，区分这两种不同的括号。")]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("表示函数调用时，函数名与左括号之间没有空格。")]),e._v(" "),t("li",[e._v("表示函数定义时，函数名与左括号之间没有空格。")]),e._v(" "),t("li",[e._v("其他情况时，前面位置的语法元素与左括号之间，都有一个空格。")])])]),e._v(" "),t("p",[e._v("按照上面的规则，下面的写法都是不规范的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("foo (bar)\nreturn(a+b);\nif(a === 0) {...}\nfunction foo (b) {...}\nfunction(x) {...}\n")])])]),t("p",[e._v("上面代码的最后一行是一个匿名函数，"),t("code",[e._v("function")]),e._v("是语法关键字，不是函数名，所以与左括号之间应该要有一个空格。")]),e._v(" "),t("h3",{attrs:{id:"行尾的分号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行尾的分号"}},[e._v("#")]),e._v(" 行尾的分号")]),e._v(" "),t("p",[e._v("分号表示一条语句的结束。JavaScript 允许省略行尾的分号。事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号。")]),e._v(" "),t("h4",{attrs:{id:"不使用分号的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不使用分号的情况"}},[e._v("#")]),e._v(" 不使用分号的情况")]),e._v(" "),t("p",[e._v("首先，以下三种情况，语法规定本来就不需要在结尾添加分号。")]),e._v(" "),t("p",[t("strong",[e._v("（1）for 和 while 循环")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for ( ; ; ) {\n} // 没有分号\n\nwhile (true) {\n} // 没有分号\n")])])]),t("p",[e._v("注意，"),t("code",[e._v("do...while")]),e._v("循环是有分号的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("do {\n  a--;\n} while(a > 0); // 分号不能省略\n")])])]),t("p",[t("strong",[e._v("（2）分支语句：if，switch，try")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (true) {\n} // 没有分号\n\nswitch () {\n} // 没有分号\n\ntry {\n} catch {\n} // 没有分号\n")])])]),t("p",[t("strong",[e._v("（3）函数的声明语句")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function f() {\n} // 没有分号\n")])])]),t("p",[e._v("注意，函数表达式仍然要使用分号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var f = function f() {\n};\n")])])]),t("p",[e._v("以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句。")]),e._v(" "),t("h4",{attrs:{id:"分号的自动添加"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分号的自动添加"}},[e._v("#")]),e._v(" 分号的自动添加")]),e._v(" "),t("p",[e._v("除了上一节的三种情况，所有语句都应该使用分号。但是，如果没有使用分号，大多数情况下，JavaScript 会自动添加。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var a = 1\n// 等同于\nvar a = 1;\n")])])]),t("p",[e._v("这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）。")]),e._v(" "),t("p",[e._v("因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，JavaScript 就不会自动添加分号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 等同于 var a = 3\nvar\na\n=\n3\n\n// 等同于 'abc'.length\n'abc'\n.length\n\n// 等同于 return a + b;\nreturn a +\nb;\n\n// 等同于 obj.foo(arg1, arg2);\nobj.foo(arg1,\narg2);\n\n// 等同于 3 * 2 + 10 * (27 / 6)\n3 * 2\n+\n10 * (27 / 6)\n")])])]),t("p",[e._v("上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("x = y\n(function () {\n  // ...\n})();\n\n// 等同于\nx = y(function () {...})();\n")])])]),t("p",[e._v("下面是更多不会自动添加分号的例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 引擎解释为 c(d+e)\nvar a = b + c\n(d+e).toString();\n\n// 引擎解释为 a = b/hi/g.exec(c).map(d)\n// 正则表达式的斜杠，会当作除法运算符\na = b\n/hi/g.exec(c).map(d);\n\n// 解释为'b'['red', 'green']，\n// 即把字符串当作一个数组，按索引取值\nvar a = 'b'\n['red', 'green'].forEach(function (c) {\n  console.log(c);\n})\n\n// 解释为 function (x) { return x }(a++)\n// 即调用匿名函数，结果f等于0\nvar a = 0;\nvar f = function (x) { return x }\n(a++)\n")])])]),t("p",[e._v("只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript 引擎才会自动添加分号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (a < 0) a = 0\nconsole.log(a)\n\n// 等同于下面的代码，\n// 因为 0console 没有意义\nif (a < 0) a = 0;\nconsole.log(a)\n")])])]),t("p",[e._v("另外，如果一行的起首是“自增”（"),t("code",[e._v("++")]),e._v("）或“自减”（"),t("code",[e._v("--")]),e._v("）运算符，则它们的前面会自动添加分号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("a = b = c = 1\n\na\n++\nb\n--\nc\n\nconsole.log(a, b, c)\n// 1 2 0\n")])])]),t("p",[e._v("上面代码之所以会得到"),t("code",[e._v("1 2 0")]),e._v("的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("a = b = c = 1;\na;\n++b;\n--c;\n")])])]),t("p",[e._v("如果"),t("code",[e._v("continue")]),e._v("、"),t("code",[e._v("break")]),e._v("、"),t("code",[e._v("return")]),e._v("和"),t("code",[e._v("throw")]),e._v("这四个语句后面，直接跟换行符，则会自动添加分号。这意味着，如果"),t("code",[e._v("return")]),e._v("语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("return\n{ first: 'Jane' };\n\n// 解释成\nreturn;\n{ first: 'Jane' };\n")])])]),t("p",[e._v("由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。")]),e._v(" "),t("p",[e._v("不应该省略结尾的分号，还有一个原因。有些 JavaScript 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果。")]),e._v(" "),t("p",[e._v("另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(";var a = 1;\n// ...\n")])])]),t("p",[e._v("上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。")]),e._v(" "),t("h3",{attrs:{id:"全局变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局变量"}},[e._v("#")]),e._v(" 全局变量")]),e._v(" "),t("p",[e._v("JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。")]),e._v(" "),t("p",[e._v("因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如"),t("code",[e._v("UPPER_CASE")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"变量声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量声明"}},[e._v("#")]),e._v(" 变量声明")]),e._v(" "),t("p",[e._v("JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (!x) {\n  var x = {};\n}\n\n// 等同于\nvar x;\nif (!x) {\n  x = {};\n}\n")])])]),t("p",[e._v("这意味着，变量"),t("code",[e._v("x")]),e._v("是"),t("code",[e._v("if")]),e._v("代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i = 0; i < 10; i++) {\n  // ...\n}\n\n// 写成\nvar i;\nfor (i = 0; i < 10; i++) {\n  // ...\n}\n")])])]),t("p",[e._v("上面这样的写法，就容易看出存在一个全局的循环变量"),t("code",[e._v("i")]),e._v("。")]),e._v(" "),t("p",[e._v("另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部。")]),e._v(" "),t("h3",{attrs:{id:"with-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#with-语句"}},[e._v("#")]),e._v(" with 语句")]),e._v(" "),t("p",[t("code",[e._v("with")]),e._v("可以减少代码的书写，但是会造成混淆。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("with (o) {\n　foo = bar;\n}\n")])])]),t("p",[e._v("上面的代码，可以有四种运行结果：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("o.foo = bar;\no.foo = o.bar;\nfoo = bar;\nfoo = o.bar;\n")])])]),t("p",[e._v("这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用"),t("code",[e._v("with")]),e._v("语句。")]),e._v(" "),t("h3",{attrs:{id:"相等和严格相等"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相等和严格相等"}},[e._v("#")]),e._v(" 相等和严格相等")]),e._v(" "),t("p",[e._v("JavaScript 有两个表示相等的运算符：“相等”（"),t("code",[e._v("==")]),e._v("）和“严格相等”（"),t("code",[e._v("===")]),e._v("）。")]),e._v(" "),t("p",[e._v("相等运算符会自动转换变量类型，造成很多意想不到的情况。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("0 == ''// true\n1 == true // true\n2 == true // false\n0 == '0' // true\nfalse == 'false' // false\nfalse == '0' // true\n' \\t\\r\\n ' == 0 // true\n")])])]),t("p",[e._v("因此，建议不要使用相等运算符（"),t("code",[e._v("==")]),e._v("），只使用严格相等运算符（"),t("code",[e._v("===")]),e._v("）。")]),e._v(" "),t("h3",{attrs:{id:"语句的合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语句的合并"}},[e._v("#")]),e._v(" 语句的合并")]),e._v(" "),t("p",[e._v("有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("a = b;\nif (a) {\n  // ...\n}\n")])])]),t("p",[e._v("他喜欢写成下面这样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (a = b) {\n  // ...\n}\n")])])]),t("p",[e._v("虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if （a === b）{\n  // ...\n}\n")])])]),t("p",[e._v("建议不要将不同目的的语句，合并成一行。")]),e._v(" "),t("h3",{attrs:{id:"自增和自减运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自增和自减运算符"}},[e._v("#")]),e._v(" 自增和自减运算符")]),e._v(" "),t("p",[e._v("自增（"),t("code",[e._v("++")]),e._v("）和自减（"),t("code",[e._v("--")]),e._v("）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的"),t("code",[e._v("++")]),e._v("运算符都可以用"),t("code",[e._v("+= 1")]),e._v("代替。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("++x\n// 等同于\nx += 1;\n")])])]),t("p",[e._v("改用"),t("code",[e._v("+= 1")]),e._v("，代码变得更清晰了。")]),e._v(" "),t("p",[e._v("建议自增（"),t("code",[e._v("++")]),e._v("）和自减（"),t("code",[e._v("--")]),e._v("）运算符尽量使用"),t("code",[e._v("+=")]),e._v("和"),t("code",[e._v("-=")]),e._v("代替。")]),e._v(" "),t("h3",{attrs:{id:"switch-case-结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#switch-case-结构"}},[e._v("#")]),e._v(" switch...case 结构")]),e._v(" "),t("p",[t("code",[e._v("switch...case")]),e._v("结构要求，在每一个"),t("code",[e._v("case")]),e._v("的最后一行必须是"),t("code",[e._v("break")]),e._v("语句，否则会接着运行下一个"),t("code",[e._v("case")]),e._v("。这样不仅容易忘记，还会造成代码的冗长。")]),e._v(" "),t("p",[e._v("而且，"),t("code",[e._v("switch...case")]),e._v("不使用大括号，不利于代码形式的统一。此外，这种结构类似于"),t("code",[e._v("goto")]),e._v("语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function doAction(action) {\n  switch (action) {\n    case 'hack':\n      return 'hack';\n    case 'slash':\n      return 'slash';\n    case 'run':\n      return 'run';\n    default:\n      throw new Error('Invalid action.');\n  }\n}\n")])])]),t("p",[e._v("上面的代码建议改写成对象结构。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function doAction(action) {\n  var actions = {\n    'hack': function () {\n      return 'hack';\n    },\n    'slash': function () {\n      return 'slash';\n    },\n    'run': function () {\n      return 'run';\n    }\n  };\n\n  if (typeof actions[action] !== 'function') {\n    throw new Error('Invalid action.');\n  }\n\n  return actions[action]();\n}\n")])])]),t("p",[e._v("因此，建议"),t("code",[e._v("switch...case")]),e._v("结构可以用对象结构代替。")]),e._v(" "),t("h3",{attrs:{id:"参考链接-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-2"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),t("ul",[t("li",[e._v("Eric Elliott, Programming JavaScript Applications, "),t("a",{attrs:{href:"http://chimera.labs.oreilly.com/books/1234000000262/ch02.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chapter 2. JavaScript Style Guide"),t("OutboundLink")],1),e._v(", O'Reilly, 2013")]),e._v(" "),t("li",[e._v("Axel Rauschmayer, "),t("a",{attrs:{href:"http://www.2ality.com/2013/07/meta-style-guide.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("A meta style guide for JavaScript"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Axel Rauschmayer, "),t("a",{attrs:{href:"http://www.2ality.com/2011/05/semicolon-insertion.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Automatic semicolon insertion in JavaScript"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Rod Vagg, "),t("a",{attrs:{href:"http://dailyjs.com/2012/04/19/semicolons/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript and Semicolons"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"console-对象与控制台"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-对象与控制台"}},[e._v("#")]),e._v(" console 对象与控制台")]),e._v(" "),t("h3",{attrs:{id:"console-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-对象"}},[e._v("#")]),e._v(" console 对象")]),e._v(" "),t("p",[t("code",[e._v("console")]),e._v("对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出"),t("code",[e._v("stdout")]),e._v("和标准错误"),t("code",[e._v("stderr")]),e._v("，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。")]),e._v(" "),t("p",[t("code",[e._v("console")]),e._v("的常见用途有两个。")]),e._v(" "),t("ul",[t("li",[e._v("调试程序，显示网页代码运行时的错误信息。")]),e._v(" "),t("li",[e._v("提供了一个命令行接口，用来与网页代码互动。")])]),e._v(" "),t("p",[t("code",[e._v("console")]),e._v("对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。")]),e._v(" "),t("ol",[t("li",[e._v("按 F12 或者"),t("code",[e._v("Control + Shift + i")]),e._v("（PC）/ "),t("code",[e._v("Command + Option + i")]),e._v("（Mac）。")]),e._v(" "),t("li",[e._v("浏览器菜单选择“工具/开发者工具”。")]),e._v(" "),t("li",[e._v("在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。")])]),e._v(" "),t("p",[e._v("打开开发者工具以后，顶端有多个面板。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Elements")]),e._v("：查看网页的 HTML 源码和 CSS 代码。")]),e._v(" "),t("li",[t("strong",[e._v("Resources")]),e._v("：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。")]),e._v(" "),t("li",[t("strong",[e._v("Network")]),e._v("：查看网页的 HTTP 通信情况。")]),e._v(" "),t("li",[t("strong",[e._v("Sources")]),e._v("：查看网页加载的脚本源码。")]),e._v(" "),t("li",[t("strong",[e._v("Timeline")]),e._v("：查看各种网页行为随时间变化的情况。")]),e._v(" "),t("li",[t("strong",[e._v("Performance")]),e._v("：查看网页的性能情况，比如 CPU 和内存消耗。")]),e._v(" "),t("li",[t("strong",[e._v("Console")]),e._v("：用来运行 JavaScript 命令。")])]),e._v(" "),t("p",[e._v("这些面板都有各自的用途，以下只介绍"),t("code",[e._v("Console")]),e._v("面板（又称为控制台）。")]),e._v(" "),t("p",[t("code",[e._v("Console")]),e._v("面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。")]),e._v(" "),t("h3",{attrs:{id:"console-对象的静态方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-对象的静态方法"}},[e._v("#")]),e._v(" console 对象的静态方法")]),e._v(" "),t("p",[t("code",[e._v("console")]),e._v("对象提供的各种静态方法，用来与控制台窗口互动。")]),e._v(" "),t("h4",{attrs:{id:"console-log-console-info-console-debug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-log-console-info-console-debug"}},[e._v("#")]),e._v(" console.log()，console.info()，console.debug()")]),e._v(" "),t("p",[t("code",[e._v("console.log")]),e._v("方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log('Hello World')\n// Hello World\nconsole.log('a', 'b', 'c')\n// a b c\n")])])]),t("p",[t("code",[e._v("console.log")]),e._v("方法会自动在每次输出的结尾，添加换行符。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(1);\nconsole.log(2);\nconsole.log(3);\n// 1\n// 2\n// 3\n")])])]),t("p",[e._v("如果第一个参数是格式字符串（使用了格式占位符），"),t("code",[e._v("console.log")]),e._v("方法将依次用后面的参数替换占位符，然后再进行输出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(' %s + %s = %s', 1, 1, 2)\n//  1 + 1 = 2\n")])])]),t("p",[e._v("上面代码中，"),t("code",[e._v("console.log")]),e._v("方法的第一个参数有三个占位符（"),t("code",[e._v("%s")]),e._v("），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。")]),e._v(" "),t("p",[t("code",[e._v("console.log")]),e._v("方法支持以下占位符，不同类型的数据必须使用对应的占位符。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("%s")]),e._v(" 字符串")]),e._v(" "),t("li",[t("code",[e._v("%d")]),e._v(" 整数")]),e._v(" "),t("li",[t("code",[e._v("%i")]),e._v(" 整数")]),e._v(" "),t("li",[t("code",[e._v("%f")]),e._v(" 浮点数")]),e._v(" "),t("li",[t("code",[e._v("%o")]),e._v(" 对象的链接")]),e._v(" "),t("li",[t("code",[e._v("%c")]),e._v(" CSS 格式字符串")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var number = 11 * 9;\nvar color = 'red';\n\nconsole.log('%d %s balloons', number, color);\n// 99 red balloons\n")])])]),t("p",[e._v("上面代码中，第二个参数是数值，对应的占位符是"),t("code",[e._v("%d")]),e._v("，第三个参数是字符串，对应的占位符是"),t("code",[e._v("%s")]),e._v("。")]),e._v(" "),t("p",[e._v("使用"),t("code",[e._v("%c")]),e._v("占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(\n  '%cThis text is styled!',\n  'color: red; background: yellow; font-size: 24px;'\n)\n")])])]),t("p",[e._v("上面代码运行后，输出的内容将显示为黄底红字。")]),e._v(" "),t("p",[t("code",[e._v("console.log")]),e._v("方法的两种参数格式，可以结合在一起使用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(' %s + %s ', 1, 1, '= 2')\n// 1 + 1  = 2\n")])])]),t("p",[e._v("如果参数是一个对象，"),t("code",[e._v("console.log")]),e._v("会显示该对象的值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log({foo: 'bar'})\n// Object {foo: \"bar\"}\nconsole.log(Date)\n// function Date() { [native code] }\n")])])]),t("p",[e._v("上面代码输出"),t("code",[e._v("Date")]),e._v("对象的值，结果为一个构造函数。")]),e._v(" "),t("p",[t("code",[e._v("console.info")]),e._v("是"),t("code",[e._v("console.log")]),e._v("方法的别名，用法完全一样。只不过"),t("code",[e._v("console.info")]),e._v("方法会在输出信息的前面，加上一个蓝色图标。")]),e._v(" "),t("p",[t("code",[e._v("console.debug")]),e._v("方法与"),t("code",[e._v("console.log")]),e._v("方法类似，会在控制台输出调试信息。但是，默认情况下，"),t("code",[e._v("console.debug")]),e._v("输出的信息不会显示，只有在打开显示级别在"),t("code",[e._v("verbose")]),e._v("的情况下，才会显示。")]),e._v(" "),t("p",[t("code",[e._v("console")]),e._v("对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义"),t("code",[e._v("console.log")]),e._v("方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("['log', 'info', 'warn', 'error'].forEach(function(method) {\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n});\n\nconsole.log(\"出错了！\");\n// 2014-05-18T09:00.000Z 出错了！\n")])])]),t("p",[e._v("上面代码表示，使用自定义的"),t("code",[e._v("console.log")]),e._v("方法，可以在显示结果添加当前时间。")]),e._v(" "),t("h4",{attrs:{id:"console-warn-console-error"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-warn-console-error"}},[e._v("#")]),e._v(" console.warn()，console.error()")]),e._v(" "),t("p",[t("code",[e._v("warn")]),e._v("方法和"),t("code",[e._v("error")]),e._v("方法也是在控制台输出信息，它们与"),t("code",[e._v("log")]),e._v("方法的不同之处在于，"),t("code",[e._v("warn")]),e._v("方法输出信息时，在最前面加一个黄色三角，表示警告；"),t("code",[e._v("error")]),e._v("方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.error('Error: %s (%i)', 'Server is not responding', 500)\n// Error: Server is not responding (500)\nconsole.warn('Warning! Too few nodes (%d)', document.childNodes.length)\n// Warning! Too few nodes (1)\n")])])]),t("p",[e._v("可以这样理解，"),t("code",[e._v("log")]),e._v("方法是写入标准输出（"),t("code",[e._v("stdout")]),e._v("），"),t("code",[e._v("warn")]),e._v("方法和"),t("code",[e._v("error")]),e._v("方法是写入标准错误（"),t("code",[e._v("stderr")]),e._v("）。")]),e._v(" "),t("h4",{attrs:{id:"console-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-table"}},[e._v("#")]),e._v(" console.table()")]),e._v(" "),t("p",[e._v("对于某些复合类型的数据，"),t("code",[e._v("console.table")]),e._v("方法可以将其转为表格显示。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var languages = [\n  { name: "JavaScript", fileExtension: ".js" },\n  { name: "TypeScript", fileExtension: ".ts" },\n  { name: "CoffeeScript", fileExtension: ".coffee" }\n];\n\nconsole.table(languages);\n')])])]),t("p",[e._v("上面代码的"),t("code",[e._v("language")]),e._v("变量，转为表格显示如下。")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("(index)")]),e._v(" "),t("th",[e._v("name")]),e._v(" "),t("th",[e._v("fileExtension")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("0")]),e._v(" "),t("td",[e._v('"JavaScript"')]),e._v(" "),t("td",[e._v('".js"')])]),e._v(" "),t("tr",[t("td",[e._v("1")]),e._v(" "),t("td",[e._v('"TypeScript"')]),e._v(" "),t("td",[e._v('".ts"')])]),e._v(" "),t("tr",[t("td",[e._v("2")]),e._v(" "),t("td",[e._v('"CoffeeScript"')]),e._v(" "),t("td",[e._v('".coffee"')])])])]),e._v(" "),t("p",[e._v("下面是显示表格内容的例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var languages = {\n  csharp: { name: "C#", paradigm: "object-oriented" },\n  fsharp: { name: "F#", paradigm: "functional" }\n};\n\nconsole.table(languages);\n')])])]),t("p",[e._v("上面代码的"),t("code",[e._v("language")]),e._v("，转为表格显示如下。")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("(index)")]),e._v(" "),t("th",[e._v("name")]),e._v(" "),t("th",[e._v("paradigm")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("csharp")]),e._v(" "),t("td",[e._v('"C#"')]),e._v(" "),t("td",[e._v('"object-oriented"')])]),e._v(" "),t("tr",[t("td",[e._v("fsharp")]),e._v(" "),t("td",[e._v('"F#"')]),e._v(" "),t("td",[e._v('"functional"')])])])]),e._v(" "),t("h4",{attrs:{id:"console-count"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-count"}},[e._v("#")]),e._v(" console.count()")]),e._v(" "),t("p",[t("code",[e._v("count")]),e._v("方法用于计数，输出它被调用了多少次。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function greet(user) {\n  console.count();\n  return 'hi ' + user;\n}\n\ngreet('bob')\n//  : 1\n// \"hi bob\"\n\ngreet('alice')\n//  : 2\n// \"hi alice\"\n\ngreet('bob')\n//  : 3\n// \"hi bob\"\n")])])]),t("p",[e._v("上面代码每次调用"),t("code",[e._v("greet")]),e._v("函数，内部的"),t("code",[e._v("console.count")]),e._v("方法就输出执行次数。")]),e._v(" "),t("p",[e._v("该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function greet(user) {\n  console.count(user);\n  return "hi " + user;\n}\n\ngreet(\'bob\')\n// bob: 1\n// "hi bob"\n\ngreet(\'alice\')\n// alice: 1\n// "hi alice"\n\ngreet(\'bob\')\n// bob: 2\n// "hi bob"\n')])])]),t("p",[e._v("上面代码根据参数的不同，显示"),t("code",[e._v("bob")]),e._v("执行了两次，"),t("code",[e._v("alice")]),e._v("执行了一次。")]),e._v(" "),t("h4",{attrs:{id:"console-dir-console-dirxml"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-dir-console-dirxml"}},[e._v("#")]),e._v(" console.dir()，console.dirxml()")]),e._v(" "),t("p",[t("code",[e._v("dir")]),e._v("方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log({f1: 'foo', f2: 'bar'})\n// Object {f1: \"foo\", f2: \"bar\"}\n\nconsole.dir({f1: 'foo', f2: 'bar'})\n// Object\n//   f1: \"foo\"\n//   f2: \"bar\"\n//   __proto__: Object\n")])])]),t("p",[e._v("上面代码显示"),t("code",[e._v("dir")]),e._v("方法的输出结果，比"),t("code",[e._v("log")]),e._v("方法更易读，信息也更丰富。")]),e._v(" "),t("p",[e._v("该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.dir(document.body)\n")])])]),t("p",[e._v("Node 环境之中，还可以指定以代码高亮的形式输出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.dir(obj, {colors: true})\n")])])]),t("p",[t("code",[e._v("dirxml")]),e._v("方法主要用于以目录树的形式，显示 DOM 节点。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.dirxml(document.body)\n")])])]),t("p",[e._v("如果参数不是 DOM 节点，而是普通的 JavaScript 对象，"),t("code",[e._v("console.dirxml")]),e._v("等同于"),t("code",[e._v("console.dir")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.dirxml([1, 2, 3])\n// 等同于\nconsole.dir([1, 2, 3])\n")])])]),t("h4",{attrs:{id:"console-assert"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-assert"}},[e._v("#")]),e._v(" console.assert()")]),e._v(" "),t("p",[t("code",[e._v("console.assert")]),e._v("方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。")]),e._v(" "),t("p",[e._v("它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为"),t("code",[e._v("false")]),e._v("，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.assert(false, '判断条件不成立')\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry {\n  if (!false) {\n    throw new Error('判断条件不成立');\n  }\n} catch(e) {\n  console.error(e);\n}\n")])])]),t("p",[e._v("下面是一个例子，判断子节点的个数是否大于等于500。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.assert(list.childNodes.length < 500, '节点个数大于等于500')\n")])])]),t("p",[e._v("上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。")]),e._v(" "),t("h4",{attrs:{id:"console-time-console-timeend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-time-console-timeend"}},[e._v("#")]),e._v(" console.time()，console.timeEnd()")]),e._v(" "),t("p",[e._v("这两个方法用于计时，可以算出一个操作所花费的准确时间。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.time('Array initialize');\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n  array[i] = new Object();\n};\n\nconsole.timeEnd('Array initialize');\n// Array initialize: 1914.481ms\n")])])]),t("p",[t("code",[e._v("time")]),e._v("方法表示计时开始，"),t("code",[e._v("timeEnd")]),e._v("方法表示计时结束。它们的参数是计时器的名称。调用"),t("code",[e._v("timeEnd")]),e._v("方法之后，控制台会显示“计时器名称: 所耗费的时间”。")]),e._v(" "),t("h4",{attrs:{id:"console-group-console-groupend-console-groupcollapsed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-group-console-groupend-console-groupcollapsed"}},[e._v("#")]),e._v(" console.group()，console.groupEnd()，console.groupCollapsed()")]),e._v(" "),t("p",[t("code",[e._v("console.group")]),e._v("和"),t("code",[e._v("console.groupEnd")]),e._v("这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.group('一级分组');\nconsole.log('一级分组的内容');\n\nconsole.group('二级分组');\nconsole.log('二级分组的内容');\n\nconsole.groupEnd(); // 二级分组结束\nconsole.groupEnd(); // 一级分组结束\n")])])]),t("p",[e._v("上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。")]),e._v(" "),t("p",[t("code",[e._v("console.groupCollapsed")]),e._v("方法与"),t("code",[e._v("console.group")]),e._v("方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.groupCollapsed('Fetching Data');\n\nconsole.log('Request Sent');\nconsole.error('Error: Server not responding (500)');\n\nconsole.groupEnd();\n")])])]),t("p",[e._v("上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。")]),e._v(" "),t("h4",{attrs:{id:"console-trace-console-clear"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#console-trace-console-clear"}},[e._v("#")]),e._v(" console.trace()，console.clear()")]),e._v(" "),t("p",[t("code",[e._v("console.trace")]),e._v("方法显示当前执行的代码在堆栈中的调用路径。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.trace()\n// console.trace()\n//   (anonymous function)\n//   InjectedScript._evaluateOn\n//   InjectedScript._evaluateAndWrap\n//   InjectedScript.evaluate\n")])])]),t("p",[t("code",[e._v("console.clear")]),e._v("方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，"),t("code",[e._v("console.clear")]),e._v("方法将不起作用。")]),e._v(" "),t("h3",{attrs:{id:"控制台命令行-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制台命令行-api"}},[e._v("#")]),e._v(" 控制台命令行 API")]),e._v(" "),t("p",[e._v("浏览器控制台中，除了使用"),t("code",[e._v("console")]),e._v("对象，还可以使用一些控制台自带的命令行方法。")]),e._v(" "),t("p",[e._v("（1）"),t("code",[e._v("$_")])]),e._v(" "),t("p",[t("code",[e._v("$_")]),e._v("属性返回上一个表达式的值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("2 + 2\n// 4\n$_\n// 4\n")])])]),t("p",[e._v("（2）"),t("code",[e._v("$0")]),e._v(" - "),t("code",[e._v("$4")])]),e._v(" "),t("p",[e._v("控制台保存了最近5个在 Elements 面板选中的 DOM 元素，"),t("code",[e._v("$0")]),e._v("代表倒数第一个（最近一个），"),t("code",[e._v("$1")]),e._v("代表倒数第二个，以此类推直到"),t("code",[e._v("$4")]),e._v("。")]),e._v(" "),t("p",[e._v("（3）"),t("code",[e._v("$(selector)")])]),e._v(" "),t("p",[t("code",[e._v("$(selector)")]),e._v("返回第一个匹配的元素，等同于"),t("code",[e._v("document.querySelector()")]),e._v("。注意，如果页面脚本对"),t("code",[e._v("$")]),e._v("有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行"),t("code",[e._v("$(selector)")]),e._v("就会采用 jQuery 的实现，返回一个数组。")]),e._v(" "),t("p",[e._v("（4）"),t("code",[e._v("$$(selector)")])]),e._v(" "),t("p",[t("code",[e._v("$$(selector)")]),e._v("返回选中的 DOM 对象，等同于"),t("code",[e._v("document.querySelectorAll")]),e._v("。")]),e._v(" "),t("p",[e._v("（5）"),t("code",[e._v("$x(path)")])]),e._v(" "),t("p",[t("code",[e._v("$x(path)")]),e._v("方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('$x("//p[a]")\n')])])]),t("p",[e._v("上面代码返回所有包含"),t("code",[e._v("a")]),e._v("元素的"),t("code",[e._v("p")]),e._v("元素。")]),e._v(" "),t("p",[e._v("（6）"),t("code",[e._v("inspect(object)")])]),e._v(" "),t("p",[t("code",[e._v("inspect(object)")]),e._v("方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在"),t("code",[e._v("Elements")]),e._v("面板中显示，比如"),t("code",[e._v("inspect(document)")]),e._v("会在 Elements 面板显示"),t("code",[e._v("document")]),e._v("元素。JavaScript 对象在控制台面板"),t("code",[e._v("Profiles")]),e._v("面板中显示，比如"),t("code",[e._v("inspect(window)")]),e._v("。")]),e._v(" "),t("p",[e._v("（7）"),t("code",[e._v("getEventListeners(object)")])]),e._v(" "),t("p",[t("code",[e._v("getEventListeners(object)")]),e._v("方法返回一个对象，该对象的成员为"),t("code",[e._v("object")]),e._v("登记了回调函数的各种事件（比如"),t("code",[e._v("click")]),e._v("或"),t("code",[e._v("keydown")]),e._v("），每个事件对应一个数组，数组的成员为该事件的回调函数。")]),e._v(" "),t("p",[e._v("（8）"),t("code",[e._v("keys(object)")]),e._v("，"),t("code",[e._v("values(object)")])]),e._v(" "),t("p",[t("code",[e._v("keys(object)")]),e._v("方法返回一个数组，包含"),t("code",[e._v("object")]),e._v("的所有键名。")]),e._v(" "),t("p",[t("code",[e._v("values(object)")]),e._v("方法返回一个数组，包含"),t("code",[e._v("object")]),e._v("的所有键值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var o = {'p1': 'a', 'p2': 'b'};\n\nkeys(o)\n// [\"p1\", \"p2\"]\nvalues(o)\n// [\"a\", \"b\"]\n")])])]),t("p",[e._v("（9）"),t("code",[e._v("monitorEvents(object[, events]) ，unmonitorEvents(object[, events])")])]),e._v(" "),t("p",[t("code",[e._v("monitorEvents(object[, events])")]),e._v("方法监听特定对象上发生的特定事件。事件发生时，会返回一个"),t("code",[e._v("Event")]),e._v("对象，包含该事件的相关信息。"),t("code",[e._v("unmonitorEvents")]),e._v("方法用于停止监听。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('monitorEvents(window, "resize");\nmonitorEvents(window, ["resize", "scroll"])\n')])])]),t("p",[e._v("上面代码分别表示单个事件和多个事件的监听方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("monitorEvents($0, 'mouse');\nunmonitorEvents($0, 'mousemove');\n")])])]),t("p",[e._v("上面代码表示如何停止监听。")]),e._v(" "),t("p",[t("code",[e._v("monitorEvents")]),e._v("允许监听同一大类的事件。所有事件可以分成四个大类。")]),e._v(" "),t("ul",[t("li",[e._v('mouse："mousedown", "mouseup", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mousewheel"')]),e._v(" "),t("li",[e._v('key："keydown", "keyup", "keypress", "textInput"')]),e._v(" "),t("li",[e._v('touch："touchstart", "touchmove", "touchend", "touchcancel"')]),e._v(" "),t("li",[e._v('control："resize", "scroll", "zoom", "focus", "blur", "select", "change", "submit", "reset"')])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('monitorEvents($("#msg"), "key");\n')])])]),t("p",[e._v("上面代码表示监听所有"),t("code",[e._v("key")]),e._v("大类的事件。")]),e._v(" "),t("p",[e._v("（10）其他方法")]),e._v(" "),t("p",[e._v("命令行 API 还提供以下方法。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("clear()")]),e._v("：清除控制台的历史。")]),e._v(" "),t("li",[t("code",[e._v("copy(object)")]),e._v("：复制特定 DOM 元素到剪贴板。")]),e._v(" "),t("li",[t("code",[e._v("dir(object)")]),e._v("：显示特定对象的所有属性，是"),t("code",[e._v("console.dir")]),e._v("方法的别名。")]),e._v(" "),t("li",[t("code",[e._v("dirxml(object)")]),e._v("：显示特定对象的 XML 形式，是"),t("code",[e._v("console.dirxml")]),e._v("方法的别名。")])]),e._v(" "),t("h3",{attrs:{id:"debugger-语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#debugger-语句"}},[e._v("#")]),e._v(" debugger 语句")]),e._v(" "),t("p",[t("code",[e._v("debugger")]),e._v("语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到"),t("code",[e._v("debugger")]),e._v("语句时会自动停下。如果没有除错工具，"),t("code",[e._v("debugger")]),e._v("语句不会产生任何结果，JavaScript 引擎自动跳过这一句。")]),e._v(" "),t("p",[e._v("Chrome 浏览器中，当代码运行到"),t("code",[e._v("debugger")]),e._v("语句时，就会暂停运行，自动打开脚本源码界面。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for(var i = 0; i < 5; i++){\n  console.log(i);\n  if (i === 2) debugger;\n}\n")])])]),t("p",[e._v("上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。")]),e._v(" "),t("h3",{attrs:{id:"参考链接-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-3"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),t("ul",[t("li",[e._v("Chrome Developer Tools, "),t("a",{attrs:{href:"https://developers.google.com/chrome-developer-tools/docs/console",target:"_blank",rel:"noopener noreferrer"}},[e._v("Using the Console"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Matt West, "),t("a",{attrs:{href:"http://blog.teamtreehouse.com/mastering-developer-tools-console",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mastering The Developer Tools Console"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Firebug Wiki, "),t("a",{attrs:{href:"https://getfirebug.com/wiki/index.php/Console_API",target:"_blank",rel:"noopener noreferrer"}},[e._v("Console API"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Axel Rauschmayer, "),t("a",{attrs:{href:"http://www.2ality.com/2013/10/console-api.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("The JavaScript console API"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Marius Schulz, "),t("a",{attrs:{href:"http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable",target:"_blank",rel:"noopener noreferrer"}},[e._v("Advanced JavaScript Debugging with console.table()"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("Google Developer, "),t("a",{attrs:{href:"https://developers.google.com/chrome-developer-tools/docs/commandline-api",target:"_blank",rel:"noopener noreferrer"}},[e._v("Command Line API Reference"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=v.exports}}]);