(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{652:function(e,t,a){"use strict";a.r(t);var n=a(25),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"面向对象编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程"}},[e._v("#")]),e._v(" 面向对象编程")]),e._v(" "),a("h2",{attrs:{id:"实例对象与new命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例对象与new命令"}},[e._v("#")]),e._v(" 实例对象与new命令")]),e._v(" "),a("p",[e._v("JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。")]),e._v(" "),a("h3",{attrs:{id:"对象是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象是什么"}},[e._v("#")]),e._v(" 对象是什么")]),e._v(" "),a("p",[e._v("面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。")]),e._v(" "),a("p",[e._v("每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。")]),e._v(" "),a("p",[e._v("那么，“对象”（object）到底是什么？我们从两个层次来理解。")]),e._v(" "),a("p",[a("strong",[e._v("（1）对象是单个实物的抽象。")])]),e._v(" "),a("p",[e._v("一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。")]),e._v(" "),a("p",[a("strong",[e._v("（2）对象是一个容器，封装了属性（property）和方法（method）。")])]),e._v(" "),a("p",[e._v("属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为"),a("code",[e._v("animal")]),e._v("对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。")]),e._v(" "),a("h3",{attrs:{id:"构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[e._v("#")]),e._v(" 构造函数")]),e._v(" "),a("p",[e._v("面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。")]),e._v(" "),a("p",[e._v("典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。")]),e._v(" "),a("p",[e._v("JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。")]),e._v(" "),a("p",[e._v("构造函数就是一个普通的函数，但具有自己的特征和用法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function () {\n  this.price = 1000;\n};\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Vehicle")]),e._v("就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。")]),e._v(" "),a("p",[e._v("构造函数的特点有两个。")]),e._v(" "),a("ul",[a("li",[e._v("函数体内部使用了"),a("code",[e._v("this")]),e._v("关键字，代表了所要生成的对象实例。")]),e._v(" "),a("li",[e._v("生成对象的时候，必须使用"),a("code",[e._v("new")]),e._v("命令。")])]),e._v(" "),a("p",[e._v("下面先介绍"),a("code",[e._v("new")]),e._v("命令。")]),e._v(" "),a("h3",{attrs:{id:"new-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-命令"}},[e._v("#")]),e._v(" new 命令")]),e._v(" "),a("h4",{attrs:{id:"基本用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[e._v("#")]),e._v(" 基本用法")]),e._v(" "),a("p",[a("code",[e._v("new")]),e._v("命令的作用，就是执行构造函数，返回一个实例对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function () {\n  this.price = 1000;\n};\n\nvar v = new Vehicle();\nv.price // 1000\n")])])]),a("p",[e._v("上面代码通过"),a("code",[e._v("new")]),e._v("命令，让构造函数"),a("code",[e._v("Vehicle")]),e._v("生成一个实例对象，保存在变量"),a("code",[e._v("v")]),e._v("中。这个新生成的实例对象，从构造函数"),a("code",[e._v("Vehicle")]),e._v("得到了"),a("code",[e._v("price")]),e._v("属性。"),a("code",[e._v("new")]),e._v("命令执行时，构造函数内部的"),a("code",[e._v("this")]),e._v("，就代表了新生成的实例对象，"),a("code",[e._v("this.price")]),e._v("表示实例对象有一个"),a("code",[e._v("price")]),e._v("属性，值是1000。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("new")]),e._v("命令时，根据需要，构造函数也可以接受参数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function (p) {\n  this.price = p;\n};\n\nvar v = new Vehicle(500);\n")])])]),a("p",[a("code",[e._v("new")]),e._v("命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 推荐的写法\nvar v = new Vehicle();\n// 不推荐的写法\nvar v = new Vehicle;\n")])])]),a("p",[e._v("一个很自然的问题是，如果忘了使用"),a("code",[e._v("new")]),e._v("命令，直接调用构造函数会发生什么事？")]),e._v(" "),a("p",[e._v("这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，"),a("code",[e._v("this")]),e._v("这时代表全局对象，将造成一些意想不到的结果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function (){\n  this.price = 1000;\n};\n\nvar v = Vehicle();\nv // undefined\nprice // 1000\n")])])]),a("p",[e._v("上面代码中，调用"),a("code",[e._v("Vehicle")]),e._v("构造函数时，忘了加上"),a("code",[e._v("new")]),e._v("命令。结果，变量"),a("code",[e._v("v")]),e._v("变成了"),a("code",[e._v("undefined")]),e._v("，而"),a("code",[e._v("price")]),e._v("属性变成了全局变量。因此，应该非常小心，避免不使用"),a("code",[e._v("new")]),e._v("命令、直接调用构造函数。")]),e._v(" "),a("p",[e._v("为了保证构造函数必须与"),a("code",[e._v("new")]),e._v("命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上"),a("code",[e._v("use strict")]),e._v("。这样的话，一旦忘了使用"),a("code",[e._v("new")]),e._v("命令，直接调用构造函数就会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Fubar(foo, bar){\n  'use strict';\n  this._foo = foo;\n  this._bar = bar;\n}\n\nFubar()\n// TypeError: Cannot set property '_foo' of undefined\n")])])]),a("p",[e._v("上面代码的"),a("code",[e._v("Fubar")]),e._v("为构造函数，"),a("code",[e._v("use strict")]),e._v("命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的"),a("code",[e._v("this")]),e._v("不能指向全局对象，默认等于"),a("code",[e._v("undefined")]),e._v("，导致不加"),a("code",[e._v("new")]),e._v("调用会报错（JavaScript 不允许对"),a("code",[e._v("undefined")]),e._v("添加属性）。")]),e._v(" "),a("p",[e._v("另一个解决办法，构造函数内部判断是否使用"),a("code",[e._v("new")]),e._v("命令，如果发现没有使用，则直接返回一个实例对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Fubar(foo, bar) {\n  if (!(this instanceof Fubar)) {\n    return new Fubar(foo, bar);\n  }\n\n  this._foo = foo;\n  this._bar = bar;\n}\n\nFubar(1, 2)._foo // 1\n(new Fubar(1, 2))._foo // 1\n")])])]),a("p",[e._v("上面代码中的构造函数，不管加不加"),a("code",[e._v("new")]),e._v("命令，都会得到同样的结果。")]),e._v(" "),a("h4",{attrs:{id:"new-命令的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-命令的原理"}},[e._v("#")]),e._v(" new 命令的原理")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("new")]),e._v("命令时，它后面的函数依次执行下面的步骤。")]),e._v(" "),a("ol",[a("li",[e._v("创建一个空对象，作为将要返回的对象实例。")]),e._v(" "),a("li",[e._v("将这个空对象的原型，指向构造函数的"),a("code",[e._v("prototype")]),e._v("属性。")]),e._v(" "),a("li",[e._v("将这个空对象赋值给函数内部的"),a("code",[e._v("this")]),e._v("关键字。")]),e._v(" "),a("li",[e._v("开始执行构造函数内部的代码。")])]),e._v(" "),a("p",[e._v("也就是说，构造函数内部，"),a("code",[e._v("this")]),e._v("指的是一个新生成的空对象，所有针对"),a("code",[e._v("this")]),e._v("的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即"),a("code",[e._v("this")]),e._v("对象），将其“构造”为需要的样子。")]),e._v(" "),a("p",[e._v("如果构造函数内部有"),a("code",[e._v("return")]),e._v("语句，而且"),a("code",[e._v("return")]),e._v("后面跟着一个对象，"),a("code",[e._v("new")]),e._v("命令会返回"),a("code",[e._v("return")]),e._v("语句指定的对象；否则，就会不管"),a("code",[e._v("return")]),e._v("语句，返回"),a("code",[e._v("this")]),e._v("对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function () {\n  this.price = 1000;\n  return 1000;\n};\n\n(new Vehicle()) === 1000\n// false\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("Vehicle")]),e._v("的"),a("code",[e._v("return")]),e._v("语句返回一个数值。这时，"),a("code",[e._v("new")]),e._v("命令就会忽略这个"),a("code",[e._v("return")]),e._v("语句，返回“构造”后的"),a("code",[e._v("this")]),e._v("对象。")]),e._v(" "),a("p",[e._v("但是，如果"),a("code",[e._v("return")]),e._v("语句返回的是一个跟"),a("code",[e._v("this")]),e._v("无关的新对象，"),a("code",[e._v("new")]),e._v("命令会返回这个新对象，而不是"),a("code",[e._v("this")]),e._v("对象。这一点需要特别引起注意。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Vehicle = function (){\n  this.price = 1000;\n  return { price: 2000 };\n};\n\n(new Vehicle()).price\n// 2000\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("Vehicle")]),e._v("的"),a("code",[e._v("return")]),e._v("语句，返回的是一个新对象。"),a("code",[e._v("new")]),e._v("命令会返回这个对象，而不是"),a("code",[e._v("this")]),e._v("对象。")]),e._v(" "),a("p",[e._v("另一方面，如果对普通函数（内部没有"),a("code",[e._v("this")]),e._v("关键字的函数）使用"),a("code",[e._v("new")]),e._v("命令，则会返回一个空对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function getMessage() {\n  return 'this is a message';\n}\n\nvar msg = new getMessage();\n\nmsg // {}\ntypeof msg // \"object\"\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("getMessage")]),e._v("是一个普通函数，返回一个字符串。对它使用"),a("code",[e._v("new")]),e._v("命令，会得到一个空对象。这是因为"),a("code",[e._v("new")]),e._v("命令总是返回一个对象，要么是实例对象，要么是"),a("code",[e._v("return")]),e._v("语句指定的对象。本例中，"),a("code",[e._v("return")]),e._v("语句返回的是字符串，所以"),a("code",[e._v("new")]),e._v("命令就忽略了该语句。")]),e._v(" "),a("p",[a("code",[e._v("new")]),e._v("命令简化的内部流程，可以用下面的代码表示。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 实例\nvar actor = _new(Person, '张三', 28);\n")])])]),a("h4",{attrs:{id:"new-target"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-target"}},[e._v("#")]),e._v(" new.target")]),e._v(" "),a("p",[e._v("函数内部可以使用"),a("code",[e._v("new.target")]),e._v("属性。如果当前函数是"),a("code",[e._v("new")]),e._v("命令调用，"),a("code",[e._v("new.target")]),e._v("指向当前函数，否则为"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  console.log(new.target === f);\n}\n\nf() // false\nnew f() // true\n")])])]),a("p",[e._v("使用这个属性，可以判断函数调用的时候，是否使用"),a("code",[e._v("new")]),e._v("命令。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  if (!new.target) {\n    throw new Error('请使用 new 命令调用！');\n  }\n  // ...\n}\n\nf() // Uncaught Error: 请使用 new 命令调用！\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("f")]),e._v("调用时，没有使用"),a("code",[e._v("new")]),e._v("命令，就抛出一个错误。")]),e._v(" "),a("h3",{attrs:{id:"object-create-创建实例对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create-创建实例对象"}},[e._v("#")]),e._v(" Object.create() 创建实例对象")]),e._v(" "),a("p",[e._v("构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用"),a("code",[e._v("Object.create()")]),e._v("方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var person1 = {\n  name: '张三',\n  age: 38,\n  greeting: function() {\n    console.log('Hi! I\\'m ' + this.name + '.');\n  }\n};\n\nvar person2 = Object.create(person1);\n\nperson2.name // 张三\nperson2.greeting() // Hi! I'm 张三.\n")])])]),a("p",[e._v("上面代码中，对象"),a("code",[e._v("person1")]),e._v("是"),a("code",[e._v("person2")]),e._v("的模板，后者继承了前者的属性和方法。")]),e._v(" "),a("p",[a("code",[e._v("Object.create()")]),e._v("的详细介绍，请看后面的相关章节。")]),e._v(" "),a("h2",{attrs:{id:"this-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-关键字"}},[e._v("#")]),e._v(" this 关键字")]),e._v(" "),a("h3",{attrs:{id:"涵义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#涵义"}},[e._v("#")]),e._v(" 涵义")]),e._v(" "),a("p",[a("code",[e._v("this")]),e._v("关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。")]),e._v(" "),a("p",[e._v("前一章已经提到，"),a("code",[e._v("this")]),e._v("可以用在构造函数之中，表示实例对象。除此之外，"),a("code",[e._v("this")]),e._v("还可以用在别的场合。但不管是什么场合，"),a("code",[e._v("this")]),e._v("都有一个共同点：它总是返回一个对象。")]),e._v(" "),a("p",[e._v("简单说，"),a("code",[e._v("this")]),e._v("就是属性或方法“当前”所在的对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this.property\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("this")]),e._v("就代表"),a("code",[e._v("property")]),e._v("属性当前所在的对象。")]),e._v(" "),a("p",[e._v("下面是一个实际的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var person = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nperson.describe()\n// \"姓名：张三\"\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("this.name")]),e._v("表示"),a("code",[e._v("name")]),e._v("属性所在的那个对象。由于"),a("code",[e._v("this.name")]),e._v("是在"),a("code",[e._v("describe")]),e._v("方法中调用，而"),a("code",[e._v("describe")]),e._v("方法所在的当前对象是"),a("code",[e._v("person")]),e._v("，因此"),a("code",[e._v("this")]),e._v("指向"),a("code",[e._v("person")]),e._v("，"),a("code",[e._v("this.name")]),e._v("就是"),a("code",[e._v("person.name")]),e._v("。")]),e._v(" "),a("p",[e._v("由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即"),a("code",[e._v("this")]),e._v("的指向是可变的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var A = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nvar B = {\n  name: '李四'\n};\n\nB.describe = A.describe;\nB.describe()\n// \"姓名：李四\"\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("A.describe")]),e._v("属性被赋给"),a("code",[e._v("B")]),e._v("，于是"),a("code",[e._v("B.describe")]),e._v("就表示"),a("code",[e._v("describe")]),e._v("方法所在的当前对象是"),a("code",[e._v("B")]),e._v("，所以"),a("code",[e._v("this.name")]),e._v("就指向"),a("code",[e._v("B.name")]),e._v("。")]),e._v(" "),a("p",[e._v("稍稍重构这个例子，"),a("code",[e._v("this")]),e._v("的动态指向就能看得更清楚。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  return '姓名：'+ this.name;\n}\n\nvar A = {\n  name: '张三',\n  describe: f\n};\n\nvar B = {\n  name: '李四',\n  describe: f\n};\n\nA.describe() // \"姓名：张三\"\nB.describe() // \"姓名：李四\"\n")])])]),a("p",[e._v("上面代码中，函数"),a("code",[e._v("f")]),e._v("内部使用了"),a("code",[e._v("this")]),e._v("关键字，随着"),a("code",[e._v("f")]),e._v("所在的对象不同，"),a("code",[e._v("this")]),e._v("的指向也不同。")]),e._v(" "),a("p",[e._v("只要函数被赋给另一个变量，"),a("code",[e._v("this")]),e._v("的指向就会变。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var A = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nvar name = '李四';\nvar f = A.describe;\nf() // \"姓名：李四\"\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("A.describe")]),e._v("被赋值给变量"),a("code",[e._v("f")]),e._v("，内部的"),a("code",[e._v("this")]),e._v("就会指向"),a("code",[e._v("f")]),e._v("运行时所在的对象（本例是顶层对象）。")]),e._v(" "),a("p",[e._v("再看一个网页编程的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input type="text" name="age" size=3 onChange="validate(this, 18, 99);">\n\n<script>\nfunction validate(obj, lowval, hival){\n  if ((obj.value < lowval) || (obj.value > hival))\n    console.log(\'Invalid Value!\');\n}\n<\/script>\n')])])]),a("p",[e._v("上面代码是一个文本输入框，每当用户输入一个值，就会调用"),a("code",[e._v("onChange")]),e._v("回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此"),a("code",[e._v("this")]),e._v("就代表传入当前对象（即文本框），然后就可以从"),a("code",[e._v("this.value")]),e._v("上面读到用户的输入值。")]),e._v(" "),a("p",[e._v("总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，"),a("code",[e._v("this")]),e._v("就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，"),a("code",[e._v("this")]),e._v("的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。")]),e._v(" "),a("h3",{attrs:{id:"实质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实质"}},[e._v("#")]),e._v(" 实质")]),e._v(" "),a("p",[e._v("JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = { foo:  5 };\n")])])]),a("p",[e._v("上面的代码将一个对象赋值给变量"),a("code",[e._v("obj")]),e._v("。JavaScript 引擎会先在内存里面，生成一个对象"),a("code",[e._v("{ foo: 5 }")]),e._v("，然后把这个对象的内存地址赋值给变量"),a("code",[e._v("obj")]),e._v("。也就是说，变量"),a("code",[e._v("obj")]),e._v("是一个地址（reference）。后面如果要读取"),a("code",[e._v("obj.foo")]),e._v("，引擎先从"),a("code",[e._v("obj")]),e._v("拿到内存地址，然后再从该地址读出原始的对象，返回它的"),a("code",[e._v("foo")]),e._v("属性。")]),e._v(" "),a("p",[e._v("原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的"),a("code",[e._v("foo")]),e._v("属性，实际上是以下面的形式保存的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  foo: {\n    [[value]]: 5\n    [[writable]]: true\n    [[enumerable]]: true\n    [[configurable]]: true\n  }\n}\n")])])]),a("p",[e._v("注意，"),a("code",[e._v("foo")]),e._v("属性的值保存在属性描述对象的"),a("code",[e._v("value")]),e._v("属性里面。")]),e._v(" "),a("p",[e._v("这样的结构是很清晰的，问题在于属性的值可能是一个函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = { foo: function () {} };\n")])])]),a("p",[e._v("这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给"),a("code",[e._v("foo")]),e._v("属性的"),a("code",[e._v("value")]),e._v("属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n  foo: {\n    [[value]]: 函数的地址\n    ...\n  }\n}\n")])])]),a("p",[e._v("由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f = function () {};\nvar obj = { f: f };\n\n// 单独执行\nf()\n\n// obj 环境执行\nobj.f()\n")])])]),a("p",[e._v("JavaScript 允许在函数体内部，引用当前环境的其他变量。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f = function () {\n  console.log(x);\n};\n")])])]),a("p",[e._v("上面代码中，函数体里面使用了变量"),a("code",[e._v("x")]),e._v("。该变量由运行环境提供。")]),e._v(" "),a("p",[e._v("现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，"),a("code",[e._v("this")]),e._v("就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f = function () {\n  console.log(this.x);\n}\n")])])]),a("p",[e._v("上面代码中，函数体里面的"),a("code",[e._v("this.x")]),e._v("就是指当前运行环境的"),a("code",[e._v("x")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f = function () {\n  console.log(this.x);\n}\n\nvar x = 1;\nvar obj = {\n  f: f,\n  x: 2,\n};\n\n// 单独执行\nf() // 1\n\n// obj 环境执行\nobj.f() // 2\n")])])]),a("p",[e._v("上面代码中，函数"),a("code",[e._v("f")]),e._v("在全局环境执行，"),a("code",[e._v("this.x")]),e._v("指向全局环境的"),a("code",[e._v("x")]),e._v("；在"),a("code",[e._v("obj")]),e._v("环境执行，"),a("code",[e._v("this.x")]),e._v("指向"),a("code",[e._v("obj.x")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"使用场合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场合"}},[e._v("#")]),e._v(" 使用场合")]),e._v(" "),a("p",[a("code",[e._v("this")]),e._v("主要有以下几个使用场合。")]),e._v(" "),a("p",[a("strong",[e._v("（1）全局环境")])]),e._v(" "),a("p",[e._v("全局环境使用"),a("code",[e._v("this")]),e._v("，它指的就是顶层对象"),a("code",[e._v("window")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("this === window // true\n\nfunction f() {\n  console.log(this === window);\n}\nf() // true\n")])])]),a("p",[e._v("上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，"),a("code",[e._v("this")]),e._v("就是指顶层对象"),a("code",[e._v("window")]),e._v("。")]),e._v(" "),a("p",[a("strong",[e._v("（2）构造函数")])]),e._v(" "),a("p",[e._v("构造函数中的"),a("code",[e._v("this")]),e._v("，指的是实例对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var Obj = function (p) {\n  this.p = p;\n};\n")])])]),a("p",[e._v("上面代码定义了一个构造函数"),a("code",[e._v("Obj")]),e._v("。由于"),a("code",[e._v("this")]),e._v("指向实例对象，所以在构造函数内部定义"),a("code",[e._v("this.p")]),e._v("，就相当于定义实例对象有一个"),a("code",[e._v("p")]),e._v("属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = new Obj('Hello World!');\no.p // \"Hello World!\"\n")])])]),a("p",[a("strong",[e._v("（3）对象的方法")])]),e._v(" "),a("p",[e._v("如果对象的方法里面包含"),a("code",[e._v("this")]),e._v("，"),a("code",[e._v("this")]),e._v("的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变"),a("code",[e._v("this")]),e._v("的指向。")]),e._v(" "),a("p",[e._v("但是，这条规则很不容易把握。请看下面的代码。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj ={\n  foo: function () {\n    console.log(this);\n  }\n};\n\nobj.foo() // obj\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj.foo")]),e._v("方法执行时，它内部的"),a("code",[e._v("this")]),e._v("指向"),a("code",[e._v("obj")]),e._v("。")]),e._v(" "),a("p",[e._v("但是，下面这几种用法，都会改变"),a("code",[e._v("this")]),e._v("的指向。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 情况一\n(obj.foo = obj.foo)() // window\n// 情况二\n(false || obj.foo)() // window\n// 情况三\n(1, obj.foo)() // window\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj.foo")]),e._v("就是一个值。这个值真正调用的时候，运行环境已经不是"),a("code",[e._v("obj")]),e._v("了，而是全局环境，所以"),a("code",[e._v("this")]),e._v("不再指向"),a("code",[e._v("obj")]),e._v("。")]),e._v(" "),a("p",[e._v("可以这样理解，JavaScript 引擎内部，"),a("code",[e._v("obj")]),e._v("和"),a("code",[e._v("obj.foo")]),e._v("储存在两个内存地址，称为地址一和地址二。"),a("code",[e._v("obj.foo()")]),e._v("这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，"),a("code",[e._v("this")]),e._v("指向"),a("code",[e._v("obj")]),e._v("。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此"),a("code",[e._v("this")]),e._v("指向全局环境。上面三种情况等同于下面的代码。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 情况一\n(obj.foo = function () {\n  console.log(this);\n})()\n// 等同于\n(function () {\n  console.log(this);\n})()\n\n// 情况二\n(false || function () {\n  console.log(this);\n})()\n\n// 情况三\n(1, function () {\n  console.log(this);\n})()\n")])])]),a("p",[e._v("如果"),a("code",[e._v("this")]),e._v("所在的方法不在对象的第一层，这时"),a("code",[e._v("this")]),e._v("只是指向当前一层的对象，而不会继承更上面的层。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = {\n  p: 'Hello',\n  b: {\n    m: function() {\n      console.log(this.p);\n    }\n  }\n};\n\na.b.m() // undefined\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("a.b.m")]),e._v("方法在"),a("code",[e._v("a")]),e._v("对象的第二层，该方法内部的"),a("code",[e._v("this")]),e._v("不是指向"),a("code",[e._v("a")]),e._v("，而是指向"),a("code",[e._v("a.b")]),e._v("，因为实际执行的是下面的代码。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var b = {\n  m: function() {\n   console.log(this.p);\n  }\n};\n\nvar a = {\n  p: 'Hello',\n  b: b\n};\n\n(a.b).m() // 等同于 b.m()\n")])])]),a("p",[e._v("如果要达到预期效果，只有写成下面这样。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = {\n  b: {\n    m: function() {\n      console.log(this.p);\n    },\n    p: 'Hello'\n  }\n};\n")])])]),a("p",[e._v("如果这时将嵌套对象内部的方法赋值给一个变量，"),a("code",[e._v("this")]),e._v("依然会指向全局对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = {\n  b: {\n    m: function() {\n      console.log(this.p);\n    },\n    p: 'Hello'\n  }\n};\n\nvar hello = a.b.m;\nhello() // undefined\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("m")]),e._v("是多层对象内部的一个方法。为求简便，将其赋值给"),a("code",[e._v("hello")]),e._v("变量，结果调用时，"),a("code",[e._v("this")]),e._v("指向了顶层对象。为了避免这个问题，可以只将"),a("code",[e._v("m")]),e._v("所在的对象赋值给"),a("code",[e._v("hello")]),e._v("，这样调用时，"),a("code",[e._v("this")]),e._v("的指向就不会变。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var hello = a.b;\nhello.m() // Hello\n")])])]),a("h3",{attrs:{id:"使用注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用注意点"}},[e._v("#")]),e._v(" 使用注意点")]),e._v(" "),a("h4",{attrs:{id:"避免多层-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免多层-this"}},[e._v("#")]),e._v(" 避免多层 this")]),e._v(" "),a("p",[e._v("由于"),a("code",[e._v("this")]),e._v("的指向是不确定的，所以切勿在函数中包含多层的"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = {\n  f1: function () {\n    console.log(this);\n    var f2 = function () {\n      console.log(this);\n    }();\n  }\n}\n\no.f1()\n// Object\n// Window\n")])])]),a("p",[e._v("上面代码包含两层"),a("code",[e._v("this")]),e._v("，结果运行后，第一层指向对象"),a("code",[e._v("o")]),e._v("，第二层指向全局对象，因为实际执行的是下面的代码。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var temp = function () {\n  console.log(this);\n};\n\nvar o = {\n  f1: function () {\n    console.log(this);\n    var f2 = temp();\n  }\n}\n")])])]),a("p",[e._v("一个解决方法是在第二层改用一个指向外层"),a("code",[e._v("this")]),e._v("的变量。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = {\n  f1: function() {\n    console.log(this);\n    var that = this;\n    var f2 = function() {\n      console.log(that);\n    }();\n  }\n}\n\no.f1()\n// Object\n// Object\n")])])]),a("p",[e._v("上面代码定义了变量"),a("code",[e._v("that")]),e._v("，固定指向外层的"),a("code",[e._v("this")]),e._v("，然后在内层使用"),a("code",[e._v("that")]),e._v("，就不会发生"),a("code",[e._v("this")]),e._v("指向的改变。")]),e._v(" "),a("p",[e._v("事实上，使用一个变量固定"),a("code",[e._v("this")]),e._v("的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。")]),e._v(" "),a("p",[e._v("JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的"),a("code",[e._v("this")]),e._v("指向顶层对象，就会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var counter = {\n  count: 0\n};\ncounter.inc = function () {\n  'use strict';\n  this.count++\n};\nvar f = counter.inc;\nf()\n// TypeError: Cannot read property 'count' of undefined\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("inc")]),e._v("方法通过"),a("code",[e._v("'use strict'")]),e._v("声明采用严格模式，这时内部的"),a("code",[e._v("this")]),e._v("一旦指向顶层对象，就会报错。")]),e._v(" "),a("h4",{attrs:{id:"避免数组处理方法中的-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免数组处理方法中的-this"}},[e._v("#")]),e._v(" 避免数组处理方法中的 this")]),e._v(" "),a("p",[e._v("数组的"),a("code",[e._v("map")]),e._v("和"),a("code",[e._v("foreach")]),e._v("方法，允许提供一个函数作为参数。这个函数内部不应该使用"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    this.p.forEach(function (item) {\n      console.log(this.v + ' ' + item);\n    });\n  }\n}\n\no.f()\n// undefined a1\n// undefined a2\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("foreach")]),e._v("方法的回调函数中的"),a("code",[e._v("this")]),e._v("，其实是指向"),a("code",[e._v("window")]),e._v("对象，因此取不到"),a("code",[e._v("o.v")]),e._v("的值。原因跟上一段的多层"),a("code",[e._v("this")]),e._v("是一样的，就是内层的"),a("code",[e._v("this")]),e._v("不指向外部，而指向顶层对象。")]),e._v(" "),a("p",[e._v("解决这个问题的一种方法，就是前面提到的，使用中间变量固定"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    var that = this;\n    this.p.forEach(function (item) {\n      console.log(that.v+' '+item);\n    });\n  }\n}\n\no.f()\n// hello a1\n// hello a2\n")])])]),a("p",[e._v("另一种方法是将"),a("code",[e._v("this")]),e._v("当作"),a("code",[e._v("foreach")]),e._v("方法的第二个参数，固定它的运行环境。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    this.p.forEach(function (item) {\n      console.log(this.v + ' ' + item);\n    }, this);\n  }\n}\n\no.f()\n// hello a1\n// hello a2\n")])])]),a("h4",{attrs:{id:"避免回调函数中的-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免回调函数中的-this"}},[e._v("#")]),e._v(" 避免回调函数中的 this")]),e._v(" "),a("p",[e._v("回调函数中的"),a("code",[e._v("this")]),e._v("往往会改变指向，最好避免使用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = new Object();\no.f = function () {\n  console.log(this === o);\n}\n\n// jQuery 的写法\n$('#button').on('click', o.f);\n")])])]),a("p",[e._v("上面代码中，点击按钮以后，控制台会显示"),a("code",[e._v("false")]),e._v("。原因是此时"),a("code",[e._v("this")]),e._v("不再指向"),a("code",[e._v("o")]),e._v("对象，而是指向按钮的 DOM 对象，因为"),a("code",[e._v("f")]),e._v("方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。")]),e._v(" "),a("p",[e._v("为了解决这个问题，可以采用下面的一些方法对"),a("code",[e._v("this")]),e._v("进行绑定，也就是使得"),a("code",[e._v("this")]),e._v("固定指向某个对象，减少不确定性。")]),e._v(" "),a("h3",{attrs:{id:"绑定-this-的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定-this-的方法"}},[e._v("#")]),e._v(" 绑定 this 的方法")]),e._v(" "),a("p",[a("code",[e._v("this")]),e._v("的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把"),a("code",[e._v("this")]),e._v("固定下来，避免出现意想不到的情况。JavaScript 提供了"),a("code",[e._v("call")]),e._v("、"),a("code",[e._v("apply")]),e._v("、"),a("code",[e._v("bind")]),e._v("这三个方法，来切换/固定"),a("code",[e._v("this")]),e._v("的指向。")]),e._v(" "),a("h4",{attrs:{id:"function-prototype-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype-call"}},[e._v("#")]),e._v(" Function.prototype.call()")]),e._v(" "),a("p",[e._v("函数实例的"),a("code",[e._v("call")]),e._v("方法，可以指定函数内部"),a("code",[e._v("this")]),e._v("的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = {};\n\nvar f = function () {\n  return this;\n};\n\nf() === window // true\nf.call(obj) === obj // true\n")])])]),a("p",[e._v("上面代码中，全局环境运行函数"),a("code",[e._v("f")]),e._v("时，"),a("code",[e._v("this")]),e._v("指向全局环境（浏览器为"),a("code",[e._v("window")]),e._v("对象）；"),a("code",[e._v("call")]),e._v("方法可以改变"),a("code",[e._v("this")]),e._v("的指向，指定"),a("code",[e._v("this")]),e._v("指向对象"),a("code",[e._v("obj")]),e._v("，然后在对象"),a("code",[e._v("obj")]),e._v("的作用域中运行函数"),a("code",[e._v("f")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("call")]),e._v("方法的参数，应该是一个对象。如果参数为空、"),a("code",[e._v("null")]),e._v("和"),a("code",[e._v("undefined")]),e._v("，则默认传入全局对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var n = 123;\nvar obj = { n: 456 };\n\nfunction a() {\n  console.log(this.n);\n}\n\na.call() // 123\na.call(null) // 123\na.call(undefined) // 123\na.call(window) // 123\na.call(obj) // 456\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("a")]),e._v("函数中的"),a("code",[e._v("this")]),e._v("关键字，如果指向全局对象，返回结果为"),a("code",[e._v("123")]),e._v("。如果使用"),a("code",[e._v("call")]),e._v("方法将"),a("code",[e._v("this")]),e._v("关键字指向"),a("code",[e._v("obj")]),e._v("对象，返回结果为"),a("code",[e._v("456")]),e._v("。可以看到，如果"),a("code",[e._v("call")]),e._v("方法没有参数，或者参数为"),a("code",[e._v("null")]),e._v("或"),a("code",[e._v("undefined")]),e._v("，则等同于指向全局对象。")]),e._v(" "),a("p",[e._v("如果"),a("code",[e._v("call")]),e._v("方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入"),a("code",[e._v("call")]),e._v("方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var f = function () {\n  return this;\n};\n\nf.call(5)\n// Number {[[PrimitiveValue]]: 5}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("call")]),e._v("的参数为"),a("code",[e._v("5")]),e._v("，不是对象，会被自动转成包装对象（"),a("code",[e._v("Number")]),e._v("的实例），绑定"),a("code",[e._v("f")]),e._v("内部的"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("call")]),e._v("方法还可以接受多个参数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func.call(thisValue, arg1, arg2, ...)\n")])])]),a("p",[a("code",[e._v("call")]),e._v("的第一个参数就是"),a("code",[e._v("this")]),e._v("所要指向的那个对象，后面的参数则是函数调用时所需的参数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function add(a, b) {\n  return a + b;\n}\n\nadd.call(this, 1, 2) // 3\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("call")]),e._v("方法指定函数"),a("code",[e._v("add")]),e._v("内部的"),a("code",[e._v("this")]),e._v("绑定当前环境（对象），并且参数为"),a("code",[e._v("1")]),e._v("和"),a("code",[e._v("2")]),e._v("，因此函数"),a("code",[e._v("add")]),e._v("运行后得到"),a("code",[e._v("3")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("call")]),e._v("方法的一个应用是调用对象的原生方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = {};\nobj.hasOwnProperty('toString') // false\n\n// 覆盖掉继承的 hasOwnProperty 方法\nobj.hasOwnProperty = function () {\n  return true;\n};\nobj.hasOwnProperty('toString') // true\n\nObject.prototype.hasOwnProperty.call(obj, 'toString') // false\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("hasOwnProperty")]),e._v("是"),a("code",[e._v("obj")]),e._v("对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。"),a("code",[e._v("call")]),e._v("方法可以解决这个问题，它将"),a("code",[e._v("hasOwnProperty")]),e._v("方法的原始定义放到"),a("code",[e._v("obj")]),e._v("对象上执行，这样无论"),a("code",[e._v("obj")]),e._v("上有没有同名方法，都不会影响结果。")]),e._v(" "),a("h4",{attrs:{id:"function-prototype-apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype-apply"}},[e._v("#")]),e._v(" Function.prototype.apply()")]),e._v(" "),a("p",[a("code",[e._v("apply")]),e._v("方法的作用与"),a("code",[e._v("call")]),e._v("方法类似，也是改变"),a("code",[e._v("this")]),e._v("指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func.apply(thisValue, [arg1, arg2, ...])\n")])])]),a("p",[a("code",[e._v("apply")]),e._v("方法的第一个参数也是"),a("code",[e._v("this")]),e._v("所要指向的那个对象，如果设为"),a("code",[e._v("null")]),e._v("或"),a("code",[e._v("undefined")]),e._v("，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在"),a("code",[e._v("call")]),e._v("方法中必须一个个添加，但是在"),a("code",[e._v("apply")]),e._v("方法中，必须以数组形式添加。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f(x, y){\n  console.log(x + y);\n}\n\nf.call(null, 1, 1) // 2\nf.apply(null, [1, 1]) // 2\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("f")]),e._v("函数本来接受两个参数，使用"),a("code",[e._v("apply")]),e._v("方法以后，就变成可以接受一个数组作为参数。")]),e._v(" "),a("p",[e._v("利用这一点，可以做一些有趣的应用。")]),e._v(" "),a("p",[a("strong",[e._v("（1）找出数组最大元素")])]),e._v(" "),a("p",[e._v("JavaScript 不提供找出数组最大元素的函数。结合使用"),a("code",[e._v("apply")]),e._v("方法和"),a("code",[e._v("Math.max")]),e._v("方法，就可以返回数组的最大元素。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = [10, 2, 4, 15, 9];\nMath.max.apply(null, a) // 15\n")])])]),a("p",[a("strong",[e._v("（2）将数组的空元素变为"),a("code",[e._v("undefined")])])]),e._v(" "),a("p",[e._v("通过"),a("code",[e._v("apply")]),e._v("方法，利用"),a("code",[e._v("Array")]),e._v("构造函数将数组的空元素变成"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Array.apply(null, ['a', ,'b'])\n// [ 'a', undefined, 'b' ]\n")])])]),a("p",[e._v("空元素与"),a("code",[e._v("undefined")]),e._v("的差别在于，数组的"),a("code",[e._v("forEach")]),e._v("方法会跳过空元素，但是不会跳过"),a("code",[e._v("undefined")]),e._v("。因此，遍历内部元素的时候，会得到不同的结果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = ['a', , 'b'];\n\nfunction print(i) {\n  console.log(i);\n}\n\na.forEach(print)\n// a\n// b\n\nArray.apply(null, a).forEach(print)\n// a\n// undefined\n// b\n")])])]),a("p",[a("strong",[e._v("（3）转换类似数组的对象")])]),e._v(" "),a("p",[e._v("另外，利用数组对象的"),a("code",[e._v("slice")]),e._v("方法，可以将一个类似数组的对象（比如"),a("code",[e._v("arguments")]),e._v("对象）转为真正的数组。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Array.prototype.slice.apply({0: 1, length: 1}) // [1]\nArray.prototype.slice.apply({0: 1}) // []\nArray.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]\nArray.prototype.slice.apply({length: 1}) // [undefined]\n")])])]),a("p",[e._v("上面代码的"),a("code",[e._v("apply")]),e._v("方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有"),a("code",[e._v("length")]),e._v("属性，以及相对应的数字键。")]),e._v(" "),a("p",[a("strong",[e._v("（4）绑定回调函数的对象")])]),e._v(" "),a("p",[e._v("前面的按钮点击事件的例子，可以改写如下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = new Object();\n\no.f = function () {\n  console.log(this === o);\n}\n\nvar f = function (){\n  o.f.apply(o);\n  // 或者 o.f.call(o);\n};\n\n// jQuery 的写法\n$('#button').on('click', f);\n")])])]),a("p",[e._v("上面代码中，点击按钮以后，控制台将会显示"),a("code",[e._v("true")]),e._v("。由于"),a("code",[e._v("apply()")]),e._v("方法（或者"),a("code",[e._v("call()")]),e._v("方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的"),a("code",[e._v("bind()")]),e._v("方法。")]),e._v(" "),a("h4",{attrs:{id:"function-prototype-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype-bind"}},[e._v("#")]),e._v(" Function.prototype.bind()")]),e._v(" "),a("p",[a("code",[e._v("bind()")]),e._v("方法用于将函数体内的"),a("code",[e._v("this")]),e._v("绑定到某个对象，然后返回一个新函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var d = new Date();\nd.getTime() // 1481869925657\n\nvar print = d.getTime;\nprint() // Uncaught TypeError: this is not a Date object.\n")])])]),a("p",[e._v("上面代码中，我们将"),a("code",[e._v("d.getTime()")]),e._v("方法赋给变量"),a("code",[e._v("print")]),e._v("，然后调用"),a("code",[e._v("print()")]),e._v("就报错了。这是因为"),a("code",[e._v("getTime()")]),e._v("方法内部的"),a("code",[e._v("this")]),e._v("，绑定"),a("code",[e._v("Date")]),e._v("对象的实例，赋给变量"),a("code",[e._v("print")]),e._v("以后，内部的"),a("code",[e._v("this")]),e._v("已经不指向"),a("code",[e._v("Date")]),e._v("对象的实例了。")]),e._v(" "),a("p",[a("code",[e._v("bind()")]),e._v("方法可以解决这个问题。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var print = d.getTime.bind(d);\nprint() // 1481869925657\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("bind()")]),e._v("方法将"),a("code",[e._v("getTime()")]),e._v("方法内部的"),a("code",[e._v("this")]),e._v("绑定到"),a("code",[e._v("d")]),e._v("对象，这时就可以安全地将这个方法赋值给其他变量了。")]),e._v(" "),a("p",[a("code",[e._v("bind")]),e._v("方法的参数就是所要绑定"),a("code",[e._v("this")]),e._v("的对象，下面是一个更清晰的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var counter = {\n  count: 0,\n  inc: function () {\n    this.count++;\n  }\n};\n\nvar func = counter.inc.bind(counter);\nfunc();\ncounter.count // 1\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("counter.inc()")]),e._v("方法被赋值给变量"),a("code",[e._v("func")]),e._v("。这时必须用"),a("code",[e._v("bind()")]),e._v("方法将"),a("code",[e._v("inc()")]),e._v("内部的"),a("code",[e._v("this")]),e._v("，绑定到"),a("code",[e._v("counter")]),e._v("，否则就会出错。")]),e._v(" "),a("p",[a("code",[e._v("this")]),e._v("绑定到其他对象也是可以的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var counter = {\n  count: 0,\n  inc: function () {\n    this.count++;\n  }\n};\n\nvar obj = {\n  count: 100\n};\nvar func = counter.inc.bind(obj);\nfunc();\nobj.count // 101\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("bind()")]),e._v("方法将"),a("code",[e._v("inc()")]),e._v("方法内部的"),a("code",[e._v("this")]),e._v("，绑定到"),a("code",[e._v("obj")]),e._v("对象。结果调用"),a("code",[e._v("func")]),e._v("函数以后，递增的就是"),a("code",[e._v("obj")]),e._v("内部的"),a("code",[e._v("count")]),e._v("属性。")]),e._v(" "),a("p",[a("code",[e._v("bind()")]),e._v("还可以接受更多的参数，将这些参数绑定原函数的参数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var add = function (x, y) {\n  return x * this.m + y * this.n;\n}\n\nvar obj = {\n  m: 2,\n  n: 2\n};\n\nvar newAdd = add.bind(obj, 5);\nnewAdd(5) // 20\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("bind()")]),e._v("方法除了绑定"),a("code",[e._v("this")]),e._v("对象，还将"),a("code",[e._v("add()")]),e._v("函数的第一个参数"),a("code",[e._v("x")]),e._v("绑定成"),a("code",[e._v("5")]),e._v("，然后返回一个新函数"),a("code",[e._v("newAdd()")]),e._v("，这个函数只要再接受一个参数"),a("code",[e._v("y")]),e._v("就能运行了。")]),e._v(" "),a("p",[e._v("如果"),a("code",[e._v("bind()")]),e._v("方法的第一个参数是"),a("code",[e._v("null")]),e._v("或"),a("code",[e._v("undefined")]),e._v("，等于将"),a("code",[e._v("this")]),e._v("绑定到全局对象，函数运行时"),a("code",[e._v("this")]),e._v("指向顶层对象（浏览器为"),a("code",[e._v("window")]),e._v("）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function add(x, y) {\n  return x + y;\n}\n\nvar plus5 = add.bind(null, 5);\nplus5(10) // 15\n")])])]),a("p",[e._v("上面代码中，函数"),a("code",[e._v("add()")]),e._v("内部并没有"),a("code",[e._v("this")]),e._v("，使用"),a("code",[e._v("bind()")]),e._v("方法的主要目的是绑定参数"),a("code",[e._v("x")]),e._v("，以后每次运行新函数"),a("code",[e._v("plus5()")]),e._v("，就只需要提供另一个参数"),a("code",[e._v("y")]),e._v("就够了。而且因为"),a("code",[e._v("add()")]),e._v("内部没有"),a("code",[e._v("this")]),e._v("，所以"),a("code",[e._v("bind()")]),e._v("的第一个参数是"),a("code",[e._v("null")]),e._v("，不过这里如果是其他对象，也没有影响。")]),e._v(" "),a("p",[a("code",[e._v("bind()")]),e._v("方法有一些使用注意点。")]),e._v(" "),a("p",[a("strong",[e._v("（1）每一次返回一个新函数")])]),e._v(" "),a("p",[a("code",[e._v("bind()")]),e._v("方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("element.addEventListener('click', o.m.bind(o));\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("click")]),e._v("事件绑定"),a("code",[e._v("bind()")]),e._v("方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("element.removeEventListener('click', o.m.bind(o));\n")])])]),a("p",[e._v("正确的方法是写成下面这样：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var listener = o.m.bind(o);\nelement.addEventListener('click', listener);\n//  ...\nelement.removeEventListener('click', listener);\n")])])]),a("p",[a("strong",[e._v("（2）结合回调函数使用")])]),e._v(" "),a("p",[e._v("回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含"),a("code",[e._v("this")]),e._v("的方法直接当作回调函数。解决方法就是使用"),a("code",[e._v("bind()")]),e._v("方法，将"),a("code",[e._v("counter.inc()")]),e._v("绑定"),a("code",[e._v("counter")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var counter = {\n  count: 0,\n  inc: function () {\n    'use strict';\n    this.count++;\n  }\n};\n\nfunction callIt(callback) {\n  callback();\n}\n\ncallIt(counter.inc.bind(counter));\ncounter.count // 1\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("callIt()")]),e._v("方法会调用回调函数。这时如果直接把"),a("code",[e._v("counter.inc")]),e._v("传入，调用时"),a("code",[e._v("counter.inc()")]),e._v("内部的"),a("code",[e._v("this")]),e._v("就会指向全局对象。使用"),a("code",[e._v("bind()")]),e._v("方法将"),a("code",[e._v("counter.inc")]),e._v("绑定"),a("code",[e._v("counter")]),e._v("以后，就不会有这个问题，"),a("code",[e._v("this")]),e._v("总是指向"),a("code",[e._v("counter")]),e._v("。")]),e._v(" "),a("p",[e._v("还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的"),a("code",[e._v("this")]),e._v("指向，很可能也会出错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = {\n  name: '张三',\n  times: [1, 2, 3],\n  print: function () {\n    this.times.forEach(function (n) {\n      console.log(this.name);\n    });\n  }\n};\n\nobj.print()\n// 没有任何输出\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj.print")]),e._v("内部"),a("code",[e._v("this.times")]),e._v("的"),a("code",[e._v("this")]),e._v("是指向"),a("code",[e._v("obj")]),e._v("的，这个没有问题。但是，"),a("code",[e._v("forEach()")]),e._v("方法的回调函数内部的"),a("code",[e._v("this.name")]),e._v("却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("obj.print = function () {\n  this.times.forEach(function (n) {\n    console.log(this === window);\n  });\n};\n\nobj.print()\n// true\n// true\n// true\n")])])]),a("p",[e._v("解决这个问题，也是通过"),a("code",[e._v("bind()")]),e._v("方法绑定"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("obj.print = function () {\n  this.times.forEach(function (n) {\n    console.log(this.name);\n  }.bind(this));\n};\n\nobj.print()\n// 张三\n// 张三\n// 张三\n")])])]),a("p",[a("strong",[e._v("（3）结合"),a("code",[e._v("call()")]),e._v("方法使用")])]),e._v(" "),a("p",[e._v("利用"),a("code",[e._v("bind()")]),e._v("方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的"),a("code",[e._v("slice()")]),e._v("方法为例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[1, 2, 3].slice(0, 1) // [1]\n// 等同于\nArray.prototype.slice.call([1, 2, 3], 0, 1) // [1]\n")])])]),a("p",[e._v("上面的代码中，数组的"),a("code",[e._v("slice")]),e._v("方法从"),a("code",[e._v("[1, 2, 3]")]),e._v("里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在"),a("code",[e._v("[1, 2, 3]")]),e._v("上面调用"),a("code",[e._v("Array.prototype.slice()")]),e._v("方法，因此可以用"),a("code",[e._v("call")]),e._v("方法表达这个过程，得到同样的结果。")]),e._v(" "),a("p",[a("code",[e._v("call()")]),e._v("方法实质上是调用"),a("code",[e._v("Function.prototype.call()")]),e._v("方法，因此上面的表达式可以用"),a("code",[e._v("bind()")]),e._v("方法改写。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var slice = Function.prototype.call.bind(Array.prototype.slice);\nslice([1, 2, 3], 0, 1) // [1]\n")])])]),a("p",[e._v("上面代码的含义就是，将"),a("code",[e._v("Array.prototype.slice")]),e._v("变成"),a("code",[e._v("Function.prototype.call")]),e._v("方法所在的对象，调用时就变成了"),a("code",[e._v("Array.prototype.slice.call")]),e._v("。类似的写法还可以用于其他数组方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var push = Function.prototype.call.bind(Array.prototype.push);\nvar pop = Function.prototype.call.bind(Array.prototype.pop);\n\nvar a = [1 ,2 ,3];\npush(a, 4)\na // [1, 2, 3, 4]\n\npop(a)\na // [1, 2, 3]\n")])])]),a("p",[e._v("如果再进一步，将"),a("code",[e._v("Function.prototype.call")]),e._v("方法绑定到"),a("code",[e._v("Function.prototype.bind")]),e._v("对象，就意味着"),a("code",[e._v("bind")]),e._v("的调用形式也可以被改写。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  console.log(this.v);\n}\n\nvar o = { v: 123 };\nvar bind = Function.prototype.call.bind(Function.prototype.bind);\nbind(f, o)() // 123\n")])])]),a("p",[e._v("上面代码的含义就是，将"),a("code",[e._v("Function.prototype.bind")]),e._v("方法绑定在"),a("code",[e._v("Function.prototype.call")]),e._v("上面，所以"),a("code",[e._v("bind")]),e._v("方法就可以直接使用，不需要在函数实例上使用。")]),e._v(" "),a("h3",{attrs:{id:"参考链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ul",[a("li",[e._v("Jonathan Creamer, "),a("a",{attrs:{href:"http://tech.pro/tutorial/1192/avoiding-the-this-problem-in-javascript",target:"_blank",rel:"noopener noreferrer"}},[e._v('Avoiding the "this" problem in JavaScript'),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Erik Kronberg, "),a("a",{attrs:{href:"https://variadic.me/posts/2013-10-22-bind-call-and-apply-in-javascript.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bind, Call and Apply in JavaScript"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Axel Rauschmayer, "),a("a",{attrs:{href:"http://www.2ality.com/2014/05/this.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript’s this: how it works, where it can trip you up"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"对象的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的继承"}},[e._v("#")]),e._v(" 对象的继承")]),e._v(" "),a("p",[e._v("面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。")]),e._v(" "),a("p",[e._v("大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。")]),e._v(" "),a("p",[e._v("ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍，请参阅《ES6 标准入门》一书的相关章节。")]),e._v(" "),a("h3",{attrs:{id:"原型对象概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型对象概述"}},[e._v("#")]),e._v(" 原型对象概述")]),e._v(" "),a("h5",{attrs:{id:"构造函数的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的缺点"}},[e._v("#")]),e._v(" 构造函数的缺点")]),e._v(" "),a("p",[e._v("JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Cat (name, color) {\n  this.name = name;\n  this.color = color;\n}\n\nvar cat1 = new Cat('大毛', '白色');\n\ncat1.name // '大毛'\ncat1.color // '白色'\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Cat")]),e._v("函数是一个构造函数，函数内部定义了"),a("code",[e._v("name")]),e._v("属性和"),a("code",[e._v("color")]),e._v("属性，所有实例对象（上例是"),a("code",[e._v("cat1")]),e._v("）都会生成这两个属性，即这两个属性会定义在实例对象上面。")]),e._v(" "),a("p",[e._v("通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Cat(name, color) {\n  this.name = name;\n  this.color = color;\n  this.meow = function () {\n    console.log('喵喵');\n  };\n}\n\nvar cat1 = new Cat('大毛', '白色');\nvar cat2 = new Cat('二毛', '黑色');\n\ncat1.meow === cat2.meow\n// false\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("cat1")]),e._v("和"),a("code",[e._v("cat2")]),e._v("是同一个构造函数的两个实例，它们都具有"),a("code",[e._v("meow")]),e._v("方法。由于"),a("code",[e._v("meow")]),e._v("方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个"),a("code",[e._v("meow")]),e._v("方法。这既没有必要，又浪费系统资源，因为所有"),a("code",[e._v("meow")]),e._v("方法都是同样的行为，完全应该共享。")]),e._v(" "),a("p",[e._v("这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。")]),e._v(" "),a("h4",{attrs:{id:"prototype-属性的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype-属性的作用"}},[e._v("#")]),e._v(" prototype 属性的作用")]),e._v(" "),a("p",[e._v("JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。")]),e._v(" "),a("p",[e._v("下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个"),a("code",[e._v("prototype")]),e._v("属性，指向一个对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function f() {}\ntypeof f.prototype // "object"\n')])])]),a("p",[e._v("上面代码中，函数"),a("code",[e._v("f")]),e._v("默认具有"),a("code",[e._v("prototype")]),e._v("属性，指向一个对象。")]),e._v(" "),a("p",[e._v("对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.color = 'white';\n\nvar cat1 = new Animal('大毛');\nvar cat2 = new Animal('二毛');\n\ncat1.color // 'white'\ncat2.color // 'white'\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("Animal")]),e._v("的"),a("code",[e._v("prototype")]),e._v("属性，就是实例对象"),a("code",[e._v("cat1")]),e._v("和"),a("code",[e._v("cat2")]),e._v("的原型对象。原型对象上添加一个"),a("code",[e._v("color")]),e._v("属性，结果，实例对象都共享了该属性。")]),e._v(" "),a("p",[e._v("原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在"),a("strong",[e._v("所有")]),e._v("实例对象上。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Animal.prototype.color = \'yellow\';\n\ncat1.color // "yellow"\ncat2.color // "yellow"\n')])])]),a("p",[e._v("上面代码中，原型对象的"),a("code",[e._v("color")]),e._v("属性的值变为"),a("code",[e._v("yellow")]),e._v("，两个实例对象的"),a("code",[e._v("color")]),e._v("属性立刻跟着变了。这是因为实例对象其实没有"),a("code",[e._v("color")]),e._v("属性，都是读取原型对象的"),a("code",[e._v("color")]),e._v("属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。")]),e._v(" "),a("p",[e._v("如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("cat1.color = 'black';\n\ncat1.color // 'black'\ncat2.color // 'yellow'\nAnimal.prototype.color // 'yellow';\n")])])]),a("p",[e._v("上面代码中，实例对象"),a("code",[e._v("cat1")]),e._v("的"),a("code",[e._v("color")]),e._v("属性改为"),a("code",[e._v("black")]),e._v("，就使得它不再去原型对象读取"),a("code",[e._v("color")]),e._v("属性，后者的值依然为"),a("code",[e._v("yellow")]),e._v("。")]),e._v(" "),a("p",[e._v("总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Animal.prototype.walk = function () {\n  console.log(this.name + ' is walking');\n};\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Animal.prototype")]),e._v("对象上面定义了一个"),a("code",[e._v("walk")]),e._v("方法，这个方法将可以在所有"),a("code",[e._v("Animal")]),e._v("实例对象上面调用。")]),e._v(" "),a("h4",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[e._v("#")]),e._v(" 原型链")]),e._v(" "),a("p",[e._v("JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……")]),e._v(" "),a("p",[e._v("如果一层层地上溯，所有对象的原型最终都可以上溯到"),a("code",[e._v("Object.prototype")]),e._v("，即"),a("code",[e._v("Object")]),e._v("构造函数的"),a("code",[e._v("prototype")]),e._v("属性。也就是说，所有对象都继承了"),a("code",[e._v("Object.prototype")]),e._v("的属性。这就是所有对象都有"),a("code",[e._v("valueOf")]),e._v("和"),a("code",[e._v("toString")]),e._v("方法的原因，因为这是从"),a("code",[e._v("Object.prototype")]),e._v("继承的。")]),e._v(" "),a("p",[e._v("那么，"),a("code",[e._v("Object.prototype")]),e._v("对象有没有它的原型呢？回答是"),a("code",[e._v("Object.prototype")]),e._v("的原型是"),a("code",[e._v("null")]),e._v("。"),a("code",[e._v("null")]),e._v("没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是"),a("code",[e._v("null")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.getPrototypeOf(Object.prototype)\n// null\n")])])]),a("p",[e._v("上面代码表示，"),a("code",[e._v("Object.prototype")]),e._v("对象的原型是"),a("code",[e._v("null")]),e._v("，由于"),a("code",[e._v("null")]),e._v("没有任何属性，所以原型链到此为止。"),a("code",[e._v("Object.getPrototypeOf")]),e._v("方法返回参数对象的原型，具体介绍请看后文。")]),e._v(" "),a("p",[e._v("读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的"),a("code",[e._v("Object.prototype")]),e._v("还是找不到，则返回"),a("code",[e._v("undefined")]),e._v("。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。")]),e._v(" "),a("p",[e._v("注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。")]),e._v(" "),a("p",[e._v("举例来说，如果让构造函数的"),a("code",[e._v("prototype")]),e._v("属性指向一个数组，就意味着实例对象可以调用数组方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var MyArray = function () {};\n\nMyArray.prototype = new Array();\nMyArray.prototype.constructor = MyArray;\n\nvar mine = new MyArray();\nmine.push(1, 2, 3);\nmine.length // 3\nmine instanceof Array // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("mine")]),e._v("是构造函数"),a("code",[e._v("MyArray")]),e._v("的实例对象，由于"),a("code",[e._v("MyArray.prototype")]),e._v("指向一个数组实例，使得"),a("code",[e._v("mine")]),e._v("可以调用数组方法（这些方法定义在数组实例的"),a("code",[e._v("prototype")]),e._v("对象上面）。最后那行"),a("code",[e._v("instanceof")]),e._v("表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明"),a("code",[e._v("mine")]),e._v("为"),a("code",[e._v("Array")]),e._v("的实例，"),a("code",[e._v("instanceof")]),e._v("运算符的详细解释详见后文。")]),e._v(" "),a("p",[e._v("上面代码还出现了原型对象的"),a("code",[e._v("constructor")]),e._v("属性，这个属性的含义下一节就来解释。")]),e._v(" "),a("h4",{attrs:{id:"constructor-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor-属性"}},[e._v("#")]),e._v(" constructor 属性")]),e._v(" "),a("p",[a("code",[e._v("prototype")]),e._v("对象有一个"),a("code",[e._v("constructor")]),e._v("属性，默认指向"),a("code",[e._v("prototype")]),e._v("对象所在的构造函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function P() {}\nP.prototype.constructor === P // true\n")])])]),a("p",[e._v("由于"),a("code",[e._v("constructor")]),e._v("属性定义在"),a("code",[e._v("prototype")]),e._v("对象上面，意味着可以被所有实例对象继承。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function P() {}\nvar p = new P();\n\np.constructor === P // true\np.constructor === P.prototype.constructor // true\np.hasOwnProperty('constructor') // false\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("p")]),e._v("是构造函数"),a("code",[e._v("P")]),e._v("的实例对象，但是"),a("code",[e._v("p")]),e._v("自身没有"),a("code",[e._v("constructor")]),e._v("属性，该属性其实是读取原型链上面的"),a("code",[e._v("P.prototype.constructor")]),e._v("属性。")]),e._v(" "),a("p",[a("code",[e._v("constructor")]),e._v("属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function F() {};\nvar f = new F();\n\nf.constructor === F // true\nf.constructor === RegExp // false\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("constructor")]),e._v("属性确定了实例对象"),a("code",[e._v("f")]),e._v("的构造函数是"),a("code",[e._v("F")]),e._v("，而不是"),a("code",[e._v("RegExp")]),e._v("。")]),e._v(" "),a("p",[e._v("另一方面，有了"),a("code",[e._v("constructor")]),e._v("属性，就可以从一个实例对象新建另一个实例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Constr() {}\nvar x = new Constr();\n\nvar y = new x.constructor();\ny instanceof Constr // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("x")]),e._v("是构造函数"),a("code",[e._v("Constr")]),e._v("的实例，可以从"),a("code",[e._v("x.constructor")]),e._v("间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Constr.prototype.createCopy = function () {\n  return new this.constructor();\n};\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("createCopy")]),e._v("方法调用构造函数，新建另一个实例。")]),e._v(" "),a("p",[a("code",[e._v("constructor")]),e._v("属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改"),a("code",[e._v("constructor")]),e._v("属性，防止引用的时候出错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.constructor === Person // true\n\nPerson.prototype = {\n  method: function () {}\n};\n\nPerson.prototype.constructor === Person // false\nPerson.prototype.constructor === Object // true\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("Person")]),e._v("的原型对象改掉了，但是没有修改"),a("code",[e._v("constructor")]),e._v("属性，导致这个属性不再指向"),a("code",[e._v("Person")]),e._v("。由于"),a("code",[e._v("Person")]),e._v("的新原型是一个普通对象，而普通对象的"),a("code",[e._v("constructor")]),e._v("属性指向"),a("code",[e._v("Object")]),e._v("构造函数，导致"),a("code",[e._v("Person.prototype.constructor")]),e._v("变成了"),a("code",[e._v("Object")]),e._v("。")]),e._v(" "),a("p",[e._v("所以，修改原型对象时，一般要同时修改"),a("code",[e._v("constructor")]),e._v("属性的指向。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 坏的写法\nC.prototype = {\n  method1: function (...) { ... },\n  // ...\n};\n\n// 好的写法\nC.prototype = {\n  constructor: C,\n  method1: function (...) { ... },\n  // ...\n};\n\n// 更好的写法\nC.prototype.method1 = function (...) { ... };\n")])])]),a("p",[e._v("上面代码中，要么将"),a("code",[e._v("constructor")]),e._v("属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证"),a("code",[e._v("instanceof")]),e._v("运算符不会失真。")]),e._v(" "),a("p",[e._v("如果不能确定"),a("code",[e._v("constructor")]),e._v("属性是什么函数，还有一个办法：通过"),a("code",[e._v("name")]),e._v("属性，从实例得到构造函数的名称。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function Foo() {}\nvar f = new Foo();\nf.constructor.name // "Foo"\n')])])]),a("h3",{attrs:{id:"instanceof-运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-运算符"}},[e._v("#")]),e._v(" instanceof 运算符")]),e._v(" "),a("p",[a("code",[e._v("instanceof")]),e._v("运算符返回一个布尔值，表示对象是否为某个构造函数的实例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var v = new Vehicle();\nv instanceof Vehicle // true\n")])])]),a("p",[e._v("上面代码中，对象"),a("code",[e._v("v")]),e._v("是构造函数"),a("code",[e._v("Vehicle")]),e._v("的实例，所以返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("instanceof")]),e._v("运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("v instanceof Vehicle\n// 等同于\nVehicle.prototype.isPrototypeOf(v)\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Vehicle")]),e._v("是对象"),a("code",[e._v("v")]),e._v("的构造函数，它的原型对象是"),a("code",[e._v("Vehicle.prototype")]),e._v("，"),a("code",[e._v("isPrototypeOf()")]),e._v("方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。")]),e._v(" "),a("p",[e._v("由于"),a("code",[e._v("instanceof")]),e._v("检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var d = new Date();\nd instanceof Date // true\nd instanceof Object // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("d")]),e._v("同时是"),a("code",[e._v("Date")]),e._v("和"),a("code",[e._v("Object")]),e._v("的实例，因此对这两个构造函数都返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("p",[e._v("由于任意对象（除了"),a("code",[e._v("null")]),e._v("）都是"),a("code",[e._v("Object")]),e._v("的实例，所以"),a("code",[e._v("instanceof")]),e._v("运算符可以判断一个值是否为非"),a("code",[e._v("null")]),e._v("的对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = { foo: 123 };\nobj instanceof Object // true\n\nnull instanceof Object // false\n")])])]),a("p",[e._v("上面代码中，除了"),a("code",[e._v("null")]),e._v("，其他对象的"),a("code",[e._v("instanceOf Object")]),e._v("的运算结果都是"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("instanceof")]),e._v("的原理是检查右边构造函数的"),a("code",[e._v("prototype")]),e._v("属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有"),a("code",[e._v("null")]),e._v("对象。这时，"),a("code",[e._v("instanceof")]),e._v("判断会失真。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var obj = Object.create(null);\ntypeof obj // "object"\nobj instanceof Object // false\n')])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Object.create(null)")]),e._v("返回一个新对象"),a("code",[e._v("obj")]),e._v("，它的原型是"),a("code",[e._v("null")]),e._v("（"),a("code",[e._v("Object.create()")]),e._v("的详细介绍见后文）。右边的构造函数"),a("code",[e._v("Object")]),e._v("的"),a("code",[e._v("prototype")]),e._v("属性，不在左边的原型链上，因此"),a("code",[e._v("instanceof")]),e._v("就认为"),a("code",[e._v("obj")]),e._v("不是"),a("code",[e._v("Object")]),e._v("的实例。这是唯一的"),a("code",[e._v("instanceof")]),e._v("运算符判断会失真的情况（一个对象的原型是"),a("code",[e._v("null")]),e._v("）。")]),e._v(" "),a("p",[a("code",[e._v("instanceof")]),e._v("运算符的一个用处，是判断值的类型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var x = [1, 2, 3];\nvar y = {};\nx instanceof Array // true\ny instanceof Object // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("instanceof")]),e._v("运算符判断，变量"),a("code",[e._v("x")]),e._v("是数组，变量"),a("code",[e._v("y")]),e._v("是对象。")]),e._v(" "),a("p",[e._v("注意，"),a("code",[e._v("instanceof")]),e._v("运算符只能用于对象，不适用原始类型的值。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var s = 'hello';\ns instanceof String // false\n")])])]),a("p",[e._v("上面代码中，字符串不是"),a("code",[e._v("String")]),e._v("对象的实例（因为字符串不是对象），所以返回"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("p",[e._v("此外，对于"),a("code",[e._v("undefined")]),e._v("和"),a("code",[e._v("null")]),e._v("，"),a("code",[e._v("instanceof")]),e._v("运算符总是返回"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("undefined instanceof Object // false\nnull instanceof Object // false\n")])])]),a("p",[e._v("利用"),a("code",[e._v("instanceof")]),e._v("运算符，还可以巧妙地解决，调用构造函数时，忘了加"),a("code",[e._v("new")]),e._v("命令的问题。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Fubar (foo, bar) {\n  if (this instanceof Fubar) {\n    this._foo = foo;\n    this._bar = bar;\n  } else {\n    return new Fubar(foo, bar);\n  }\n}\n")])])]),a("p",[e._v("上面代码使用"),a("code",[e._v("instanceof")]),e._v("运算符，在函数体内部判断"),a("code",[e._v("this")]),e._v("关键字是否为构造函数"),a("code",[e._v("Fubar")]),e._v("的实例。如果不是，就表明忘了加"),a("code",[e._v("new")]),e._v("命令。")]),e._v(" "),a("h3",{attrs:{id:"构造函数的继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的继承"}},[e._v("#")]),e._v(" 构造函数的继承")]),e._v(" "),a("p",[e._v("让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Sub(value) {\n  Super.call(this);\n  this.prop = value;\n}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Sub")]),e._v("是子类的构造函数，"),a("code",[e._v("this")]),e._v("是子类的实例。在实例上调用父类的构造函数"),a("code",[e._v("Super")]),e._v("，就会让子类实例具有父类实例的属性。")]),e._v(" "),a("p",[e._v("第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Sub.prototype = Object.create(Super.prototype);\nSub.prototype.constructor = Sub;\nSub.prototype.method = '...';\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Sub.prototype")]),e._v("是子类的原型，要将它赋值为"),a("code",[e._v("Object.create(Super.prototype)")]),e._v("，而不是直接等于"),a("code",[e._v("Super.prototype")]),e._v("。否则后面两行对"),a("code",[e._v("Sub.prototype")]),e._v("的操作，会连父类的原型"),a("code",[e._v("Super.prototype")]),e._v("一起修改掉。")]),e._v(" "),a("p",[e._v("另外一种写法是"),a("code",[e._v("Sub.prototype")]),e._v("等于一个父类实例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Sub.prototype = new Super();\n")])])]),a("p",[e._v("上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。")]),e._v(" "),a("p",[e._v("举例来说，下面是一个"),a("code",[e._v("Shape")]),e._v("构造函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function (x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n")])])]),a("p",[e._v("我们需要让"),a("code",[e._v("Rectangle")]),e._v("构造函数继承"),a("code",[e._v("Shape")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 第一步，子类继承父类的实例\nfunction Rectangle() {\n  Shape.call(this); // 调用父类构造函数\n}\n// 另一种写法\nfunction Rectangle() {\n  this.base = Shape;\n  this.base();\n}\n\n// 第二步，子类继承父类的原型\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n")])])]),a("p",[e._v("采用这样的写法以后，"),a("code",[e._v("instanceof")]),e._v("运算符会对子类和父类的构造函数，都返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var rect = new Rectangle();\n\nrect instanceof Rectangle  // true\nrect instanceof Shape  // true\n")])])]),a("p",[e._v("上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ClassB.prototype.print = function() {\n  ClassA.prototype.print.call(this);\n  // some code\n}\n")])])]),a("p",[e._v("上面代码中，子类"),a("code",[e._v("B")]),e._v("的"),a("code",[e._v("print")]),e._v("方法先调用父类"),a("code",[e._v("A")]),e._v("的"),a("code",[e._v("print")]),e._v("方法，再部署自己的代码。这就等于继承了父类"),a("code",[e._v("A")]),e._v("的"),a("code",[e._v("print")]),e._v("方法。")]),e._v(" "),a("h3",{attrs:{id:"多重继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多重继承"}},[e._v("#")]),e._v(" 多重继承")]),e._v(" "),a("p",[e._v("JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function M1() {\n  this.hello = 'hello';\n}\n\nfunction M2() {\n  this.world = 'world';\n}\n\nfunction S() {\n  M1.call(this);\n  M2.call(this);\n}\n\n// 继承 M1\nS.prototype = Object.create(M1.prototype);\n// 继承链上加入 M2\nObject.assign(S.prototype, M2.prototype);\n\n// 指定构造函数\nS.prototype.constructor = S;\n\nvar s = new S();\ns.hello // 'hello'\ns.world // 'world'\n")])])]),a("p",[e._v("上面代码中，子类"),a("code",[e._v("S")]),e._v("同时继承了父类"),a("code",[e._v("M1")]),e._v("和"),a("code",[e._v("M2")]),e._v("。这种模式又称为 Mixin（混入）。")]),e._v(" "),a("h3",{attrs:{id:"模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[e._v("#")]),e._v(" 模块")]),e._v(" "),a("p",[e._v("随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。")]),e._v(" "),a("p",[e._v("JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。")]),e._v(" "),a("p",[e._v("但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。")]),e._v(" "),a("h4",{attrs:{id:"基本的实现方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本的实现方法"}},[e._v("#")]),e._v(" 基本的实现方法")]),e._v(" "),a("p",[e._v("模块是实现特定功能的一组属性和方法的封装。")]),e._v(" "),a("p",[e._v("简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var module1 = new Object({\n　_count : 0,\n　m1 : function (){\n　　//...\n　},\n　m2 : function (){\n  　//...\n　}\n});\n")])])]),a("p",[e._v("上面的函数"),a("code",[e._v("m1")]),e._v("和"),a("code",[e._v("m2")]),e._v("，都封装在"),a("code",[e._v("module1")]),e._v("对象里。使用的时候，就是调用这个对象的属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module1.m1();\n")])])]),a("p",[e._v("但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module1._count = 5;\n")])])]),a("h4",{attrs:{id:"封装私有变量-构造函数的写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装私有变量-构造函数的写法"}},[e._v("#")]),e._v(" 封装私有变量：构造函数的写法")]),e._v(" "),a("p",[e._v("我们可以利用构造函数，封装私有变量。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function StringBuilder() {\n  var buffer = [];\n\n  this.add = function (str) {\n     buffer.push(str);\n  };\n\n  this.toString = function () {\n    return buffer.join('');\n  };\n\n}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("buffer")]),e._v("是模块的私有变量。一旦生成实例对象，外部是无法直接访问"),a("code",[e._v("buffer")]),e._v("的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function StringBuilder() {\n  this._buffer = [];\n}\n\nStringBuilder.prototype = {\n  constructor: StringBuilder,\n  add: function (str) {\n    this._buffer.push(str);\n  },\n  toString: function () {\n    return this._buffer.join('');\n  }\n};\n")])])]),a("p",[e._v("这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。")]),e._v(" "),a("h4",{attrs:{id:"封装私有变量-立即执行函数的写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装私有变量-立即执行函数的写法"}},[e._v("#")]),e._v(" 封装私有变量：立即执行函数的写法")]),e._v(" "),a("p",[e._v("另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var module1 = (function () {\n　var _count = 0;\n　var m1 = function () {\n　  //...\n　};\n　var m2 = function () {\n　　//...\n　};\n　return {\n　　m1 : m1,\n　　m2 : m2\n　};\n})();\n")])])]),a("p",[e._v("使用上面的写法，外部代码无法读取内部的"),a("code",[e._v("_count")]),e._v("变量。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.info(module1._count); //undefined\n")])])]),a("p",[e._v("上面的"),a("code",[e._v("module1")]),e._v("就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。")]),e._v(" "),a("h4",{attrs:{id:"模块的放大模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块的放大模式"}},[e._v("#")]),e._v(" 模块的放大模式")]),e._v(" "),a("p",[e._v("如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var module1 = (function (mod){\n　mod.m3 = function () {\n　　//...\n　};\n　return mod;\n})(module1);\n")])])]),a("p",[e._v("上面的代码为"),a("code",[e._v("module1")]),e._v("模块添加了一个新方法"),a("code",[e._v("m3()")]),e._v("，然后返回新的"),a("code",[e._v("module1")]),e._v("模块。")]),e._v(" "),a("p",[e._v('在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"（Loose augmentation）。')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var module1 = (function (mod) {\n　//...\n　return mod;\n})(window.module1 || {});\n")])])]),a("p",[e._v('与"放大模式"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。')]),e._v(" "),a("h4",{attrs:{id:"输入全局变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入全局变量"}},[e._v("#")]),e._v(" 输入全局变量")]),e._v(" "),a("p",[e._v("独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。")]),e._v(" "),a("p",[e._v("为了在模块内部调用全局变量，必须显式地将其他变量输入模块。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var module1 = (function ($, YAHOO) {\n　//...\n})(jQuery, YAHOO);\n")])])]),a("p",[e._v("上面的"),a("code",[e._v("module1")]),e._v("模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入"),a("code",[e._v("module1")]),e._v("。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。")]),e._v(" "),a("p",[e._v("立即执行函数还可以起到命名空间的作用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(function($, window, document) {\n\n  function go(num) {\n  }\n\n  function handleEvents() {\n  }\n\n  function initialize() {\n  }\n\n  function dieCarouselDie() {\n  }\n\n  //attach to the global scope\n  window.finalCarousel = {\n    init : initialize,\n    destroy : dieCarouselDie\n  }\n\n})( jQuery, window, document );\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("finalCarousel")]),e._v("对象输出到全局，对外暴露"),a("code",[e._v("init")]),e._v("和"),a("code",[e._v("destroy")]),e._v("接口，内部方法"),a("code",[e._v("go")]),e._v("、"),a("code",[e._v("handleEvents")]),e._v("、"),a("code",[e._v("initialize")]),e._v("、"),a("code",[e._v("dieCarouselDie")]),e._v("都是外部无法调用的。")]),e._v(" "),a("h3",{attrs:{id:"参考链接-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-2"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Modules: A Beginner’s Guide"),a("OutboundLink")],1),e._v(", by Preethi Kasireddy")])]),e._v(" "),a("h2",{attrs:{id:"object-对象的相关方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-对象的相关方法"}},[e._v("#")]),e._v(" Object 对象的相关方法")]),e._v(" "),a("p",[e._v("JavaScript 在"),a("code",[e._v("Object")]),e._v("对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法。")]),e._v(" "),a("h3",{attrs:{id:"object-getprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-getprototypeof"}},[e._v("#")]),e._v(" Object.getPrototypeOf()")]),e._v(" "),a("p",[a("code",[e._v("Object.getPrototypeOf")]),e._v("方法返回参数对象的原型。这是获取原型对象的标准方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var F = function () {};\nvar f = new F();\nObject.getPrototypeOf(f) === F.prototype // true\n")])])]),a("p",[e._v("上面代码中，实例对象"),a("code",[e._v("f")]),e._v("的原型是"),a("code",[e._v("F.prototype")]),e._v("。")]),e._v(" "),a("p",[e._v("下面是几种特殊对象的原型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 空对象的原型是 Object.prototype\nObject.getPrototypeOf({}) === Object.prototype // true\n\n// Object.prototype 的原型是 null\nObject.getPrototypeOf(Object.prototype) === null // true\n\n// 函数的原型是 Function.prototype\nfunction f() {}\nObject.getPrototypeOf(f) === Function.prototype // true\n")])])]),a("h3",{attrs:{id:"object-setprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-setprototypeof"}},[e._v("#")]),e._v(" Object.setPrototypeOf()")]),e._v(" "),a("p",[a("code",[e._v("Object.setPrototypeOf")]),e._v("方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = {};\nvar b = {x: 1};\nObject.setPrototypeOf(a, b);\n\nObject.getPrototypeOf(a) === b // true\na.x // 1\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Object.setPrototypeOf")]),e._v("方法将对象"),a("code",[e._v("a")]),e._v("的原型，设置为对象"),a("code",[e._v("b")]),e._v("，因此"),a("code",[e._v("a")]),e._v("可以共享"),a("code",[e._v("b")]),e._v("的属性。")]),e._v(" "),a("p",[a("code",[e._v("new")]),e._v("命令可以使用"),a("code",[e._v("Object.setPrototypeOf")]),e._v("方法模拟。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var F = function () {\n  this.foo = 'bar';\n};\n\nvar f = new F();\n// 等同于\nvar f = Object.setPrototypeOf({}, F.prototype);\nF.call(f);\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("new")]),e._v("命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的"),a("code",[e._v("prototype")]),e._v("属性（上例是"),a("code",[e._v("F.prototype")]),e._v("）；第二步，将构造函数内部的"),a("code",[e._v("this")]),e._v("绑定这个空对象，然后执行构造函数，使得定义在"),a("code",[e._v("this")]),e._v("上面的方法和属性（上例是"),a("code",[e._v("this.foo")]),e._v("），都转移到这个空对象上。")]),e._v(" "),a("h3",{attrs:{id:"object-create"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create"}},[e._v("#")]),e._v(" Object.create()")]),e._v(" "),a("p",[e._v("生成实例对象的常用方法是，使用"),a("code",[e._v("new")]),e._v("命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？")]),e._v(" "),a("p",[e._v("JavaScript 提供了"),a("code",[e._v("Object.create()")]),e._v("方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 原型对象\nvar A = {\n  print: function () {\n    console.log('hello');\n  }\n};\n\n// 实例对象\nvar B = Object.create(A);\n\nObject.getPrototypeOf(B) === A // true\nB.print() // hello\nB.print === A.print // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Object.create()")]),e._v("方法以"),a("code",[e._v("A")]),e._v("对象为原型，生成了"),a("code",[e._v("B")]),e._v("对象。"),a("code",[e._v("B")]),e._v("继承了"),a("code",[e._v("A")]),e._v("的所有属性和方法。")]),e._v(" "),a("p",[e._v("实际上，"),a("code",[e._v("Object.create()")]),e._v("方法可以用下面的代码代替。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (typeof Object.create !== 'function') {\n  Object.create = function (obj) {\n    function F() {}\n    F.prototype = obj;\n    return new F();\n  };\n}\n")])])]),a("p",[e._v("上面代码表明，"),a("code",[e._v("Object.create()")]),e._v("方法的实质是新建一个空的构造函数"),a("code",[e._v("F")]),e._v("，然后让"),a("code",[e._v("F.prototype")]),e._v("属性指向参数对象"),a("code",[e._v("obj")]),e._v("，最后返回一个"),a("code",[e._v("F")]),e._v("的实例，从而实现让该实例继承"),a("code",[e._v("obj")]),e._v("的属性。")]),e._v(" "),a("p",[e._v("下面三种方式生成的新对象是等价的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj1 = Object.create({});\nvar obj2 = Object.create(Object.prototype);\nvar obj3 = new Object();\n")])])]),a("p",[e._v("如果想要生成一个不继承任何属性（比如没有"),a("code",[e._v("toString()")]),e._v("和"),a("code",[e._v("valueOf()")]),e._v("方法）的对象，可以将"),a("code",[e._v("Object.create()")]),e._v("的参数设为"),a("code",[e._v("null")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = Object.create(null);\n\nobj.valueOf()\n// TypeError: Object [object Object] has no method 'valueOf'\n")])])]),a("p",[e._v("上面代码中，对象"),a("code",[e._v("obj")]),e._v("的原型是"),a("code",[e._v("null")]),e._v("，它就不具备一些定义在"),a("code",[e._v("Object.prototype")]),e._v("对象上面的属性，比如"),a("code",[e._v("valueOf()")]),e._v("方法。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("Object.create()")]),e._v("方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.create()\n// TypeError: Object prototype may only be an Object or null\nObject.create(123)\n// TypeError: Object prototype may only be an Object or null\n")])])]),a("p",[a("code",[e._v("Object.create()")]),e._v("方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj1 = { p: 1 };\nvar obj2 = Object.create(obj1);\n\nobj1.p = 2;\nobj2.p // 2\n")])])]),a("p",[e._v("上面代码中，修改对象原型"),a("code",[e._v("obj1")]),e._v("会影响到实例对象"),a("code",[e._v("obj2")]),e._v("。")]),e._v(" "),a("p",[e._v("除了对象的原型，"),a("code",[e._v("Object.create()")]),e._v("方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = Object.create({}, {\n  p1: {\n    value: 123,\n    enumerable: true,\n    configurable: true,\n    writable: true,\n  },\n  p2: {\n    value: 'abc',\n    enumerable: true,\n    configurable: true,\n    writable: true,\n  }\n});\n\n// 等同于\nvar obj = Object.create({});\nobj.p1 = 123;\nobj.p2 = 'abc';\n")])])]),a("p",[a("code",[e._v("Object.create()")]),e._v("方法生成的对象，继承了它的原型对象的构造函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function A() {}\nvar a = new A();\nvar b = Object.create(a);\n\nb.constructor === A // true\nb instanceof A // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("b")]),e._v("对象的原型是"),a("code",[e._v("a")]),e._v("对象，因此继承了"),a("code",[e._v("a")]),e._v("对象的构造函数"),a("code",[e._v("A")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"object-prototype-isprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-isprototypeof"}},[e._v("#")]),e._v(" Object.prototype.isPrototypeOf()")]),e._v(" "),a("p",[e._v("实例对象的"),a("code",[e._v("isPrototypeOf")]),e._v("方法，用来判断该对象是否为参数对象的原型。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o1 = {};\nvar o2 = Object.create(o1);\nvar o3 = Object.create(o2);\n\no2.isPrototypeOf(o3) // true\no1.isPrototypeOf(o3) // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("o1")]),e._v("和"),a("code",[e._v("o2")]),e._v("都是"),a("code",[e._v("o3")]),e._v("的原型。这表明只要实例对象处在参数对象的原型链上，"),a("code",[e._v("isPrototypeOf")]),e._v("方法都返回"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.prototype.isPrototypeOf({}) // true\nObject.prototype.isPrototypeOf([]) // true\nObject.prototype.isPrototypeOf(/xyz/) // true\nObject.prototype.isPrototypeOf(Object.create(null)) // false\n")])])]),a("p",[e._v("上面代码中，由于"),a("code",[e._v("Object.prototype")]),e._v("处于原型链的最顶端，所以对各种实例都返回"),a("code",[e._v("true")]),e._v("，只有直接继承自"),a("code",[e._v("null")]),e._v("的对象除外。")]),e._v(" "),a("h3",{attrs:{id:"object-prototype-proto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-proto"}},[e._v("#")]),e._v(" Object.prototype."),a("strong",[e._v("proto")])]),e._v(" "),a("p",[e._v("实例对象的"),a("code",[e._v("__proto__")]),e._v("属性（前后各两个下划线），返回该对象的原型。该属性可读写。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = {};\nvar p = {};\n\nobj.__proto__ = p;\nObject.getPrototypeOf(obj) === p // true\n")])])]),a("p",[e._v("上面代码通过"),a("code",[e._v("__proto__")]),e._v("属性，将"),a("code",[e._v("p")]),e._v("对象设为"),a("code",[e._v("obj")]),e._v("对象的原型。")]),e._v(" "),a("p",[e._v("根据语言标准，"),a("code",[e._v("__proto__")]),e._v("属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用"),a("code",[e._v("Object.getPrototypeOf()")]),e._v("和"),a("code",[e._v("Object.setPrototypeOf()")]),e._v("，进行原型对象的读写操作。")]),e._v(" "),a("p",[e._v("原型链可以用"),a("code",[e._v("__proto__")]),e._v("很直观地表示。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var A = {\n  name: '张三'\n};\nvar B = {\n  name: '李四'\n};\n\nvar proto = {\n  print: function () {\n    console.log(this.name);\n  }\n};\n\nA.__proto__ = proto;\nB.__proto__ = proto;\n\nA.print() // 张三\nB.print() // 李四\n\nA.print === B.print // true\nA.print === proto.print // true\nB.print === proto.print // true\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("A")]),e._v("对象和"),a("code",[e._v("B")]),e._v("对象的原型都是"),a("code",[e._v("proto")]),e._v("对象，它们都共享"),a("code",[e._v("proto")]),e._v("对象的"),a("code",[e._v("print")]),e._v("方法。也就是说，"),a("code",[e._v("A")]),e._v("和"),a("code",[e._v("B")]),e._v("的"),a("code",[e._v("print")]),e._v("方法，都是在调用"),a("code",[e._v("proto")]),e._v("对象的"),a("code",[e._v("print")]),e._v("方法。")]),e._v(" "),a("h3",{attrs:{id:"获取原型对象方法的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取原型对象方法的比较"}},[e._v("#")]),e._v(" 获取原型对象方法的比较")]),e._v(" "),a("p",[e._v("如前所述，"),a("code",[e._v("__proto__")]),e._v("属性指向当前对象的原型对象，即构造函数的"),a("code",[e._v("prototype")]),e._v("属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var obj = new Object();\n\nobj.__proto__ === Object.prototype\n// true\nobj.__proto__ === obj.constructor.prototype\n// true\n")])])]),a("p",[e._v("上面代码首先新建了一个对象"),a("code",[e._v("obj")]),e._v("，它的"),a("code",[e._v("__proto__")]),e._v("属性，指向构造函数（"),a("code",[e._v("Object")]),e._v("或"),a("code",[e._v("obj.constructor")]),e._v("）的"),a("code",[e._v("prototype")]),e._v("属性。")]),e._v(" "),a("p",[e._v("因此，获取实例对象"),a("code",[e._v("obj")]),e._v("的原型对象，有三种方法。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("obj.__proto__")])]),e._v(" "),a("li",[a("code",[e._v("obj.constructor.prototype")])]),e._v(" "),a("li",[a("code",[e._v("Object.getPrototypeOf(obj)")])])]),e._v(" "),a("p",[e._v("上面三种方法之中，前两种都不是很可靠。"),a("code",[e._v("__proto__")]),e._v("属性只有浏览器才需要部署，其他环境可以不部署。而"),a("code",[e._v("obj.constructor.prototype")]),e._v("在手动改变原型对象时，可能会失效。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var P = function () {};\nvar p = new P();\n\nvar C = function () {};\nC.prototype = p;\nvar c = new C();\n\nc.constructor.prototype === p // false\n")])])]),a("p",[e._v("上面代码中，构造函数"),a("code",[e._v("C")]),e._v("的原型对象被改成了"),a("code",[e._v("p")]),e._v("，但是实例对象的"),a("code",[e._v("c.constructor.prototype")]),e._v("却没有指向"),a("code",[e._v("p")]),e._v("。所以，在改变原型对象时，一般要同时设置"),a("code",[e._v("constructor")]),e._v("属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("C.prototype = p;\nC.prototype.constructor = C;\n\nvar c = new C();\nc.constructor.prototype === p // true\n")])])]),a("p",[e._v("因此，推荐使用第三种"),a("code",[e._v("Object.getPrototypeOf")]),e._v("方法，获取原型对象。")]),e._v(" "),a("h3",{attrs:{id:"object-getownpropertynames"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-getownpropertynames"}},[e._v("#")]),e._v(" Object.getOwnPropertyNames()")]),e._v(" "),a("p",[a("code",[e._v("Object.getOwnPropertyNames")]),e._v("方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Object.getOwnPropertyNames(Date)\n// ["parse", "arguments", "UTC", "caller", "name", "prototype", "now", "length"]\n')])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Object.getOwnPropertyNames")]),e._v("方法返回"),a("code",[e._v("Date")]),e._v("所有自身的属性名。")]),e._v(" "),a("p",[e._v("对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。"),a("code",[e._v("Object.getOwnPropertyNames")]),e._v("方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用"),a("code",[e._v("Object.keys")]),e._v("方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.keys(Date) // []\n")])])]),a("p",[e._v("上面代码表明，"),a("code",[e._v("Date")]),e._v("对象所有自身的属性，都是不可以遍历的。")]),e._v(" "),a("h3",{attrs:{id:"object-prototype-hasownproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-hasownproperty"}},[e._v("#")]),e._v(" Object.prototype.hasOwnProperty()")]),e._v(" "),a("p",[e._v("对象实例的"),a("code",[e._v("hasOwnProperty")]),e._v("方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Date.hasOwnProperty('length') // true\nDate.hasOwnProperty('toString') // false\n")])])]),a("p",[e._v("上面代码表明，"),a("code",[e._v("Date.length")]),e._v("（构造函数"),a("code",[e._v("Date")]),e._v("可以接受多少个参数）是"),a("code",[e._v("Date")]),e._v("自身的属性，"),a("code",[e._v("Date.toString")]),e._v("是继承的属性。")]),e._v(" "),a("p",[e._v("另外，"),a("code",[e._v("hasOwnProperty")]),e._v("方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。")]),e._v(" "),a("h3",{attrs:{id:"in-运算符和-for-in-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#in-运算符和-for-in-循环"}},[e._v("#")]),e._v(" in 运算符和 for...in 循环")]),e._v(" "),a("p",[a("code",[e._v("in")]),e._v("运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'length' in Date // true\n'toString' in Date // true\n")])])]),a("p",[a("code",[e._v("in")]),e._v("运算符常用于检查一个属性是否存在。")]),e._v(" "),a("p",[e._v("获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用"),a("code",[e._v("for...in")]),e._v("循环。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var o1 = { p1: 123 };\n\nvar o2 = Object.create(o1, {\n  p2: { value: "abc", enumerable: true }\n});\n\nfor (p in o2) {\n  console.info(p);\n}\n// p2\n// p1\n')])])]),a("p",[e._v("上面代码中，对象"),a("code",[e._v("o2")]),e._v("的"),a("code",[e._v("p2")]),e._v("属性是自身的，"),a("code",[e._v("p1")]),e._v("属性是继承的。这两个属性都会被"),a("code",[e._v("for...in")]),e._v("循环遍历。")]),e._v(" "),a("p",[e._v("为了在"),a("code",[e._v("for...in")]),e._v("循环中获得对象自身的属性，可以采用"),a("code",[e._v("hasOwnProperty")]),e._v("方法判断一下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("for ( var name in object ) {\n  if ( object.hasOwnProperty(name) ) {\n    /* loop code */\n  }\n}\n")])])]),a("p",[e._v("获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function inheritedPropertyNames(obj) {\n  var props = {};\n  while(obj) {\n    Object.getOwnPropertyNames(obj).forEach(function(p) {\n      props[p] = true;\n    });\n    obj = Object.getPrototypeOf(obj);\n  }\n  return Object.getOwnPropertyNames(props);\n}\n")])])]),a("p",[e._v("上面代码依次获取"),a("code",[e._v("obj")]),e._v("对象的每一级原型对象“自身”的属性，从而获取"),a("code",[e._v("obj")]),e._v("对象的“所有”属性，不管是否可遍历。")]),e._v(" "),a("p",[e._v("下面是一个例子，列出"),a("code",[e._v("Date")]),e._v("对象的所有属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('inheritedPropertyNames(Date)\n// [\n//  "caller",\n//  "constructor",\n//  "toString",\n//  "UTC",\n//  ...\n// ]\n')])])]),a("h3",{attrs:{id:"对象的拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的拷贝"}},[e._v("#")]),e._v(" 对象的拷贝")]),e._v(" "),a("p",[e._v("如果要拷贝一个对象，需要做到下面两件事情。")]),e._v(" "),a("ul",[a("li",[e._v("确保拷贝后的对象，与原对象具有同样的原型。")]),e._v(" "),a("li",[e._v("确保拷贝后的对象，与原对象具有同样的实例属性。")])]),e._v(" "),a("p",[e._v("下面就是根据上面两点，实现的对象拷贝函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function copyObject(orig) {\n  var copy = Object.create(Object.getPrototypeOf(orig));\n  copyOwnPropertiesFrom(copy, orig);\n  return copy;\n}\n\nfunction copyOwnPropertiesFrom(target, source) {\n  Object\n    .getOwnPropertyNames(source)\n    .forEach(function (propKey) {\n      var desc = Object.getOwnPropertyDescriptor(source, propKey);\n      Object.defineProperty(target, propKey, desc);\n    });\n  return target;\n}\n")])])]),a("p",[e._v("另一种更简单的写法，是利用 ES2017 才引入标准的"),a("code",[e._v("Object.getOwnPropertyDescriptors")]),e._v("方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function copyObject(orig) {\n  return Object.create(\n    Object.getPrototypeOf(orig),\n    Object.getOwnPropertyDescriptors(orig)\n  );\n}\n")])])]),a("h3",{attrs:{id:"参考链接-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-3"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ul",[a("li",[e._v("Dr. Axel Rauschmayer, "),a("a",{attrs:{href:"http://www.2ality.com/2011/07/js-properties.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript properties: inheritance and enumerability"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"严格模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[e._v("#")]),e._v(" 严格模式")]),e._v(" "),a("p",[e._v("除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。")]),e._v(" "),a("p",[e._v("同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。")]),e._v(" "),a("h3",{attrs:{id:"设计目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计目的"}},[e._v("#")]),e._v(" 设计目的")]),e._v(" "),a("p",[e._v("早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。")]),e._v(" "),a("p",[e._v("严格模式是从 ES5 进入标准的，主要目的有以下几个。")]),e._v(" "),a("ul",[a("li",[e._v("明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。")]),e._v(" "),a("li",[e._v("增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。")]),e._v(" "),a("li",[e._v("提高编译器效率，增加运行速度。")]),e._v(" "),a("li",[e._v("为未来新版本的 JavaScript 语法做好铺垫。")])]),e._v(" "),a("p",[e._v("总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。")]),e._v(" "),a("h3",{attrs:{id:"启用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启用方法"}},[e._v("#")]),e._v(" 启用方法")]),e._v(" "),a("p",[e._v("进入严格模式的标志，是一行字符串"),a("code",[e._v("use strict")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\n")])])]),a("p",[e._v("老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。")]),e._v(" "),a("p",[e._v("严格模式可以用于整个脚本，也可以只用于单个函数。")]),e._v(" "),a("p",[a("strong",[e._v("（1） 整个脚本文件")])]),e._v(" "),a("p",[a("code",[e._v("use strict")]),e._v("放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，"),a("code",[e._v("use strict")]),e._v("可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<script>\n  'use strict';\n  console.log('这是严格模式');\n<\/script>\n\n<script>\n  console.log('这是正常模式');\n<\/script>\n")])])]),a("p",[e._v("上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个"),a("code",[e._v("<script>")]),e._v("标签是严格模式，后一个不是。")]),e._v(" "),a("p",[e._v("如果"),a("code",[e._v("use strict")]),e._v("写成下面这样，则不起作用，严格模式必须从代码一开始就生效。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<script>\n  console.log('这是正常模式');\n  'use strict';\n<\/script>\n")])])]),a("p",[a("strong",[e._v("（2）单个函数")])]),e._v(" "),a("p",[a("code",[e._v("use strict")]),e._v("放在函数体的第一行，则整个函数以严格模式运行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function strict() {\n  'use strict';\n  return '这是严格模式';\n}\n\nfunction strict2() {\n  'use strict';\n  function f() {\n    return '这也是严格模式';\n  }\n  return f();\n}\n\nfunction notStrict() {\n  return '这是正常模式';\n}\n")])])]),a("p",[e._v("有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(function () {\n  'use strict';\n  // some code here\n})();\n")])])]),a("h3",{attrs:{id:"显式报错"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显式报错"}},[e._v("#")]),e._v(" 显式报错")]),e._v(" "),a("p",[e._v("严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。")]),e._v(" "),a("h4",{attrs:{id:"只读属性不可写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#只读属性不可写"}},[e._v("#")]),e._v(" 只读属性不可写")]),e._v(" "),a("p",[e._v("严格模式下，设置字符串的"),a("code",[e._v("length")]),e._v("属性，会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\n'abc'.length = 5;\n// TypeError: Cannot assign to read only property 'length' of string 'abc'\n")])])]),a("p",[e._v("上面代码报错，因为"),a("code",[e._v("length")]),e._v("是只读属性，严格模式下不可写。正常模式下，改变"),a("code",[e._v("length")]),e._v("属性是无效的，但不会报错。")]),e._v(" "),a("p",[e._v("严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 对只读属性赋值会报错\n'use strict';\nObject.defineProperty({}, 'a', {\n  value: 37,\n  writable: false\n});\nobj.a = 123;\n// TypeError: Cannot assign to read only property 'a' of object #<Object>\n\n// 删除不可配置的属性会报错\n'use strict';\nvar obj = Object.defineProperty({}, 'p', {\n  value: 1,\n  configurable: false\n});\ndelete obj.p\n// TypeError: Cannot delete property 'p' of #<Object>\n")])])]),a("h4",{attrs:{id:"只设置了取值器的属性不可写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#只设置了取值器的属性不可写"}},[e._v("#")]),e._v(" 只设置了取值器的属性不可写")]),e._v(" "),a("p",[e._v("严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar obj = {\n  get v() { return 1; }\n};\nobj.v = 2;\n// Uncaught TypeError: Cannot set property v of #<Object> which has only a getter\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj.v")]),e._v("只有取值器，没有存值器，对它进行赋值就会报错。")]),e._v(" "),a("h4",{attrs:{id:"禁止扩展的对象不可扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止扩展的对象不可扩展"}},[e._v("#")]),e._v(" 禁止扩展的对象不可扩展")]),e._v(" "),a("p",[e._v("严格模式下，对禁止扩展的对象添加新属性，会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar obj = {};\nObject.preventExtensions(obj);\nobj.v = 1;\n// Uncaught TypeError: Cannot add property v, object is not extensible\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj")]),e._v("对象禁止扩展，添加属性就会报错。")]),e._v(" "),a("h4",{attrs:{id:"eval、arguments-不可用作标识名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eval、arguments-不可用作标识名"}},[e._v("#")]),e._v(" eval、arguments 不可用作标识名")]),e._v(" "),a("p",[e._v("严格模式下，使用"),a("code",[e._v("eval")]),e._v("或者"),a("code",[e._v("arguments")]),e._v("作为标识名，将会报错。下面的语句都会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar eval = 17;\nvar arguments = 17;\nvar obj = { set p(arguments) { } };\ntry { } catch (arguments) { }\nfunction x(eval) { }\nfunction arguments() { }\nvar y = function eval() { };\nvar f = new Function('arguments', \"'use strict'; return 17;\");\n// SyntaxError: Unexpected eval or arguments in strict mode\n")])])]),a("h4",{attrs:{id:"函数不能有重名的参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数不能有重名的参数"}},[e._v("#")]),e._v(" 函数不能有重名的参数")]),e._v(" "),a("p",[e._v("正常模式下，如果函数有多个重名的参数，可以用"),a("code",[e._v("arguments[i]")]),e._v("读取。严格模式下，这属于语法错误。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f(a, a, b) {\n  'use strict';\n  return a + b;\n}\n// Uncaught SyntaxError: Duplicate parameter name not allowed in this context\n")])])]),a("h4",{attrs:{id:"禁止八进制的前缀0表示法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止八进制的前缀0表示法"}},[e._v("#")]),e._v(" 禁止八进制的前缀0表示法")]),e._v(" "),a("p",[e._v("正常模式下，整数的第一位如果是"),a("code",[e._v("0")]),e._v("，表示这是八进制数，比如"),a("code",[e._v("0100")]),e._v("等于十进制的64。严格模式禁止这种表示法，整数第一位为"),a("code",[e._v("0")]),e._v("，将报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar n = 0100;\n// Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n")])])]),a("h3",{attrs:{id:"增强的安全措施"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增强的安全措施"}},[e._v("#")]),e._v(" 增强的安全措施")]),e._v(" "),a("p",[e._v("严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。")]),e._v(" "),a("h4",{attrs:{id:"全局变量显式声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局变量显式声明"}},[e._v("#")]),e._v(" 全局变量显式声明")]),e._v(" "),a("p",[e._v("正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\n\nv = 1; // 报错，v未声明\n\nfor (i = 0; i < 2; i++) { // 报错，i 未声明\n  // ...\n}\n\nfunction f() {\n  x = 123;\n}\nf() // 报错，未声明就创建一个全局变量\n")])])]),a("p",[e._v("因此，严格模式下，变量都必须先声明，然后再使用。")]),e._v(" "),a("h4",{attrs:{id:"禁止-this-关键字指向全局对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止-this-关键字指向全局对象"}},[e._v("#")]),e._v(" 禁止 this 关键字指向全局对象")]),e._v(" "),a("p",[e._v("正常模式下，函数内部的"),a("code",[e._v("this")]),e._v("可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 正常模式\nfunction f() {\n  console.log(this === window);\n}\nf() // true\n\n// 严格模式\nfunction f() {\n  'use strict';\n  console.log(this === undefined);\n}\nf() // true\n")])])]),a("p",[e._v("上面代码中，严格模式的函数体内部"),a("code",[e._v("this")]),e._v("是"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("p",[e._v("这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加"),a("code",[e._v("new")]),e._v("，这时"),a("code",[e._v("this")]),e._v("不再指向全局对象，而是报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  'use strict';\n  this.a = 1;\n};\n\nf();// 报错，this 未定义\n")])])]),a("p",[e._v("严格模式下，函数直接调用时（不使用"),a("code",[e._v("new")]),e._v("调用），函数内部的"),a("code",[e._v("this")]),e._v("表示"),a("code",[e._v("undefined")]),e._v("（未定义），因此可以用"),a("code",[e._v("call")]),e._v("、"),a("code",[e._v("apply")]),e._v("和"),a("code",[e._v("bind")]),e._v("方法，将任意值绑定在"),a("code",[e._v("this")]),e._v("上面。正常模式下，"),a("code",[e._v("this")]),e._v("指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而"),a("code",[e._v("null")]),e._v("和"),a("code",[e._v("undefined")]),e._v("这两个无法转成对象的值，将被忽略。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 正常模式\nfunction fun() {\n  return this;\n}\n\nfun() // window\nfun.call(2) // Number {2}\nfun.call(true) // Boolean {true}\nfun.call(null) // window\nfun.call(undefined) // window\n\n// 严格模式\n'use strict';\nfunction fun() {\n  return this;\n}\n\nfun() //undefined\nfun.call(2) // 2\nfun.call(true) // true\nfun.call(null) // null\nfun.call(undefined) // undefined\n")])])]),a("p",[e._v("上面代码中，可以把任意类型的值，绑定在"),a("code",[e._v("this")]),e._v("上面。")]),e._v(" "),a("h4",{attrs:{id:"禁止使用-fn-callee、fn-caller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止使用-fn-callee、fn-caller"}},[e._v("#")]),e._v(" 禁止使用 fn.callee、fn.caller")]),e._v(" "),a("p",[e._v("函数内部不得使用"),a("code",[e._v("fn.caller")]),e._v("、"),a("code",[e._v("fn.arguments")]),e._v("，否则会报错。这意味着不能在函数内部得到调用栈了。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1() {\n  'use strict';\n  f1.caller;    // 报错\n  f1.arguments; // 报错\n}\n\nf1();\n")])])]),a("h4",{attrs:{id:"禁止使用-arguments-callee、arguments-caller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止使用-arguments-callee、arguments-caller"}},[e._v("#")]),e._v(" 禁止使用 arguments.callee、arguments.caller")]),e._v(" "),a("p",[a("code",[e._v("arguments.callee")]),e._v("和"),a("code",[e._v("arguments.caller")]),e._v("是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用"),a("code",[e._v("arguments.callee")]),e._v("、"),a("code",[e._v("arguments.caller")]),e._v("将会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar f = function () {\n  return arguments.callee;\n};\n\nf(); // 报错\n")])])]),a("h4",{attrs:{id:"禁止删除变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止删除变量"}},[e._v("#")]),e._v(" 禁止删除变量")]),e._v(" "),a("p",[e._v("严格模式下无法删除变量，如果使用"),a("code",[e._v("delete")]),e._v("命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的"),a("code",[e._v("configurable")]),e._v("属性设置为"),a("code",[e._v("true")]),e._v("，才能被"),a("code",[e._v("delete")]),e._v("命令删除。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar x;\ndelete x; // 语法错误\n\nvar obj = Object.create(null, {\n  x: {\n    value: 1,\n    configurable: true\n  }\n});\ndelete obj.x; // 删除成功\n")])])]),a("h3",{attrs:{id:"静态绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态绑定"}},[e._v("#")]),e._v(" 静态绑定")]),e._v(" "),a("p",[e._v("JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。")]),e._v(" "),a("p",[e._v("严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。")]),e._v(" "),a("p",[e._v("具体来说，涉及以下几个方面。")]),e._v(" "),a("h4",{attrs:{id:"禁止使用-with-语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止使用-with-语句"}},[e._v("#")]),e._v(" 禁止使用 with 语句")]),e._v(" "),a("p",[e._v("严格模式下，使用"),a("code",[e._v("with")]),e._v("语句将报错。因为"),a("code",[e._v("with")]),e._v("语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nvar v  = 1;\nvar obj = {};\n\nwith (obj) {\n  v = 2;\n}\n// Uncaught SyntaxError: Strict mode code may not include a with statement\n")])])]),a("h4",{attrs:{id:"创设-eval-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创设-eval-作用域"}},[e._v("#")]),e._v(" 创设 eval 作用域")]),e._v(" "),a("p",[e._v("正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域："),a("code",[e._v("eval")]),e._v("作用域。")]),e._v(" "),a("p",[e._v("正常模式下，"),a("code",[e._v("eval")]),e._v("语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，"),a("code",[e._v("eval")]),e._v("语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，"),a("code",[e._v("eval")]),e._v("所生成的变量只能用于"),a("code",[e._v("eval")]),e._v("内部。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(function () {\n  'use strict';\n  var x = 2;\n  console.log(eval('var x = 5; x')) // 5\n  console.log(x) // 2\n})()\n")])])]),a("p",[e._v("上面代码中，由于"),a("code",[e._v("eval")]),e._v("语句内部是一个独立作用域，所以内部的变量"),a("code",[e._v("x")]),e._v("不会泄露到外部。")]),e._v(" "),a("p",[e._v("注意，如果希望"),a("code",[e._v("eval")]),e._v("语句也使用严格模式，有两种方式。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 方式一\nfunction f1(str){\n  'use strict';\n  return eval(str);\n}\nf1('undeclared_variable = 1'); // 报错\n\n// 方式二\nfunction f2(str){\n  return eval(str);\n}\nf2('\"use strict\";undeclared_variable = 1')  // 报错\n")])])]),a("p",[e._v("上面两种写法，"),a("code",[e._v("eval")]),e._v("内部使用的都是严格模式。")]),e._v(" "),a("h4",{attrs:{id:"arguments-不再追踪参数的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arguments-不再追踪参数的变化"}},[e._v("#")]),e._v(" arguments 不再追踪参数的变化")]),e._v(" "),a("p",[e._v("变量"),a("code",[e._v("arguments")]),e._v("代表函数的参数。严格模式下，函数内部改变参数与"),a("code",[e._v("arguments")]),e._v("的联系被切断了，两者不再存在联动关系。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f(a) {\n  a = 2;\n  return [a, arguments[0]];\n}\nf(1); // 正常模式为[2, 2]\n\nfunction f(a) {\n  'use strict';\n  a = 2;\n  return [a, arguments[0]];\n}\nf(1); // 严格模式为[2, 1]\n")])])]),a("p",[e._v("上面代码中，改变函数的参数，不会反应到"),a("code",[e._v("arguments")]),e._v("对象上来。")]),e._v(" "),a("h3",{attrs:{id:"向下一个版本的-javascript-过渡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向下一个版本的-javascript-过渡"}},[e._v("#")]),e._v(" 向下一个版本的 JavaScript 过渡")]),e._v(" "),a("p",[e._v("JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。")]),e._v(" "),a("h4",{attrs:{id:"非函数代码块不得声明函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非函数代码块不得声明函数"}},[e._v("#")]),e._v(" 非函数代码块不得声明函数")]),e._v(" "),a("p",[e._v("ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("'use strict';\nif (true) {\n  function f1() { } // 语法错误\n}\n\nfor (var i = 0; i < 5; i++) {\n  function f2() { } // 语法错误\n}\n")])])]),a("p",[e._v("上面代码在"),a("code",[e._v("if")]),e._v("代码块和"),a("code",[e._v("for")]),e._v("代码块中声明了函数，ES5 环境会报错。")]),e._v(" "),a("p",[e._v("注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。")]),e._v(" "),a("h4",{attrs:{id:"保留字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保留字"}},[e._v("#")]),e._v(" 保留字")]),e._v(" "),a("p",[e._v("为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function package(protected) { // 语法错误\n  'use strict';\n  var implements; // 语法错误\n}\n")])])]),a("h3",{attrs:{id:"参考链接-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接-4"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ul",[a("li",[e._v("MDN, "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode",target:"_blank",rel:"noopener noreferrer"}},[e._v("Strict mode"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Dr. Axel Rauschmayer, "),a("a",{attrs:{href:"http://www.2ality.com/2011/10/strict-mode-hatred.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript: Why the hatred for strict mode?"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Dr. Axel Rauschmayer，"),a("a",{attrs:{href:"http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript’s strict mode: a summary"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Douglas Crockford, "),a("a",{attrs:{href:"http://www.yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Strict Mode Is Coming To Town"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"http://java-script.limewebs.com/strictMode/test_hosted.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Strict Mode Support"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);