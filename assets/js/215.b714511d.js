(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{651:function(e,t,a){"use strict";a.r(t);var n=a(25),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"异步操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步操作"}},[e._v("#")]),e._v(" 异步操作")]),e._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),a("h3",{attrs:{id:"单线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程模型"}},[e._v("#")]),e._v(" 单线程模型")]),e._v(" "),a("p",[e._v("单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。")]),e._v(" "),a("p",[e._v("注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。")]),e._v(" "),a("p",[e._v("JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。")]),e._v(" "),a("p",[e._v("这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。")]),e._v(" "),a("p",[e._v("如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。")]),e._v(" "),a("p",[e._v("单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是 Node.js 可以用很少的资源，应付大流量访问的原因。")]),e._v(" "),a("p",[e._v("为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。")]),e._v(" "),a("h3",{attrs:{id:"同步任务和异步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步任务和异步任务"}},[e._v("#")]),e._v(" 同步任务和异步任务")]),e._v(" "),a("p",[e._v("程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。")]),e._v(" "),a("p",[e._v("同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。")]),e._v(" "),a("p",[e._v("异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。")]),e._v(" "),a("p",[e._v("举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。")]),e._v(" "),a("h3",{attrs:{id:"任务队列和事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务队列和事件循环"}},[e._v("#")]),e._v(" 任务队列和事件循环")]),e._v(" "),a("p",[e._v("JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）")]),e._v(" "),a("p",[e._v("首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。")]),e._v(" "),a("p",[e._v("异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。")]),e._v(" "),a("p",[e._v("JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Event_loop",target:"_blank",rel:"noopener noreferrer"}},[e._v("维基百科"),a("OutboundLink")],1),e._v("的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。")]),e._v(" "),a("h3",{attrs:{id:"异步操作的模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的模式"}},[e._v("#")]),e._v(" 异步操作的模式")]),e._v(" "),a("p",[e._v("下面总结一下异步操作的几种模式。")]),e._v(" "),a("h4",{attrs:{id:"回调函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[e._v("#")]),e._v(" 回调函数")]),e._v(" "),a("p",[e._v("回调函数是异步操作最基本的方法。")]),e._v(" "),a("p",[e._v("下面是两个函数"),a("code",[e._v("f1")]),e._v("和"),a("code",[e._v("f2")]),e._v("，编程的意图是"),a("code",[e._v("f2")]),e._v("必须等到"),a("code",[e._v("f1")]),e._v("执行完成，才能执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1() {\n  // ...\n}\n\nfunction f2() {\n  // ...\n}\n\nf1();\nf2();\n")])])]),a("p",[e._v("上面代码的问题在于，如果"),a("code",[e._v("f1")]),e._v("是异步操作，"),a("code",[e._v("f2")]),e._v("会立即执行，不会等到"),a("code",[e._v("f1")]),e._v("结束再执行。")]),e._v(" "),a("p",[e._v("这时，可以考虑改写"),a("code",[e._v("f1")]),e._v("，把"),a("code",[e._v("f2")]),e._v("写成"),a("code",[e._v("f1")]),e._v("的回调函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1(callback) {\n  // ...\n  callback();\n}\n\nfunction f2() {\n  // ...\n}\n\nf1(f2);\n")])])]),a("p",[e._v("回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Coupling_(computer_programming)",target:"_blank",rel:"noopener noreferrer"}},[e._v("耦合"),a("OutboundLink")],1),e._v("（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。")]),e._v(" "),a("h4",{attrs:{id:"事件监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[e._v("#")]),e._v(" 事件监听")]),e._v(" "),a("p",[e._v("另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。")]),e._v(" "),a("p",[e._v("还是以"),a("code",[e._v("f1")]),e._v("和"),a("code",[e._v("f2")]),e._v("为例。首先，为"),a("code",[e._v("f1")]),e._v("绑定一个事件（这里采用的 jQuery 的"),a("a",{attrs:{href:"https://api.jquery.com/on/",target:"_blank",rel:"noopener noreferrer"}},[e._v("写法"),a("OutboundLink")],1),e._v("）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f1.on('done', f2);\n")])])]),a("p",[e._v("上面这行代码的意思是，当"),a("code",[e._v("f1")]),e._v("发生"),a("code",[e._v("done")]),e._v("事件，就执行"),a("code",[e._v("f2")]),e._v("。然后，对"),a("code",[e._v("f1")]),e._v("进行改写：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1() {\n  setTimeout(function () {\n    // ...\n    f1.trigger('done');\n  }, 1000);\n}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("f1.trigger('done')")]),e._v("表示，执行完成后，立即触发"),a("code",[e._v("done")]),e._v("事件，从而开始执行"),a("code",[e._v("f2")]),e._v("。")]),e._v(" "),a("p",[e._v("这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Decoupling",target:"_blank",rel:"noopener noreferrer"}},[e._v("去耦合"),a("OutboundLink")],1),e._v("”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。")]),e._v(" "),a("h4",{attrs:{id:"发布-订阅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅"}},[e._v("#")]),e._v(" 发布/订阅")]),e._v(" "),a("p",[e._v("事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Publish-subscribe_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("发布/订阅模式"),a("OutboundLink")],1),e._v("”（publish-subscribe pattern），又称“"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Observer_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("观察者模式"),a("OutboundLink")],1),e._v("”（observer pattern）。")]),e._v(" "),a("p",[e._v("这个模式有多种"),a("a",{attrs:{href:"https://msdn.microsoft.com/en-us/magazine/hh201955.aspx",target:"_blank",rel:"noopener noreferrer"}},[e._v("实现"),a("OutboundLink")],1),e._v("，下面采用的是 Ben Alman 的 "),a("a",{attrs:{href:"https://gist.github.com/661855",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tiny Pub/Sub"),a("OutboundLink")],1),e._v("，这是 jQuery 的一个插件。")]),e._v(" "),a("p",[e._v("首先，"),a("code",[e._v("f2")]),e._v("向信号中心"),a("code",[e._v("jQuery")]),e._v("订阅"),a("code",[e._v("done")]),e._v("信号。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jQuery.subscribe('done', f2);\n")])])]),a("p",[e._v("然后，"),a("code",[e._v("f1")]),e._v("进行如下改写。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1() {\n  setTimeout(function () {\n    // ...\n    jQuery.publish('done');\n  }, 1000);\n}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("jQuery.publish('done')")]),e._v("的意思是，"),a("code",[e._v("f1")]),e._v("执行完成后，向信号中心"),a("code",[e._v("jQuery")]),e._v("发布"),a("code",[e._v("done")]),e._v("信号，从而引发"),a("code",[e._v("f2")]),e._v("的执行。")]),e._v(" "),a("p",[a("code",[e._v("f2")]),e._v("完成执行后，可以取消订阅（unsubscribe）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("jQuery.unsubscribe('done', f2);\n")])])]),a("p",[e._v("这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。")]),e._v(" "),a("h3",{attrs:{id:"异步操作的流程控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的流程控制"}},[e._v("#")]),e._v(" 异步操作的流程控制")]),e._v(" "),a("p",[e._v("如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n")])])]),a("p",[e._v("上面代码的"),a("code",[e._v("async")]),e._v("函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。")]),e._v(" "),a("p",[e._v("如果有六个这样的异步任务，需要全部完成后，才能执行最后的"),a("code",[e._v("final")]),e._v("函数。请问应该如何安排操作流程？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function final(value) {\n  console.log('完成: ', value);\n}\n\nasync(1, function (value) {\n  async(2, function (value) {\n    async(3, function (value) {\n      async(4, function (value) {\n        async(5, function (value) {\n          async(6, final);\n        });\n      });\n    });\n  });\n});\n// 参数为 1 , 1秒后返回结果\n// 参数为 2 , 1秒后返回结果\n// 参数为 3 , 1秒后返回结果\n// 参数为 4 , 1秒后返回结果\n// 参数为 5 , 1秒后返回结果\n// 参数为 6 , 1秒后返回结果\n// 完成:  12\n")])])]),a("p",[e._v("上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。")]),e._v(" "),a("h4",{attrs:{id:"串行执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#串行执行"}},[e._v("#")]),e._v(" 串行执行")]),e._v(" "),a("p",[e._v("我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction series(item) {\n  if(item) {\n    async( item, function(result) {\n      results.push(result);\n      return series(items.shift());\n    });\n  } else {\n    return final(results[results.length - 1]);\n  }\n}\n\nseries(items.shift());\n")])])]),a("p",[e._v("上面代码中，函数"),a("code",[e._v("series")]),e._v("就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行"),a("code",[e._v("final")]),e._v("函数。"),a("code",[e._v("items")]),e._v("数组保存每一个异步任务的参数，"),a("code",[e._v("results")]),e._v("数组保存每一个异步任务的运行结果。")]),e._v(" "),a("p",[e._v("注意，上面的写法需要六秒，才能完成整个脚本。")]),e._v(" "),a("h4",{attrs:{id:"并行执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行执行"}},[e._v("#")]),e._v(" 并行执行")]),e._v(" "),a("p",[e._v("流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行"),a("code",[e._v("final")]),e._v("函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nitems.forEach(function(item) {\n  async(item, function(result){\n    results.push(result);\n    if(results.length === items.length) {\n      final(results[results.length - 1]);\n    }\n  })\n});\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("forEach")]),e._v("方法会同时发起六个异步任务，等到它们全部完成以后，才会执行"),a("code",[e._v("final")]),e._v("函数。")]),e._v(" "),a("p",[e._v("相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。")]),e._v(" "),a("h4",{attrs:{id:"并行与串行的结合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并行与串行的结合"}},[e._v("#")]),e._v(" 并行与串行的结合")]),e._v(" "),a("p",[e._v("所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行"),a("code",[e._v("n")]),e._v("个异步任务，这样就避免了过分占用系统资源。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var items = [ 1, 2, 3, 4, 5, 6 ];\nvar results = [];\nvar running = 0;\nvar limit = 2;\n\nfunction async(arg, callback) {\n  console.log('参数为 ' + arg +' , 1秒后返回结果');\n  setTimeout(function () { callback(arg * 2); }, 1000);\n}\n\nfunction final(value) {\n  console.log('完成: ', value);\n}\n\nfunction launcher() {\n  while(running < limit && items.length > 0) {\n    var item = items.shift();\n    async(item, function(result) {\n      results.push(result);\n      running--;\n      if(items.length > 0) {\n        launcher();\n      } else if(running == 0) {\n        final(results);\n      }\n    });\n    running++;\n  }\n}\n\nlauncher();\n")])])]),a("p",[e._v("上面代码中，最多只能同时运行两个异步任务。变量"),a("code",[e._v("running")]),e._v("记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于"),a("code",[e._v("0")]),e._v("，就表示所有任务都执行完了，这时就执行"),a("code",[e._v("final")]),e._v("函数。")]),e._v(" "),a("p",[e._v("这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节"),a("code",[e._v("limit")]),e._v("变量，达到效率和资源的最佳平衡。")]),e._v(" "),a("h2",{attrs:{id:"定时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[e._v("#")]),e._v(" 定时器")]),e._v(" "),a("p",[e._v("JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由"),a("code",[e._v("setTimeout()")]),e._v("和"),a("code",[e._v("setInterval()")]),e._v("这两个函数来完成。它们向任务队列添加定时任务。")]),e._v(" "),a("h3",{attrs:{id:"settimeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout"}},[e._v("#")]),e._v(" setTimeout()")]),e._v(" "),a("p",[a("code",[e._v("setTimeout")]),e._v("函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var timerId = setTimeout(func|code, delay);\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("setTimeout")]),e._v("函数接受两个参数，第一个参数"),a("code",[e._v("func|code")]),e._v("是将要推迟执行的函数名或者一段代码，第二个参数"),a("code",[e._v("delay")]),e._v("是推迟执行的毫秒数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(1);\nsetTimeout('console.log(2)',1000);\nconsole.log(3);\n// 1\n// 3\n// 2\n")])])]),a("p",[e._v("上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，"),a("code",[e._v("console.log(2)")]),e._v("必须以字符串的形式，作为"),a("code",[e._v("setTimeout")]),e._v("的参数。")]),e._v(" "),a("p",[e._v("如果推迟执行的是函数，就直接将函数名，作为"),a("code",[e._v("setTimeout")]),e._v("的参数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {\n  console.log(2);\n}\n\nsetTimeout(f, 1000);\n")])])]),a("p",[a("code",[e._v("setTimeout")]),e._v("的第二个参数如果省略，则默认为0。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setTimeout(f)\n// 等同于\nsetTimeout(f, 0)\n")])])]),a("p",[e._v("除了前两个参数，"),a("code",[e._v("setTimeout")]),e._v("还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setTimeout(function (a,b) {\n  console.log(a + b);\n}, 1000, 1, 1);\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("setTimeout")]),e._v("共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。")]),e._v(" "),a("p",[e._v("还有一个需要注意的地方，如果回调函数是对象的方法，那么"),a("code",[e._v("setTimeout")]),e._v("使得方法内部的"),a("code",[e._v("this")]),e._v("关键字指向全局环境，而不是定义时所在的那个对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var x = 1;\n\nvar obj = {\n  x: 2,\n  y: function () {\n    console.log(this.x);\n  }\n};\n\nsetTimeout(obj.y, 1000) // 1\n")])])]),a("p",[e._v("上面代码输出的是1，而不是2。因为当"),a("code",[e._v("obj.y")]),e._v("在1000毫秒后运行时，"),a("code",[e._v("this")]),e._v("所指向的已经不是"),a("code",[e._v("obj")]),e._v("了，而是全局环境。")]),e._v(" "),a("p",[e._v("为了防止出现这个问题，一种解决方法是将"),a("code",[e._v("obj.y")]),e._v("放入一个函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var x = 1;\n\nvar obj = {\n  x: 2,\n  y: function () {\n    console.log(this.x);\n  }\n};\n\nsetTimeout(function () {\n  obj.y();\n}, 1000);\n// 2\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("obj.y")]),e._v("放在一个匿名函数之中，这使得"),a("code",[e._v("obj.y")]),e._v("在"),a("code",[e._v("obj")]),e._v("的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。")]),e._v(" "),a("p",[e._v("另一种解决方法是，使用"),a("code",[e._v("bind")]),e._v("方法，将"),a("code",[e._v("obj.y")]),e._v("这个方法绑定在"),a("code",[e._v("obj")]),e._v("上面。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var x = 1;\n\nvar obj = {\n  x: 2,\n  y: function () {\n    console.log(this.x);\n  }\n};\n\nsetTimeout(obj.y.bind(obj), 1000)\n// 2\n")])])]),a("h3",{attrs:{id:"setinterval"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setinterval"}},[e._v("#")]),e._v(" setInterval()")]),e._v(" "),a("p",[a("code",[e._v("setInterval")]),e._v("函数的用法与"),a("code",[e._v("setTimeout")]),e._v("完全一致，区别仅仅在于"),a("code",[e._v("setInterval")]),e._v("指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var i = 1\nvar timer = setInterval(function() {\n  console.log(2);\n}, 1000)\n")])])]),a("p",[e._v("上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。")]),e._v(" "),a("p",[e._v("与"),a("code",[e._v("setTimeout")]),e._v("一样，除了前两个参数，"),a("code",[e._v("setInterval")]),e._v("方法还可以接受更多的参数，它们会传入回调函数。")]),e._v(" "),a("p",[e._v("下面是一个通过"),a("code",[e._v("setInterval")]),e._v("方法实现网页动画的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var div = document.getElementById('someDiv');\nvar opacity = 1;\nvar fader = setInterval(function() {\n  opacity -= 0.1;\n  if (opacity >= 0) {\n    div.style.opacity = opacity;\n  } else {\n    clearInterval(fader);\n  }\n}, 100);\n")])])]),a("p",[e._v("上面代码每隔100毫秒，设置一次"),a("code",[e._v("div")]),e._v("元素的透明度，直至其完全透明为止。")]),e._v(" "),a("p",[a("code",[e._v("setInterval")]),e._v("的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var hash = window.location.hash;\nvar hashWatcher = setInterval(function() {\n  if (window.location.hash != hash) {\n    updatePage();\n  }\n}, 1000);\n")])])]),a("p",[a("code",[e._v("setInterval")]),e._v("指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，"),a("code",[e._v("setInterval")]),e._v("指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。")]),e._v(" "),a("p",[e._v("为了确保两次执行之间有固定的间隔，可以不用"),a("code",[e._v("setInterval")]),e._v("，而是每次执行结束后，使用"),a("code",[e._v("setTimeout")]),e._v("指定下一次执行的具体时间。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var i = 1;\nvar timer = setTimeout(function f() {\n  // ...\n  timer = setTimeout(f, 2000);\n}, 2000);\n")])])]),a("p",[e._v("上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。")]),e._v(" "),a("h3",{attrs:{id:"cleartimeout-clearinterval"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cleartimeout-clearinterval"}},[e._v("#")]),e._v(" clearTimeout()，clearInterval()")]),e._v(" "),a("p",[a("code",[e._v("setTimeout")]),e._v("和"),a("code",[e._v("setInterval")]),e._v("函数，都返回一个整数值，表示计数器编号。将该整数传入"),a("code",[e._v("clearTimeout")]),e._v("和"),a("code",[e._v("clearInterval")]),e._v("函数，就可以取消对应的定时器。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var id1 = setTimeout(f, 1000);\nvar id2 = setInterval(f, 1000);\n\nclearTimeout(id1);\nclearInterval(id2);\n")])])]),a("p",[e._v("上面代码中，回调函数"),a("code",[e._v("f")]),e._v("不会再执行了，因为两个定时器都被取消了。")]),e._v(" "),a("p",[a("code",[e._v("setTimeout")]),e._v("和"),a("code",[e._v("setInterval")]),e._v("返回的整数值是连续的，也就是说，第二个"),a("code",[e._v("setTimeout")]),e._v("方法返回的整数值，将比第一个的整数值大1。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f() {}\nsetTimeout(f, 1000) // 10\nsetTimeout(f, 1000) // 11\nsetTimeout(f, 1000) // 12\n")])])]),a("p",[e._v("上面代码中，连续调用三次"),a("code",[e._v("setTimeout")]),e._v("，返回值都比上一次大了1。")]),e._v(" "),a("p",[e._v("利用这一点，可以写一个函数，取消当前所有的"),a("code",[e._v("setTimeout")]),e._v("定时器。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(function() {\n  // 每轮事件循环检查一次\n  var gid = setInterval(clearAllTimeouts, 0);\n\n  function clearAllTimeouts() {\n    var id = setTimeout(function() {}, 0);\n    while (id > 0) {\n      if (id !== gid) {\n        clearTimeout(id);\n      }\n      id--;\n    }\n  }\n})();\n")])])]),a("p",[e._v("上面代码中，先调用"),a("code",[e._v("setTimeout")]),e._v("，得到一个计算器编号，然后把编号比它小的计数器全部取消。")]),e._v(" "),a("h3",{attrs:{id:"实例-debounce-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例-debounce-函数"}},[e._v("#")]),e._v(" 实例：debounce 函数")]),e._v(" "),a("p",[e._v("有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$('textarea').on('keydown', ajaxAction);\n")])])]),a("p",[e._v("这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发"),a("code",[e._v("keydown")]),e._v("事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的"),a("code",[e._v("keydown")]),e._v("事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的"),a("code",[e._v("keydown")]),e._v("事件，再将数据发送出去。")]),e._v(" "),a("p",[e._v("这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$('textarea').on('keydown', debounce(ajaxAction, 2500));\n\nfunction debounce(fn, delay){\n  var timer = null; // 声明计时器\n  return function() {\n    var context = this;\n    var args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n")])])]),a("p",[e._v("上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。")]),e._v(" "),a("h3",{attrs:{id:"运行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行机制"}},[e._v("#")]),e._v(" 运行机制")]),e._v(" "),a("p",[a("code",[e._v("setTimeout")]),e._v("和"),a("code",[e._v("setInterval")]),e._v("的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。")]),e._v(" "),a("p",[e._v("这意味着，"),a("code",[e._v("setTimeout")]),e._v("和"),a("code",[e._v("setInterval")]),e._v("指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，"),a("code",[e._v("setTimeout")]),e._v("和"),a("code",[e._v("setInterval")]),e._v("指定的任务，一定会按照预定时间执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setTimeout(someTask, 100);\nveryLongTask();\n")])])]),a("p",[e._v("上面代码的"),a("code",[e._v("setTimeout")]),e._v("，指定100毫秒以后运行一个任务。但是，如果后面的"),a("code",[e._v("veryLongTask")]),e._v("函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的"),a("code",[e._v("someTask")]),e._v("就只有等着，等到"),a("code",[e._v("veryLongTask")]),e._v("运行结束，才轮到它执行。")]),e._v(" "),a("p",[e._v("再看一个"),a("code",[e._v("setInterval")]),e._v("的例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setInterval(function () {\n  console.log(2);\n}, 1000);\n\nsleep(3000);\n\nfunction sleep(ms) {\n  var start = Date.now();\n  while ((Date.now() - start) < ms) {\n  }\n}\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("setInterval")]),e._v("要求每隔1000毫秒，就输出一个2。但是，紧接着的"),a("code",[e._v("sleep")]),e._v("语句需要3000毫秒才能完成，那么"),a("code",[e._v("setInterval")]),e._v("就必须推迟到3000毫秒之后才开始生效。注意，生效后"),a("code",[e._v("setInterval")]),e._v("不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。")]),e._v(" "),a("h3",{attrs:{id:"settimeout-f-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-f-0"}},[e._v("#")]),e._v(" setTimeout(f, 0)")]),e._v(" "),a("h4",{attrs:{id:"含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[e._v("#")]),e._v(" 含义")]),e._v(" "),a("p",[a("code",[e._v("setTimeout")]),e._v("的作用是将代码推迟到指定时间执行，如果指定时间为"),a("code",[e._v("0")]),e._v("，即"),a("code",[e._v("setTimeout(f, 0)")]),e._v("，那么会立刻执行吗？")]),e._v(" "),a("p",[e._v("答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行"),a("code",[e._v("setTimeout")]),e._v("指定的回调函数"),a("code",[e._v("f")]),e._v("。也就是说，"),a("code",[e._v("setTimeout(f, 0)")]),e._v("会在下一轮事件循环一开始就执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setTimeout(function () {\n  console.log(1);\n}, 0);\nconsole.log(2);\n// 2\n// 1\n")])])]),a("p",[e._v("上面代码先输出"),a("code",[e._v("2")]),e._v("，再输出"),a("code",[e._v("1")]),e._v("。因为"),a("code",[e._v("2")]),e._v("是同步任务，在本轮事件循环执行，而"),a("code",[e._v("1")]),e._v("是下一轮事件循环执行。")]),e._v(" "),a("p",[e._v("总之，"),a("code",[e._v("setTimeout(f, 0)")]),e._v("这种写法的目的是，尽可能早地执行"),a("code",[e._v("f")]),e._v("，但是并不能保证立刻就执行"),a("code",[e._v("f")]),e._v("。")]),e._v(" "),a("p",[e._v("实际上，"),a("code",[e._v("setTimeout(f, 0)")]),e._v("不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。")]),e._v(" "),a("h4",{attrs:{id:"应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[e._v("#")]),e._v(" 应用")]),e._v(" "),a("p",[a("code",[e._v("setTimeout(f, 0)")]),e._v("有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到"),a("code",[e._v("setTimeout(f, 0)")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// HTML 代码如下\n// <input type=\"button\" id=\"myButton\" value=\"click\">\n\nvar input = document.getElementById('myButton');\n\ninput.onclick = function A() {\n  setTimeout(function B() {\n    input.value +=' input';\n  }, 0)\n};\n\ndocument.body.onclick = function C() {\n  input.value += ' body'\n};\n")])])]),a("p",[e._v("上面代码在点击按钮后，先触发回调函数"),a("code",[e._v("A")]),e._v("，然后触发函数"),a("code",[e._v("C")]),e._v("。函数"),a("code",[e._v("A")]),e._v("中，"),a("code",[e._v("setTimeout")]),e._v("将函数"),a("code",[e._v("B")]),e._v("推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数"),a("code",[e._v("C")]),e._v("的目的了。")]),e._v(" "),a("p",[e._v("另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，"),a("code",[e._v("keypress")]),e._v("事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// HTML 代码如下\n// <input type="text" id="input-box">\n\ndocument.getElementById(\'input-box\').onkeypress = function (event) {\n  this.value = this.value.toUpperCase();\n}\n')])])]),a("p",[e._v("上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以"),a("code",[e._v("this.value")]),e._v("取不到最新输入的那个字符。只有用"),a("code",[e._v("setTimeout")]),e._v("改写，上面的代码才能发挥作用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("document.getElementById('input-box').onkeypress = function() {\n  var self = this;\n  setTimeout(function() {\n    self.value = self.value.toUpperCase();\n  }, 0);\n}\n")])])]),a("p",[e._v("上面代码将代码放入"),a("code",[e._v("setTimeout")]),e._v("之中，就能使得它在浏览器接收到文本之后触发。")]),e._v(" "),a("p",[e._v("由于"),a("code",[e._v("setTimeout(f, 0)")]),e._v("实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到"),a("code",[e._v("setTimeout(f, 0)")]),e._v("里面执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var div = document.getElementsByTagName('div')[0];\n\n// 写法一\nfor (var i = 0xA00000; i < 0xFFFFFF; i++) {\n  div.style.backgroundColor = '#' + i.toString(16);\n}\n\n// 写法二\nvar timer;\nvar i=0x100000;\n\nfunction func() {\n  timer = setTimeout(func, 0);\n  div.style.backgroundColor = '#' + i.toString(16);\n  if (i++ == 0xFFFFFF) clearTimeout(timer);\n}\n\ntimer = setTimeout(func, 0);\n")])])]),a("p",[e._v("上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是"),a("code",[e._v("setTimeout(f, 0)")]),e._v("的好处。")]),e._v(" "),a("p",[e._v("另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成"),a("code",[e._v("setTimeout(highlightNext, 50)")]),e._v("的样子，性能压力就会减轻。")]),e._v(" "),a("h2",{attrs:{id:"promise-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[e._v("#")]),e._v(" Promise 对象")]),e._v(" "),a("h3",{attrs:{id:"概述-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),a("p",[e._v("Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。")]),e._v(" "),a("p",[e._v("注意，本章只是 Promise 对象的简单介绍。为了避免与后续教程的重复，更完整的介绍请看"),a("a",{attrs:{href:"https://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("《ES6 标准入门》"),a("OutboundLink")],1),e._v("的"),a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Promise 对象》"),a("OutboundLink")],1),e._v("一章。")]),e._v(" "),a("p",[e._v("首先，Promise 是一个对象，也是一个构造函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function f1(resolve, reject) {\n  // 异步代码...\n}\n\nvar p1 = new Promise(f1);\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Promise")]),e._v("构造函数接受一个回调函数"),a("code",[e._v("f1")]),e._v("作为参数，"),a("code",[e._v("f1")]),e._v("里面是异步操作的代码。然后，返回的"),a("code",[e._v("p1")]),e._v("就是一个 Promise 实例。")]),e._v(" "),a("p",[e._v("Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个"),a("code",[e._v("then")]),e._v("方法，用来指定下一步的回调函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise(f1);\np1.then(f2);\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("f1")]),e._v("的异步操作执行完成，就会执行"),a("code",[e._v("f2")]),e._v("。")]),e._v(" "),a("p",[e._v("传统的写法可能需要把"),a("code",[e._v("f2")]),e._v("作为回调函数传入"),a("code",[e._v("f1")]),e._v("，比如写成"),a("code",[e._v("f1(f2)")]),e._v("，异步操作完成后，在"),a("code",[e._v("f1")]),e._v("内部调用"),a("code",[e._v("f2")]),e._v("。Promise 使得"),a("code",[e._v("f1")]),e._v("和"),a("code",[e._v("f2")]),e._v("变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 传统写法\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // ...\n      });\n    });\n  });\n});\n\n// Promise 的写法\n(new Promise(step1))\n  .then(step2)\n  .then(step3)\n  .then(step4);\n")])])]),a("p",[e._v("从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的"),a("code",[e._v("Promise")]),e._v("实例的生成格式，做了简化，真正的语法请参照下文。")]),e._v(" "),a("p",[e._v("总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。")]),e._v(" "),a("p",[e._v("Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。")]),e._v(" "),a("h3",{attrs:{id:"promise-对象的状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象的状态"}},[e._v("#")]),e._v(" Promise 对象的状态")]),e._v(" "),a("p",[e._v("Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。")]),e._v(" "),a("ul",[a("li",[e._v("异步操作未完成（pending）")]),e._v(" "),a("li",[e._v("异步操作成功（fulfilled）")]),e._v(" "),a("li",[e._v("异步操作失败（rejected）")])]),e._v(" "),a("p",[e._v("上面三种状态里面，"),a("code",[e._v("fulfilled")]),e._v("和"),a("code",[e._v("rejected")]),e._v("合在一起称为"),a("code",[e._v("resolved")]),e._v("（已定型）。")]),e._v(" "),a("p",[e._v("这三种的状态的变化途径只有两种。")]),e._v(" "),a("ul",[a("li",[e._v("从“未完成”到“成功”")]),e._v(" "),a("li",[e._v("从“未完成”到“失败”")])]),e._v(" "),a("p",[e._v("一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。")]),e._v(" "),a("p",[e._v("因此，Promise 的最终结果只有两种。")]),e._v(" "),a("ul",[a("li",[e._v("异步操作成功，Promise 实例传回一个值（value），状态变为"),a("code",[e._v("fulfilled")]),e._v("。")]),e._v(" "),a("li",[e._v("异步操作失败，Promise 实例抛出一个错误（error），状态变为"),a("code",[e._v("rejected")]),e._v("。")])]),e._v(" "),a("h3",{attrs:{id:"promise-构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-构造函数"}},[e._v("#")]),e._v(" Promise 构造函数")]),e._v(" "),a("p",[e._v("JavaScript 提供原生的"),a("code",[e._v("Promise")]),e._v("构造函数，用来生成 Promise 实例。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var promise = new Promise(function (resolve, reject) {\n  // ...\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else { /* 异步操作失败 */\n    reject(new Error());\n  }\n});\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("Promise")]),e._v("构造函数接受一个函数作为参数，该函数的两个参数分别是"),a("code",[e._v("resolve")]),e._v("和"),a("code",[e._v("reject")]),e._v("。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。")]),e._v(" "),a("p",[a("code",[e._v("resolve")]),e._v("函数的作用是，将"),a("code",[e._v("Promise")]),e._v("实例的状态从“未完成”变为“成功”（即从"),a("code",[e._v("pending")]),e._v("变为"),a("code",[e._v("fulfilled")]),e._v("），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。"),a("code",[e._v("reject")]),e._v("函数的作用是，将"),a("code",[e._v("Promise")]),e._v("实例的状态从“未完成”变为“失败”（即从"),a("code",[e._v("pending")]),e._v("变为"),a("code",[e._v("rejected")]),e._v("），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。")]),e._v(" "),a("p",[e._v("下面是一个例子。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100)\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("timeout(100)")]),e._v("返回一个 Promise 实例。100毫秒以后，该实例的状态会变为"),a("code",[e._v("fulfilled")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"promise-prototype-then"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[e._v("#")]),e._v(" Promise.prototype.then()")]),e._v(" "),a("p",[e._v("Promise 实例的"),a("code",[e._v("then")]),e._v("方法，用来添加回调函数。")]),e._v(" "),a("p",[a("code",[e._v("then")]),e._v("方法可以接受两个回调函数，第一个是异步操作成功时（变为"),a("code",[e._v("fulfilled")]),e._v("状态）的回调函数，第二个是异步操作失败（变为"),a("code",[e._v("rejected")]),e._v("）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise(function (resolve, reject) {\n  resolve('成功');\n});\np1.then(console.log, console.error);\n// \"成功\"\n\nvar p2 = new Promise(function (resolve, reject) {\n  reject(new Error('失败'));\n});\np2.then(console.log, console.error);\n// Error: 失败\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("p1")]),e._v("和"),a("code",[e._v("p2")]),e._v("都是Promise 实例，它们的"),a("code",[e._v("then")]),e._v("方法绑定两个回调函数：成功时的回调函数"),a("code",[e._v("console.log")]),e._v("，失败时的回调函数"),a("code",[e._v("console.error")]),e._v("（可以省略）。"),a("code",[e._v("p1")]),e._v("的状态变为成功，"),a("code",[e._v("p2")]),e._v("的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。")]),e._v(" "),a("p",[a("code",[e._v("then")]),e._v("方法可以链式使用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("p1\n  .then(step1)\n  .then(step2)\n  .then(step3)\n  .then(\n    console.log,\n    console.error\n  );\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("p1")]),e._v("后面有四个"),a("code",[e._v("then")]),e._v("，意味依次有四个回调函数。只要前一步的状态变为"),a("code",[e._v("fulfilled")]),e._v("，就会依次执行紧跟在后面的回调函数。")]),e._v(" "),a("p",[e._v("最后一个"),a("code",[e._v("then")]),e._v("方法，回调函数是"),a("code",[e._v("console.log")]),e._v("和"),a("code",[e._v("console.error")]),e._v("，用法上有一点重要的区别。"),a("code",[e._v("console.log")]),e._v("只显示"),a("code",[e._v("step3")]),e._v("的返回值，而"),a("code",[e._v("console.error")]),e._v("可以显示"),a("code",[e._v("p1")]),e._v("、"),a("code",[e._v("step1")]),e._v("、"),a("code",[e._v("step2")]),e._v("、"),a("code",[e._v("step3")]),e._v("之中任意一个发生的错误。举例来说，如果"),a("code",[e._v("step1")]),e._v("的状态变为"),a("code",[e._v("rejected")]),e._v("，那么"),a("code",[e._v("step2")]),e._v("和"),a("code",[e._v("step3")]),e._v("都不会执行了（因为它们是"),a("code",[e._v("resolved")]),e._v("的回调函数）。Promise 开始寻找，接下来第一个为"),a("code",[e._v("rejected")]),e._v("的回调函数，在上面代码中是"),a("code",[e._v("console.error")]),e._v("。这就是说，Promise 对象的报错具有传递性。")]),e._v(" "),a("h3",{attrs:{id:"then-用法辨析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#then-用法辨析"}},[e._v("#")]),e._v(" then() 用法辨析")]),e._v(" "),a("p",[e._v("Promise 的用法，简单说就是一句话：使用"),a("code",[e._v("then")]),e._v("方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 写法一\nf1().then(function () {\n  return f2();\n});\n\n// 写法二\nf1().then(function () {\n  f2();\n});\n\n// 写法三\nf1().then(f2());\n\n// 写法四\nf1().then(f2);\n")])])]),a("p",[e._v("为了便于讲解，下面这四种写法都再用"),a("code",[e._v("then")]),e._v("方法接一个回调函数"),a("code",[e._v("f3")]),e._v("。写法一的"),a("code",[e._v("f3")]),e._v("回调函数的参数，是"),a("code",[e._v("f2")]),e._v("函数的运行结果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f1().then(function () {\n  return f2();\n}).then(f3);\n")])])]),a("p",[e._v("写法二的"),a("code",[e._v("f3")]),e._v("回调函数的参数是"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f1().then(function () {\n  f2();\n  return;\n}).then(f3);\n")])])]),a("p",[e._v("写法三的"),a("code",[e._v("f3")]),e._v("回调函数的参数，是"),a("code",[e._v("f2")]),e._v("函数返回的函数的运行结果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f1().then(f2())\n  .then(f3);\n")])])]),a("p",[e._v("写法四与写法一只有一个差别，那就是"),a("code",[e._v("f2")]),e._v("会接收到"),a("code",[e._v("f1()")]),e._v("返回的结果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f1().then(f2)\n  .then(f3);\n")])])]),a("h3",{attrs:{id:"实例-图片加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例-图片加载"}},[e._v("#")]),e._v(" 实例：图片加载")]),e._v(" "),a("p",[e._v("下面是使用 Promise 完成图片的加载。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n")])])]),a("p",[e._v("上面代码中，"),a("code",[e._v("image")]),e._v("是一个图片对象的实例。它有两个事件监听属性，"),a("code",[e._v("onload")]),e._v("属性在图片加载成功后调用，"),a("code",[e._v("onerror")]),e._v("属性在加载失败调用。")]),e._v(" "),a("p",[e._v("上面的"),a("code",[e._v("preloadImage()")]),e._v("函数用法如下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("preloadImage('https://example.com/my.jpg')\n  .then(function (e) { document.body.append(e.target) })\n  .then(function () { console.log('加载成功') })\n")])])]),a("p",[e._v("上面代码中，图片加载成功以后，"),a("code",[e._v("onload")]),e._v("属性会返回一个事件对象，因此第一个"),a("code",[e._v("then()")]),e._v("方法的回调函数，会接收到这个事件对象。该对象的"),a("code",[e._v("target")]),e._v("属性就是图片加载后生成的 DOM 节点。")]),e._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("p",[e._v("Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。")]),e._v(" "),a("p",[e._v("而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。")]),e._v(" "),a("p",[e._v("Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆"),a("code",[e._v("then")]),e._v("，必须自己在"),a("code",[e._v("then")]),e._v("的回调函数里面理清逻辑。")]),e._v(" "),a("h3",{attrs:{id:"微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[e._v("#")]),e._v(" 微任务")]),e._v(" "),a("p",[e._v("Promise 的回调函数属于异步任务，会在同步任务之后执行。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new Promise(function (resolve, reject) {\n  resolve(1);\n}).then(console.log);\n\nconsole.log(2);\n// 2\n// 1\n")])])]),a("p",[e._v("上面代码会先输出2，再输出1。因为"),a("code",[e._v("console.log(2)")]),e._v("是同步任务，而"),a("code",[e._v("then")]),e._v("的回调函数属于异步任务，一定晚于同步任务执行。")]),e._v(" "),a("p",[e._v("但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setTimeout(function() {\n  console.log(1);\n}, 0);\n\nnew Promise(function (resolve, reject) {\n  resolve(2);\n}).then(console.log);\n\nconsole.log(3);\n// 3\n// 2\n// 1\n")])])]),a("p",[e._v("上面代码的输出结果是"),a("code",[e._v("321")]),e._v("。这说明"),a("code",[e._v("then")]),e._v("的回调函数的执行时间，早于"),a("code",[e._v("setTimeout(fn, 0)")]),e._v("。因为"),a("code",[e._v("then")]),e._v("是本轮事件循环执行，"),a("code",[e._v("setTimeout(fn, 0)")]),e._v("在下一轮事件循环开始时执行。")]),e._v(" "),a("h3",{attrs:{id:"参考链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ul",[a("li",[e._v("Sebastian Porto, "),a("a",{attrs:{href:"https://sporto.github.com/blog/2012/12/09/callbacks-listeners-promises/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Rhys Brett-Bowen, "),a("a",{attrs:{href:"https://modernjavascript.blogspot.com/2013/08/promisesa-understanding-by-doing.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+ - understanding the spec through implementation"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Matt Podwysocki, Amanda Silver, "),a("a",{attrs:{href:"https://blogs.msdn.com/b/ie/archive/2011/09/11/asynchronous-programming-in-javascript-with-promises.aspx",target:"_blank",rel:"noopener noreferrer"}},[e._v("Asynchronous Programming in JavaScript with “Promises”"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Marc Harter, "),a("a",{attrs:{href:"https://gist.github.com//wavded/5692344",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise A+ Implementation"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Bryan Klimt, "),a("a",{attrs:{href:"http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/",target:"_blank",rel:"noopener noreferrer"}},[e._v("What’s so great about JavaScript Promises?"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Jake Archibald, "),a("a",{attrs:{href:"https://www.html5rocks.com/en/tutorials/es6/promises/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Promises There and back again"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Mikito Takada, "),a("a",{attrs:{href:"http://book.mixu.net/node/ch7.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("7. Control flow, Mixu's Node book"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);