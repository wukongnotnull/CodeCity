(window.webpackJsonp=window.webpackJsonp||[]).push([[217],{656:function(e,t,v){"use strict";v.r(t);var a=v(25),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[e._v("#")]),e._v(" 事件")]),e._v(" "),v("h2",{attrs:{id:"eventtarget-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-接口"}},[e._v("#")]),e._v(" EventTarget 接口")]),e._v(" "),v("p",[e._v("事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。")]),e._v(" "),v("p",[e._v("介绍具体的事件之前，先来看看如何让 DOM 节点监听事件。")]),e._v(" "),v("h3",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("p",[e._v("DOM 节点的事件操作（监听和触发），都定义在"),v("code",[e._v("EventTarget")]),e._v("接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，"),v("code",[e._v("XMLHttpRequest")]),e._v("、"),v("code",[e._v("AudioNode")]),e._v("、"),v("code",[e._v("AudioContext")]),e._v("）也部署了这个接口。")]),e._v(" "),v("p",[e._v("该接口主要提供三个实例方法。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("addEventListener()")]),e._v("：绑定事件的监听函数")]),e._v(" "),v("li",[v("code",[e._v("removeEventListener()")]),e._v("：移除事件的监听函数")]),e._v(" "),v("li",[v("code",[e._v("dispatchEvent()")]),e._v("：触发事件")])]),e._v(" "),v("h3",{attrs:{id:"eventtarget-addeventlistener"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-addeventlistener"}},[e._v("#")]),e._v(" EventTarget.addEventListener()")]),e._v(" "),v("p",[v("code",[e._v("EventTarget.addEventListener()")]),e._v("用于在当前节点或对象上（即部署了 EventTarget 接口的对象），定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("target.addEventListener(type, listener[, useCapture]);\n")])])]),v("p",[e._v("该方法接受三个参数。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("type")]),e._v("：事件名称，大小写敏感。")]),e._v(" "),v("li",[v("code",[e._v("listener")]),e._v("：监听函数。事件发生时，会调用该监听函数。")]),e._v(" "),v("li",[v("code",[e._v("useCapture")]),e._v("：布尔值，如果设为"),v("code",[e._v("true")]),e._v("，表示监听函数将在捕获阶段（capture）触发（参见后文《事件的传播》部分）。该参数可选，默认值为"),v("code",[e._v("false")]),e._v("（监听函数只在冒泡阶段被触发）。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function hello() {\n  console.log('Hello world');\n}\n\nvar button = document.getElementById('btn');\nbutton.addEventListener('click', hello, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("button")]),e._v("节点的"),v("code",[e._v("addEventListener()")]),e._v("方法绑定"),v("code",[e._v("click")]),e._v("事件的监听函数"),v("code",[e._v("hello()")]),e._v("，该函数只在冒泡阶段触发。")]),e._v(" "),v("p",[e._v("关于参数，有两个地方需要注意。")]),e._v(" "),v("p",[e._v("首先，第二个参数除了监听函数，还可以是一个具有"),v("code",[e._v("handleEvent")]),e._v("方法的对象，效果与监听函数一样。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("buttonElement.addEventListener('click', {\n  handleEvent: function (event) {\n    console.log('click');\n  }\n});\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("addEventListener()")]),e._v("方法的第二个参数，就是一个具有"),v("code",[e._v("handleEvent()")]),e._v("方法的对象。")]),e._v(" "),v("p",[e._v("其次，第三个参数除了布尔值"),v("code",[e._v("useCapture")]),e._v("，还可以是一个监听器配置对象，定制事件监听行为。该对象有以下属性。")]),e._v(" "),v("blockquote",[v("ul",[v("li",[v("code",[e._v("capture")]),e._v("：布尔值，如果设为"),v("code",[e._v("true")]),e._v("，表示监听函数在捕获阶段触发，默认为"),v("code",[e._v("false")]),e._v("，在冒泡阶段触发。")]),e._v(" "),v("li",[v("code",[e._v("once")]),e._v("：布尔值，如果设为"),v("code",[e._v("true")]),e._v("，表示监听函数执行一次就会自动移除，后面将不再监听该事件。该属性默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("passive")]),e._v("：布尔值，设为"),v("code",[e._v("true")]),e._v("时，表示禁止监听函数调用"),v("code",[e._v("preventDefault()")]),e._v("方法。如果调用了，浏览器将忽略这个要求，并在控制台输出一条警告。该属性默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("signal")]),e._v("：该属性的值为一个 AbortSignal 对象，为监听器设置了一个信号通道，用来在需要时发出信号，移除监听函数。")])])]),e._v(" "),v("p",[e._v("下面是"),v("code",[e._v("once")]),e._v("属性的例子，让监听函数只执行一次。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("element.addEventListener('click', function (event) {\n  // 只执行一次的代码\n}, {once: true});\n")])])]),v("p",[v("code",[e._v("addEventListener()")]),e._v("方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用"),v("code",[e._v("removeEventListener()")]),e._v("方法手动去除）。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function hello() {\n  console.log('Hello world');\n}\n\ndocument.addEventListener('click', hello, false);\ndocument.addEventListener('click', hello, false);\n")])])]),v("p",[e._v("执行上面代码，点击文档只会输出一行"),v("code",[e._v("Hello world")]),e._v("。")]),e._v(" "),v("p",[e._v("如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function print(x) {\n  console.log(x);\n}\n\nvar el = document.getElementById('div1');\nel.addEventListener('click', function () { print('Hello'); }, false);\n")])])]),v("p",[e._v("上面代码通过匿名函数，向监听函数"),v("code",[e._v("print")]),e._v("传递了一个参数。")]),e._v(" "),v("p",[e._v("监听函数内部的"),v("code",[e._v("this")]),e._v("，指向当前事件所在的那个对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <p id=\"para\">Hello</p>\nvar para = document.getElementById('para');\npara.addEventListener('click', function (e) {\n  console.log(this.nodeName); // \"P\"\n}, false);\n")])])]),v("p",[e._v("上面代码中，监听函数内部的"),v("code",[e._v("this")]),e._v("指向事件所在的对象"),v("code",[e._v("para")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"eventtarget-removeeventlistener"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-removeeventlistener"}},[e._v("#")]),e._v(" EventTarget.removeEventListener()")]),e._v(" "),v("p",[v("code",[e._v("EventTarget.removeEventListener()")]),e._v("方法用来移除"),v("code",[e._v("addEventListener()")]),e._v("方法添加的事件监听函数。该方法没有返回值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('click', listener, false);\ndiv.removeEventListener('click', listener, false);\n")])])]),v("p",[v("code",[e._v("removeEventListener()")]),e._v("方法的参数，与"),v("code",[e._v("addEventListener()")]),e._v("方法完全一致。它的第一个参数“事件类型”，大小写敏感。")]),e._v(" "),v("p",[e._v("注意，"),v("code",[e._v("removeEventListener()")]),e._v("方法移除的监听函数，必须是"),v("code",[e._v("addEventListener()")]),e._v("方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('click', function (e) {}, false);\ndiv.removeEventListener('click', function (e) {}, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("removeEventListener()")]),e._v("方法无效，因为监听函数不是同一个匿名函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("element.addEventListener('mousedown', handleMouseDown, true);\nelement.removeEventListener(\"mousedown\", handleMouseDown, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("removeEventListener()")]),e._v("方法也是无效的，因为第三个参数不一样。")]),e._v(" "),v("h3",{attrs:{id:"eventtarget-dispatchevent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-dispatchevent"}},[e._v("#")]),e._v(" EventTarget.dispatchEvent()")]),e._v(" "),v("p",[v("code",[e._v("EventTarget.dispatchEvent()")]),e._v("方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了"),v("code",[e._v("Event.preventDefault()")]),e._v("，则返回值为"),v("code",[e._v("false")]),e._v("，否则为"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("target.dispatchEvent(event)\n")])])]),v("p",[v("code",[e._v("dispatchEvent()")]),e._v("方法的参数是一个"),v("code",[e._v("Event")]),e._v("对象的实例（详见《Event 对象》章节）。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("para.addEventListener('click', hello, false);\nvar event = new Event('click');\npara.dispatchEvent(event);\n")])])]),v("p",[e._v("上面代码在当前节点触发了"),v("code",[e._v("click")]),e._v("事件。")]),e._v(" "),v("p",[e._v("如果"),v("code",[e._v("dispatchEvent()")]),e._v("方法的参数为空，或者不是一个有效的事件对象，将报错。")]),e._v(" "),v("p",[e._v("下面代码根据"),v("code",[e._v("dispatchEvent()")]),e._v("方法的返回值，判断事件是否被取消了。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var canceled = !cb.dispatchEvent(event);\nif (canceled) {\n  console.log('事件取消');\n} else {\n  console.log('事件未取消');\n}\n")])])]),v("h2",{attrs:{id:"事件模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[e._v("#")]),e._v(" 事件模型")]),e._v(" "),v("h3",{attrs:{id:"监听函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#监听函数"}},[e._v("#")]),e._v(" 监听函数")]),e._v(" "),v("p",[e._v("浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。")]),e._v(" "),v("p",[e._v("JavaScript 有三种方法，可以为事件绑定监听函数。")]),e._v(" "),v("h4",{attrs:{id:"html-的-on-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html-的-on-属性"}},[e._v("#")]),e._v(" HTML 的 on- 属性")]),e._v(" "),v("p",[e._v("HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<body onload="doSomething()">\n<div onclick="console.log(\'触发事件\')">\n')])])]),v("p",[e._v("上面代码为"),v("code",[e._v("body")]),e._v("节点的"),v("code",[e._v("load")]),e._v("事件、"),v("code",[e._v("div")]),e._v("节点的"),v("code",[e._v("click")]),e._v("事件，指定了监听代码。一旦事件发生，就会执行这段代码。")]),e._v(" "),v("p",[e._v("元素的事件监听属性，都是"),v("code",[e._v("on")]),e._v("加上事件名，比如"),v("code",[e._v("onload")]),e._v("就是"),v("code",[e._v("on + load")]),e._v("，表示"),v("code",[e._v("load")]),e._v("事件的监听代码。")]),e._v(" "),v("p",[e._v("注意，这些属性的值是将会执行的代码，而不是一个函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('\x3c!-- 正确 --\x3e\n<body onload="doSomething()">\n\n\x3c!-- 错误 --\x3e\n<body onload="doSomething">\n')])])]),v("p",[e._v("一旦指定的事件发生，"),v("code",[e._v("on-")]),e._v("属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。")]),e._v(" "),v("p",[e._v("使用这个方法指定的监听代码，只会在冒泡阶段触发。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div onclick="console.log(2)">\n  <button onclick="console.log(1)">点击</button>\n</div>\n')])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("<button>")]),e._v("是"),v("code",[e._v("<div>")]),e._v("的子元素。"),v("code",[e._v("<button>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件，也会触发"),v("code",[e._v("<div>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件。由于"),v("code",[e._v("on-")]),e._v("属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出"),v("code",[e._v("1")]),e._v("，再输出"),v("code",[e._v("2")]),e._v("，即事件从子元素开始冒泡到父元素。")]),e._v(" "),v("p",[e._v("直接设置"),v("code",[e._v("on-")]),e._v("属性，与通过元素节点的"),v("code",[e._v("setAttribute")]),e._v("方法设置"),v("code",[e._v("on-")]),e._v("属性，效果是一样的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("el.setAttribute('onclick', 'doSomething()');\n// 等同于\n// <Element onclick=\"doSomething()\">\n")])])]),v("h4",{attrs:{id:"元素节点的事件属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#元素节点的事件属性"}},[e._v("#")]),e._v(" 元素节点的事件属性")]),e._v(" "),v("p",[e._v("元素节点对象的事件属性，同样可以指定监听函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.onload = doSomething;\n\ndiv.onclick = function (event) {\n  console.log('触发事件');\n};\n")])])]),v("p",[e._v("使用这个方法指定的监听函数，也是只会在冒泡阶段触发。")]),e._v(" "),v("p",[e._v("注意，这种方法与 HTML 的"),v("code",[e._v("on-")]),e._v("属性的差异是，它的值是函数名（"),v("code",[e._v("doSomething")]),e._v("），而不像后者，必须给出完整的监听代码（"),v("code",[e._v("doSomething()")]),e._v("）。")]),e._v(" "),v("h4",{attrs:{id:"eventtarget-addeventlistener-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-addeventlistener-2"}},[e._v("#")]),e._v(" EventTarget.addEventListener()")]),e._v(" "),v("p",[e._v("所有 DOM 节点实例都有"),v("code",[e._v("addEventListener")]),e._v("方法，用来为该节点定义事件的监听函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('load', doSomething, false);\n")])])]),v("p",[v("code",[e._v("addEventListener")]),e._v("方法的详细介绍，参见"),v("code",[e._v("EventTarget")]),e._v("章节。")]),e._v(" "),v("h4",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),v("p",[e._v("上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。")]),e._v(" "),v("p",[e._v("第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次"),v("code",[e._v("onclick")]),e._v("属性，后一次定义会覆盖前一次。因此，也不推荐使用。")]),e._v(" "),v("p",[e._v("第三种"),v("code",[e._v("EventTarget.addEventListener")]),e._v("是推荐的指定监听函数的方法。它有如下优点：")]),e._v(" "),v("ul",[v("li",[e._v("同一个事件可以添加多个监听函数。")]),e._v(" "),v("li",[e._v("能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。")]),e._v(" "),v("li",[e._v("除了 DOM 节点，其他对象（比如"),v("code",[e._v("window")]),e._v("、"),v("code",[e._v("XMLHttpRequest")]),e._v("等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。")])]),e._v(" "),v("h3",{attrs:{id:"this-的指向"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this-的指向"}},[e._v("#")]),e._v(" this 的指向")]),e._v(" "),v("p",[e._v("监听函数内部的"),v("code",[e._v("this")]),e._v("指向触发事件的那个元素节点。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<button id="btn" onclick="console.log(this.id)">点击</button>\n')])])]),v("p",[e._v("执行上面代码，点击后会输出"),v("code",[e._v("btn")]),e._v("。")]),e._v(" "),v("p",[e._v("其他两种监听函数的写法，"),v("code",[e._v("this")]),e._v("的指向也是如此。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <button id=\"btn\">点击</button>\nvar btn = document.getElementById('btn');\n\n// 写法一\nbtn.onclick = function () {\n  console.log(this.id);\n};\n\n// 写法二\nbtn.addEventListener(\n  'click',\n  function (e) {\n    console.log(this.id);\n  },\n  false\n);\n")])])]),v("p",[e._v("上面两种写法，点击按钮以后也是输出"),v("code",[e._v("btn")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"事件的传播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件的传播"}},[e._v("#")]),e._v(" 事件的传播")]),e._v(" "),v("p",[e._v("一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("第一阶段")]),e._v("：从"),v("code",[e._v("window")]),e._v("对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。")]),e._v(" "),v("li",[v("strong",[e._v("第二阶段")]),e._v("：在目标节点上触发，称为“目标阶段”（target phase）。")]),e._v(" "),v("li",[v("strong",[e._v("第三阶段")]),e._v("：从目标节点传导回"),v("code",[e._v("window")]),e._v("对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。")])]),e._v(" "),v("p",[e._v("这种三阶段的传播模型，使得同一个事件会在多个节点上触发。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<div>\n  <p>点击</p>\n</div>\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("<div>")]),e._v("节点之中有一个"),v("code",[e._v("<p>")]),e._v("节点。")]),e._v(" "),v("p",[e._v("如果对这两个节点，都设置"),v("code",[e._v("click")]),e._v("事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对"),v("code",[e._v("<p>")]),e._v("点击，"),v("code",[e._v("click")]),e._v("事件会触发四次。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var phases = {\n  1: 'capture',\n  2: 'target',\n  3: 'bubble'\n};\n\nvar div = document.querySelector('div');\nvar p = document.querySelector('p');\n\ndiv.addEventListener('click', callback, true);\np.addEventListener('click', callback, true);\ndiv.addEventListener('click', callback, false);\np.addEventListener('click', callback, false);\n\nfunction callback(event) {\n  var tag = event.currentTarget.tagName;\n  var phase = phases[event.eventPhase];\n  console.log(\"Tag: '\" + tag + \"'. EventPhase: '\" + phase + \"'\");\n}\n\n// 点击以后的结果\n// Tag: 'DIV'. EventPhase: 'capture'\n// Tag: 'P'. EventPhase: 'target'\n// Tag: 'P'. EventPhase: 'target'\n// Tag: 'DIV'. EventPhase: 'bubble'\n")])])]),v("p",[e._v("上面代码表示，"),v("code",[e._v("click")]),e._v("事件被触发了四次："),v("code",[e._v("<div>")]),e._v("节点的捕获阶段和冒泡阶段各1次，"),v("code",[e._v("<p>")]),e._v("节点的目标阶段触发了2次。")]),e._v(" "),v("ol",[v("li",[e._v("捕获阶段：事件从"),v("code",[e._v("<div>")]),e._v("向"),v("code",[e._v("<p>")]),e._v("传播时，触发"),v("code",[e._v("<div>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件；")]),e._v(" "),v("li",[e._v("目标阶段：事件从"),v("code",[e._v("<div>")]),e._v("到达"),v("code",[e._v("<p>")]),e._v("时，触发"),v("code",[e._v("<p>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件；")]),e._v(" "),v("li",[e._v("冒泡阶段：事件从"),v("code",[e._v("<p>")]),e._v("传回"),v("code",[e._v("<div>")]),e._v("时，再次触发"),v("code",[e._v("<div>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件。")])]),e._v(" "),v("p",[e._v("其中，"),v("code",[e._v("<p>")]),e._v("节点有两个监听函数（"),v("code",[e._v("addEventListener")]),e._v("方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为"),v("code",[e._v("click")]),e._v("事件触发一次。所以，"),v("code",[e._v("<p>")]),e._v("会在"),v("code",[e._v("target")]),e._v("阶段有两次输出。")]),e._v(" "),v("p",[e._v("注意，浏览器总是假定"),v("code",[e._v("click")]),e._v("事件的目标节点，就是点击位置嵌套最深的那个节点（本例是"),v("code",[e._v("<div>")]),e._v("节点里面的"),v("code",[e._v("<p>")]),e._v("节点）。所以，"),v("code",[e._v("<p>")]),e._v("节点的捕获阶段和冒泡阶段，都会显示为"),v("code",[e._v("target")]),e._v("阶段。")]),e._v(" "),v("p",[e._v("事件传播的最上层对象是"),v("code",[e._v("window")]),e._v("，接着依次是"),v("code",[e._v("document")]),e._v("，"),v("code",[e._v("html")]),e._v("（"),v("code",[e._v("document.documentElement")]),e._v("）和"),v("code",[e._v("body")]),e._v("（"),v("code",[e._v("document.body")]),e._v("）。也就是说，上例的事件传播顺序，在捕获阶段依次为"),v("code",[e._v("window")]),e._v("、"),v("code",[e._v("document")]),e._v("、"),v("code",[e._v("html")]),e._v("、"),v("code",[e._v("body")]),e._v("、"),v("code",[e._v("div")]),e._v("、"),v("code",[e._v("p")]),e._v("，在冒泡阶段依次为"),v("code",[e._v("p")]),e._v("、"),v("code",[e._v("div")]),e._v("、"),v("code",[e._v("body")]),e._v("、"),v("code",[e._v("html")]),e._v("、"),v("code",[e._v("document")]),e._v("、"),v("code",[e._v("window")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"事件的代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件的代理"}},[e._v("#")]),e._v(" 事件的代理")]),e._v(" "),v("p",[e._v("由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var ul = document.querySelector('ul');\n\nul.addEventListener('click', function (event) {\n  if (event.target.tagName.toLowerCase() === 'li') {\n    // some code\n  }\n});\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("click")]),e._v("事件的监听函数定义在"),v("code",[e._v("<ul>")]),e._v("节点，但是实际上，它处理的是子节点"),v("code",[e._v("<li>")]),e._v("的"),v("code",[e._v("click")]),e._v("事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个"),v("code",[e._v("<li>")]),e._v("节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。")]),e._v(" "),v("p",[e._v("如果希望事件到某个节点为止，不再传播，可以使用事件对象的"),v("code",[e._v("stopPropagation")]),e._v("方法。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// 事件传播到 p 元素后，就不再向下传播了\np.addEventListener('click', function (event) {\n  event.stopPropagation();\n}, true);\n\n// 事件冒泡到 p 元素后，就不再向上冒泡了\np.addEventListener('click', function (event) {\n  event.stopPropagation();\n}, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("stopPropagation")]),e._v("方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。")]),e._v(" "),v("p",[e._v("但是，"),v("code",[e._v("stopPropagation")]),e._v("方法只会阻止事件的传播，不会阻止该事件触发"),v("code",[e._v("<p>")]),e._v("节点的其他"),v("code",[e._v("click")]),e._v("事件的监听函数。也就是说，不是彻底取消"),v("code",[e._v("click")]),e._v("事件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("p.addEventListener('click', function (event) {\n  event.stopPropagation();\n  console.log(1);\n});\n\np.addEventListener('click', function(event) {\n  // 会触发\n  console.log(2);\n});\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("p")]),e._v("元素绑定了两个"),v("code",[e._v("click")]),e._v("事件的监听函数。"),v("code",[e._v("stopPropagation")]),e._v("方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。")]),e._v(" "),v("p",[e._v("如果想要彻底取消该事件，不再触发后面所有"),v("code",[e._v("click")]),e._v("的监听函数，可以使用"),v("code",[e._v("stopImmediatePropagation")]),e._v("方法。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("p.addEventListener('click', function (event) {\n  event.stopImmediatePropagation();\n  console.log(1);\n});\n\np.addEventListener('click', function(event) {\n  // 不会被触发\n  console.log(2);\n});\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("stopImmediatePropagation")]),e._v("方法可以彻底取消这个事件，使得后面绑定的所有"),v("code",[e._v("click")]),e._v("监听函数都不再触发。所以，只会输出1，不会输出2。")]),e._v(" "),v("h2",{attrs:{id:"event-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-对象"}},[e._v("#")]),e._v(" Event 对象")]),e._v(" "),v("h3",{attrs:{id:"概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("p",[e._v("事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个"),v("code",[e._v("Event")]),e._v("对象，所有的事件都是这个对象的实例，或者说继承了"),v("code",[e._v("Event.prototype")]),e._v("对象。")]),e._v(" "),v("p",[v("code",[e._v("Event")]),e._v("对象本身就是一个构造函数，可以用来生成新的实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("event = new Event(type, options);\n")])])]),v("p",[v("code",[e._v("Event")]),e._v("构造函数接受两个参数。第一个参数"),v("code",[e._v("type")]),e._v("是字符串，表示事件的名称；第二个参数"),v("code",[e._v("options")]),e._v("是一个对象，表示事件对象的配置。该对象主要有下面两个属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("bubbles")]),e._v("：布尔值，可选，默认为"),v("code",[e._v("false")]),e._v("，表示事件对象是否冒泡。")]),e._v(" "),v("li",[v("code",[e._v("cancelable")]),e._v("：布尔值，可选，默认为"),v("code",[e._v("false")]),e._v("，表示事件是否可以被取消，即能否用"),v("code",[e._v("Event.preventDefault()")]),e._v("取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var ev = new Event(\n  'look',\n  {\n    'bubbles': true,\n    'cancelable': false\n  }\n);\ndocument.dispatchEvent(ev);\n")])])]),v("p",[e._v("上面代码新建一个"),v("code",[e._v("look")]),e._v("事件实例，然后使用"),v("code",[e._v("dispatchEvent")]),e._v("方法触发该事件。")]),e._v(" "),v("p",[e._v("注意，如果不是显式指定"),v("code",[e._v("bubbles")]),e._v("属性为"),v("code",[e._v("true")]),e._v("，生成的事件就只能在“捕获阶段”触发监听函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <div><p>Hello</p></div>\nvar div = document.querySelector('div');\nvar p = document.querySelector('p');\n\nfunction callback(event) {\n  var tag = event.currentTarget.tagName;\n  console.log('Tag: ' + tag); // 没有任何输出\n}\n\ndiv.addEventListener('click', callback, false);\n\nvar click = new Event('click');\np.dispatchEvent(click);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("p")]),e._v("元素发出一个"),v("code",[e._v("click")]),e._v("事件，该事件默认不会冒泡。"),v("code",[e._v("div.addEventListener")]),e._v("方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成"),v("code",[e._v("div.addEventListener('click', callback, true)")]),e._v("，那么在“捕获阶段”可以监听到这个事件。")]),e._v(" "),v("p",[e._v("另一方面，如果这个事件在"),v("code",[e._v("div")]),e._v("元素上触发。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.dispatchEvent(click);\n")])])]),v("p",[e._v("那么，不管"),v("code",[e._v("div")]),e._v("元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时"),v("code",[e._v("div")]),e._v("元素是事件的目标，不存在是否冒泡的问题，"),v("code",[e._v("div")]),e._v("元素总是会接收到事件，因此导致监听函数生效。")]),e._v(" "),v("h3",{attrs:{id:"实例属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[e._v("#")]),e._v(" 实例属性")]),e._v(" "),v("h4",{attrs:{id:"event-bubbles-event-eventphase"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-bubbles-event-eventphase"}},[e._v("#")]),e._v(" Event.bubbles，Event.eventPhase")]),e._v(" "),v("p",[v("code",[e._v("Event.bubbles")]),e._v("属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，"),v("code",[e._v("Event")]),e._v("构造函数生成的事件，默认是不冒泡的。")]),e._v(" "),v("p",[v("code",[e._v("Event.eventPhase")]),e._v("属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var phase = event.eventPhase;\n")])])]),v("p",[v("code",[e._v("Event.eventPhase")]),e._v("的返回值有四种可能。")]),e._v(" "),v("ul",[v("li",[e._v("0，事件目前没有发生。")]),e._v(" "),v("li",[e._v("1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。")]),e._v(" "),v("li",[e._v("2，事件到达目标节点，即"),v("code",[e._v("Event.target")]),e._v("属性指向的那个节点。")]),e._v(" "),v("li",[e._v("3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。")])]),e._v(" "),v("h4",{attrs:{id:"event-cancelable-event-cancelbubble-event-defaultprevented"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-cancelable-event-cancelbubble-event-defaultprevented"}},[e._v("#")]),e._v(" Event.cancelable，Event.cancelBubble，event.defaultPrevented")]),e._v(" "),v("p",[v("code",[e._v("Event.cancelable")]),e._v("属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。")]),e._v(" "),v("p",[e._v("大多数浏览器的原生事件是可以取消的。比如，取消"),v("code",[e._v("click")]),e._v("事件，点击链接将无效。但是除非显式声明，"),v("code",[e._v("Event")]),e._v("构造函数生成的事件，默认是不可以取消的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var evt = new Event('foo');\nevt.cancelable  // false\n")])])]),v("p",[e._v("当"),v("code",[e._v("Event.cancelable")]),e._v("属性为"),v("code",[e._v("true")]),e._v("时，调用"),v("code",[e._v("Event.preventDefault()")]),e._v("就可以取消这个事件，阻止浏览器对该事件的默认行为。")]),e._v(" "),v("p",[e._v("如果事件不能取消，调用"),v("code",[e._v("Event.preventDefault()")]),e._v("会没有任何效果。所以使用这个方法之前，最好用"),v("code",[e._v("Event.cancelable")]),e._v("属性判断一下是否可以取消。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function preventEvent(event) {\n  if (event.cancelable) {\n    event.preventDefault();\n  } else {\n    console.warn('This event couldn\\'t be canceled.');\n    console.dir(event);\n  }\n}\n")])])]),v("p",[v("code",[e._v("Event.cancelBubble")]),e._v("属性是一个布尔值，如果设为"),v("code",[e._v("true")]),e._v("，相当于执行"),v("code",[e._v("Event.stopPropagation()")]),e._v("，可以阻止事件的传播。")]),e._v(" "),v("p",[v("code",[e._v("Event.defaultPrevented")]),e._v("属性返回一个布尔值，表示该事件是否调用过"),v("code",[e._v("Event.preventDefault")]),e._v("方法。该属性只读。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("if (event.defaultPrevented) {\n  console.log('该事件已经取消了');\n}\n")])])]),v("h4",{attrs:{id:"event-currenttarget-event-target"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-currenttarget-event-target"}},[e._v("#")]),e._v(" Event.currentTarget，Event.target")]),e._v(" "),v("p",[e._v("事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意事件都有两个与事件相关的节点，一个是事件的原始触发节点（"),v("code",[e._v("Event.target")]),e._v("），另一个是事件当前正在通过的节点（"),v("code",[e._v("Event.currentTarget")]),e._v("）。前者通常是后者的后代节点。")]),e._v(" "),v("p",[v("code",[e._v("Event.currentTarget")]),e._v("属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。")]),e._v(" "),v("p",[v("code",[e._v("Event.target")]),e._v("属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。")]),e._v(" "),v("p",[e._v("事件传播过程中，不同节点的监听函数内部的"),v("code",[e._v("Event.target")]),e._v("与"),v("code",[e._v("Event.currentTarget")]),e._v("属性的值是不一样的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <p id=\"para\">Hello <em>World</em></p>\nfunction hide(e) {\n  // 不管点击 Hello 或 World，总是返回 true\n  console.log(this === e.currentTarget);\n\n  // 点击 Hello，返回 true\n  // 点击 World，返回 false\n  console.log(this === e.target);\n}\n\ndocument.getElementById('para').addEventListener('click', hide, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("<em>")]),e._v("是"),v("code",[e._v("<p>")]),e._v("的子节点，点击"),v("code",[e._v("<em>")]),e._v("或者点击"),v("code",[e._v("<p>")]),e._v("，都会导致监听函数执行。这时，"),v("code",[e._v("e.target")]),e._v("总是指向原始点击位置的那个节点，而"),v("code",[e._v("e.currentTarget")]),e._v("指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以"),v("code",[e._v("e.currentTarget")]),e._v("总是等同于监听函数内部的"),v("code",[e._v("this")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"event-type"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-type"}},[e._v("#")]),e._v(" Event.type")]),e._v(" "),v("p",[v("code",[e._v("Event.type")]),e._v("属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var evt = new Event('foo');\nevt.type // \"foo\"\n")])])]),v("h4",{attrs:{id:"event-timestamp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-timestamp"}},[e._v("#")]),e._v(" Event.timeStamp")]),e._v(" "),v("p",[v("code",[e._v("Event.timeStamp")]),e._v("属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var evt = new Event('foo');\nevt.timeStamp // 3683.6999999995896\n")])])]),v("p",[e._v("它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。")]),e._v(" "),v("p",[e._v("下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var previousX;\nvar previousY;\nvar previousT;\n\nwindow.addEventListener('mousemove', function(event) {\n  if (\n    previousX !== undefined &&\n    previousY !== undefined &&\n    previousT !== undefined\n  ) {\n    var deltaX = event.screenX - previousX;\n    var deltaY = event.screenY - previousY;\n    var deltaD = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\n    var deltaT = event.timeStamp - previousT;\n    console.log(deltaD / deltaT * 1000);\n  }\n\n  previousX = event.screenX;\n  previousY = event.screenY;\n  previousT = event.timeStamp;\n});\n")])])]),v("h4",{attrs:{id:"event-istrusted"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-istrusted"}},[e._v("#")]),e._v(" Event.isTrusted")]),e._v(" "),v("p",[v("code",[e._v("Event.isTrusted")]),e._v("属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个"),v("code",[e._v("click")]),e._v("事件，该事件是用户产生的；"),v("code",[e._v("Event")]),e._v("构造函数生成的事件，则是脚本产生的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var evt = new Event('foo');\nevt.isTrusted // false\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("evt")]),e._v("对象是脚本产生的，所以"),v("code",[e._v("isTrusted")]),e._v("属性返回"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"event-detail"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-detail"}},[e._v("#")]),e._v(" Event.detail")]),e._v(" "),v("p",[v("code",[e._v("Event.detail")]),e._v("属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于"),v("code",[e._v("click")]),e._v("和"),v("code",[e._v("dblclick")]),e._v("事件，"),v("code",[e._v("Event.detail")]),e._v("是鼠标按下的次数（"),v("code",[e._v("1")]),e._v("表示单击，"),v("code",[e._v("2")]),e._v("表示双击，"),v("code",[e._v("3")]),e._v("表示三击）；对于鼠标滚轮事件，"),v("code",[e._v("Event.detail")]),e._v("是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <p>Hello</p>\nfunction giveDetails(e) {\n  console.log(e.detail);\n}\n\ndocument.querySelector('p').onclick = giveDetails;\n")])])]),v("h3",{attrs:{id:"实例方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[e._v("#")]),e._v(" 实例方法")]),e._v(" "),v("h4",{attrs:{id:"event-preventdefault"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-preventdefault"}},[e._v("#")]),e._v(" Event.preventDefault()")]),e._v(" "),v("p",[v("code",[e._v("Event.preventDefault")]),e._v("方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的"),v("code",[e._v("cancelable")]),e._v("属性为"),v("code",[e._v("true")]),e._v("，如果为"),v("code",[e._v("false")]),e._v("，调用该方法没有任何效果。")]),e._v(" "),v("p",[e._v("注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用"),v("code",[e._v("stopPropagation()")]),e._v("或"),v("code",[e._v("stopImmediatePropagation()")]),e._v("方法。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <input type=\"checkbox\" id=\"my-checkbox\" />\nvar cb = document.getElementById('my-checkbox');\n\ncb.addEventListener(\n  'click',\n  function (e){ e.preventDefault(); },\n  false\n);\n")])])]),v("p",[e._v("上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。")]),e._v(" "),v("p",[e._v("利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <input type=\"text\" id=\"my-input\" />\nvar input = document.getElementById('my-input');\ninput.addEventListener('keypress', checkName, false);\n\nfunction checkName(e) {\n  if (e.charCode < 97 || e.charCode > 122) {\n    e.preventDefault();\n  }\n}\n")])])]),v("p",[e._v("上面代码为文本框的"),v("code",[e._v("keypress")]),e._v("事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。")]),e._v(" "),v("h4",{attrs:{id:"event-stoppropagation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-stoppropagation"}},[e._v("#")]),e._v(" Event.stopPropagation()")]),e._v(" "),v("p",[v("code",[e._v("stopPropagation")]),e._v("方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function stopEvent(e) {\n  e.stopPropagation();\n}\n\nel.addEventListener('click', stopEvent, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("click")]),e._v("事件将不会进一步冒泡到"),v("code",[e._v("el")]),e._v("节点的父节点。")]),e._v(" "),v("h4",{attrs:{id:"event-stopimmediatepropagation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-stopimmediatepropagation"}},[e._v("#")]),e._v(" Event.stopImmediatePropagation()")]),e._v(" "),v("p",[v("code",[e._v("Event.stopImmediatePropagation")]),e._v("方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比"),v("code",[e._v("Event.stopPropagation()")]),e._v("更彻底。")]),e._v(" "),v("p",[e._v("如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了"),v("code",[e._v("Event.stopImmediatePropagation")]),e._v("方法，其他的监听函数就不会再执行了。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function l1(e){\n  e.stopImmediatePropagation();\n}\n\nfunction l2(e){\n  console.log('hello world');\n}\n\nel.addEventListener('click', l1, false);\nel.addEventListener('click', l2, false);\n")])])]),v("p",[e._v("上面代码在"),v("code",[e._v("el")]),e._v("节点上，为"),v("code",[e._v("click")]),e._v("事件添加了两个监听函数"),v("code",[e._v("l1")]),e._v("和"),v("code",[e._v("l2")]),e._v("。由于"),v("code",[e._v("l1")]),e._v("调用了"),v("code",[e._v("event.stopImmediatePropagation")]),e._v("方法，所以"),v("code",[e._v("l2")]),e._v("不会被调用。")]),e._v(" "),v("h4",{attrs:{id:"event-composedpath"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-composedpath"}},[e._v("#")]),e._v(" Event.composedPath()")]),e._v(" "),v("p",[v("code",[e._v("Event.composedPath()")]),e._v("返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <div>\n//   <p>Hello</p>\n// </div>\nvar div = document.querySelector('div');\nvar p = document.querySelector('p');\n\ndiv.addEventListener('click', function (e) {\n  console.log(e.composedPath());\n}, false);\n// [p, div, body, html, document, Window]\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("click")]),e._v("事件的最底层节点是"),v("code",[e._v("p")]),e._v("，向上依次是"),v("code",[e._v("div")]),e._v("、"),v("code",[e._v("body")]),e._v("、"),v("code",[e._v("html")]),e._v("、"),v("code",[e._v("document")]),e._v("、"),v("code",[e._v("Window")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"鼠标事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#鼠标事件"}},[e._v("#")]),e._v(" 鼠标事件")]),e._v(" "),v("h3",{attrs:{id:"鼠标事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#鼠标事件的种类"}},[e._v("#")]),e._v(" 鼠标事件的种类")]),e._v(" "),v("p",[e._v("鼠标事件主要有下面这些，所有事件都继承了"),v("code",[e._v("MouseEvent")]),e._v("接口（详见后文）。")]),e._v(" "),v("p",[e._v("（1）点击事件")]),e._v(" "),v("p",[e._v("鼠标点击相关的有四个事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("click")]),e._v("：按下鼠标（通常是按下主按钮）时触发。")]),e._v(" "),v("li",[v("code",[e._v("dblclick")]),e._v("：在同一个元素上双击鼠标时触发。")]),e._v(" "),v("li",[v("code",[e._v("mousedown")]),e._v("：按下鼠标键时触发。")]),e._v(" "),v("li",[v("code",[e._v("mouseup")]),e._v("：释放按下的鼠标键时触发。")])]),e._v(" "),v("p",[v("code",[e._v("click")]),e._v("事件可以看成是两个事件组成的：用户在同一个位置先触发"),v("code",[e._v("mousedown")]),e._v("，再触发"),v("code",[e._v("mouseup")]),e._v("。因此，触发顺序是，"),v("code",[e._v("mousedown")]),e._v("首先触发，"),v("code",[e._v("mouseup")]),e._v("接着触发，"),v("code",[e._v("click")]),e._v("最后触发。")]),e._v(" "),v("p",[e._v("双击时，"),v("code",[e._v("dblclick")]),e._v("事件则会在"),v("code",[e._v("mousedown")]),e._v("、"),v("code",[e._v("mouseup")]),e._v("、"),v("code",[e._v("click")]),e._v("之后触发。")]),e._v(" "),v("p",[e._v("（2）移动事件")]),e._v(" "),v("p",[e._v("鼠标移动相关的有五个事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("mousemove")]),e._v("：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。")]),e._v(" "),v("li",[v("code",[e._v("mouseenter")]),e._v("：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。")]),e._v(" "),v("li",[v("code",[e._v("mouseover")]),e._v("：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。")]),e._v(" "),v("li",[v("code",[e._v("mouseout")]),e._v("：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。")]),e._v(" "),v("li",[v("code",[e._v("mouseleave")]),e._v("：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。")])]),e._v(" "),v("p",[v("code",[e._v("mouseover")]),e._v("事件和"),v("code",[e._v("mouseenter")]),e._v("事件，都是鼠标进入一个节点时触发。两者的区别是，"),v("code",[e._v("mouseenter")]),e._v("事件只触发一次，而只要鼠标在节点内部移动，"),v("code",[e._v("mouseover")]),e._v("事件会在子节点上触发多次。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n <ul>\n   <li>item 1</li>\n   <li>item 2</li>\n   <li>item 3</li>\n </ul>\n*/\n\nvar ul = document.querySelector('ul');\n\n// 进入 ul 节点以后，mouseenter 事件只会触发一次\n// 以后只要鼠标在节点内移动，都不会再触发这个事件\n// event.target 是 ul 节点\nul.addEventListener('mouseenter', function (event) {\n  event.target.style.color = 'purple';\n  setTimeout(function () {\n    event.target.style.color = '';\n  }, 500);\n}, false);\n\n// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次\n// event.target 是 li 节点\nul.addEventListener('mouseover', function (event) {\n  event.target.style.color = 'orange';\n  setTimeout(function () {\n    event.target.style.color = '';\n  }, 500);\n}, false);\n")])])]),v("p",[e._v("上面代码中，在父节点内部进入子节点，不会触发"),v("code",[e._v("mouseenter")]),e._v("事件，但是会触发"),v("code",[e._v("mouseover")]),e._v("事件。")]),e._v(" "),v("p",[v("code",[e._v("mouseout")]),e._v("事件和"),v("code",[e._v("mouseleave")]),e._v("事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，"),v("code",[e._v("mouseleave")]),e._v("事件不会触发，而"),v("code",[e._v("mouseout")]),e._v("事件会触发。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n <ul>\n   <li>item 1</li>\n   <li>item 2</li>\n   <li>item 3</li>\n </ul>\n*/\n\nvar ul = document.querySelector('ul');\n\n// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件\n// 只有离开 ul 节点时，触发一次 mouseleave\n// event.target 是 ul 节点\nul.addEventListener('mouseleave', function (event) {\n  event.target.style.color = 'purple';\n  setTimeout(function () {\n    event.target.style.color = '';\n  }, 500);\n}, false);\n\n// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次\n// event.target 是 li 节点\nul.addEventListener('mouseout', function (event) {\n  event.target.style.color = 'orange';\n  setTimeout(function () {\n    event.target.style.color = '';\n  }, 500);\n}, false);\n")])])]),v("p",[e._v("上面代码中，在父节点内部离开子节点，不会触发"),v("code",[e._v("mouseleave")]),e._v("事件，但是会触发"),v("code",[e._v("mouseout")]),e._v("事件。")]),e._v(" "),v("p",[e._v("（3）其他事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("contextmenu")]),e._v("：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。")]),e._v(" "),v("li",[v("code",[e._v("wheel")]),e._v("：滚动鼠标的滚轮时触发，该事件继承的是"),v("code",[e._v("WheelEvent")]),e._v("接口。")])]),e._v(" "),v("h3",{attrs:{id:"mouseevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-接口"}},[e._v("#")]),e._v(" MouseEvent 接口")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent")]),e._v("接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是"),v("code",[e._v("MouseEvent")]),e._v("实例。此外，滚轮事件和拖拉事件也是"),v("code",[e._v("MouseEvent")]),e._v("实例。")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent")]),e._v("接口继承了"),v("code",[e._v("Event")]),e._v("接口，所以拥有"),v("code",[e._v("Event")]),e._v("的所有属性和方法，并且还提供鼠标独有的属性和方法。")]),e._v(" "),v("p",[e._v("浏览器原生提供一个"),v("code",[e._v("MouseEvent()")]),e._v("构造函数，用于新建一个"),v("code",[e._v("MouseEvent")]),e._v("实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var event = new MouseEvent(type, options);\n")])])]),v("p",[v("code",[e._v("MouseEvent()")]),e._v("构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了"),v("code",[e._v("Event")]),e._v("接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("screenX")]),e._v("：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。")]),e._v(" "),v("li",[v("code",[e._v("screenY")]),e._v("：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与"),v("code",[e._v("screenX")]),e._v("相同。")]),e._v(" "),v("li",[v("code",[e._v("clientX")]),e._v("：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。")]),e._v(" "),v("li",[v("code",[e._v("clientY")]),e._v("：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与"),v("code",[e._v("clientX")]),e._v("相同。")]),e._v(" "),v("li",[v("code",[e._v("ctrlKey")]),e._v("：布尔值，是否同时按下了 Ctrl 键，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("shiftKey")]),e._v("：布尔值，是否同时按下了 Shift 键，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("altKey")]),e._v("：布尔值，是否同时按下 Alt 键，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("metaKey")]),e._v("：布尔值，是否同时按下 Meta 键，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("button")]),e._v("：数值，表示按下了哪一个鼠标按键，默认值为"),v("code",[e._v("0")]),e._v("，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；"),v("code",[e._v("1")]),e._v("表示按下辅助键（通常是鼠标的中间键），"),v("code",[e._v("2")]),e._v("表示按下次要键（通常是鼠标的右键）。")]),e._v(" "),v("li",[v("code",[e._v("buttons")]),e._v("：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为"),v("code",[e._v("0")]),e._v("（没有按下任何键）。"),v("code",[e._v("1")]),e._v("（二进制"),v("code",[e._v("001")]),e._v("）表示按下主键（通常是左键），"),v("code",[e._v("2")]),e._v("（二进制"),v("code",[e._v("010")]),e._v("）表示按下次要键（通常是右键），"),v("code",[e._v("4")]),e._v("（二进制"),v("code",[e._v("100")]),e._v("）表示按下辅助键（通常是中间键）。因此，如果返回"),v("code",[e._v("3")]),e._v("（二进制"),v("code",[e._v("011")]),e._v("）就表示同时按下了左键和右键。")]),e._v(" "),v("li",[v("code",[e._v("relatedTarget")]),e._v("：节点对象，表示事件的相关节点，默认为"),v("code",[e._v("null")]),e._v("。"),v("code",[e._v("mouseenter")]),e._v("和"),v("code",[e._v("mouseover")]),e._v("事件时，表示鼠标刚刚离开的那个元素节点；"),v("code",[e._v("mouseout")]),e._v("和"),v("code",[e._v("mouseleave")]),e._v("事件时，表示鼠标正在进入的那个元素节点。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function simulateClick() {\n  var event = new MouseEvent('click', {\n    'bubbles': true,\n    'cancelable': true\n  });\n  var cb = document.getElementById('checkbox');\n  cb.dispatchEvent(event);\n}\n")])])]),v("p",[e._v("上面代码生成一个鼠标点击事件，并触发该事件。")]),e._v(" "),v("h3",{attrs:{id:"mouseevent-接口的实例属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-接口的实例属性"}},[e._v("#")]),e._v(" MouseEvent 接口的实例属性")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-altkey-mouseevent-ctrlkey-mouseevent-metakey-mouseevent-shiftkey"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-altkey-mouseevent-ctrlkey-mouseevent-metakey-mouseevent-shiftkey"}},[e._v("#")]),e._v(" MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.altKey")]),e._v("、"),v("code",[e._v("MouseEvent.ctrlKey")]),e._v("、"),v("code",[e._v("MouseEvent.metaKey")]),e._v("、"),v("code",[e._v("MouseEvent.shiftKey")]),e._v("这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("altKey")]),e._v("属性：Alt 键")]),e._v(" "),v("li",[v("code",[e._v("ctrlKey")]),e._v("属性：Ctrl 键")]),e._v(" "),v("li",[v("code",[e._v("metaKey")]),e._v("属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）")]),e._v(" "),v("li",[v("code",[e._v("shiftKey")]),e._v("属性：Shift 键")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <body onclick=\"showKey(event)\">\nfunction showKey(e) {\n  console.log('ALT key pressed: ' + e.altKey);\n  console.log('CTRL key pressed: ' + e.ctrlKey);\n  console.log('META key pressed: ' + e.metaKey);\n  console.log('SHIFT key pressed: ' + e.shiftKey);\n}\n")])])]),v("p",[e._v("上面代码中，点击网页会输出是否同时按下对应的键。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-button-mouseevent-buttons"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-button-mouseevent-buttons"}},[e._v("#")]),e._v(" MouseEvent.button，MouseEvent.buttons")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.button")]),e._v("属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。")]),e._v(" "),v("ul",[v("li",[e._v("0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如"),v("code",[e._v("mousemove")]),e._v("事件）。")]),e._v(" "),v("li",[e._v("1：按下辅助键（通常是中键或者滚轮键）。")]),e._v(" "),v("li",[e._v("2：按下次键（通常是右键）。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <button onmouseup=\"whichButton(event)\">点击</button>\nvar whichButton = function (e) {\n  switch (e.button) {\n    case 0:\n      console.log('Left button clicked.');\n      break;\n    case 1:\n      console.log('Middle button clicked.');\n      break;\n    case 2:\n      console.log('Right button clicked.');\n      break;\n    default:\n      console.log('Unexpected code: ' + e.button);\n  }\n}\n")])])]),v("p",[v("code",[e._v("MouseEvent.buttons")]),e._v("属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。")]),e._v(" "),v("ul",[v("li",[e._v("1：二进制为"),v("code",[e._v("001")]),e._v("（十进制的1），表示按下左键。")]),e._v(" "),v("li",[e._v("2：二进制为"),v("code",[e._v("010")]),e._v("（十进制的2），表示按下右键。")]),e._v(" "),v("li",[e._v("4：二进制为"),v("code",[e._v("100")]),e._v("（十进制的4），表示按下中键或滚轮键。")])]),e._v(" "),v("p",[e._v("同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-clientx-mouseevent-clienty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-clientx-mouseevent-clienty"}},[e._v("#")]),e._v(" MouseEvent.clientX，MouseEvent.clientY")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.clientX")]),e._v("属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），"),v("code",[e._v("MouseEvent.clientY")]),e._v("属性返回垂直坐标。这两个属性都是只读属性。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码为\n// <body onmousedown=\"showCoords(event)\">\nfunction showCoords(evt){\n  console.log(\n    'clientX value: ' + evt.clientX + '\\n' +\n    'clientY value: ' + evt.clientY + '\\n'\n  );\n}\n")])])]),v("p",[e._v("这两个属性还分别有一个别名"),v("code",[e._v("MouseEvent.x")]),e._v("和"),v("code",[e._v("MouseEvent.y")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-movementx-mouseevent-movementy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-movementx-mouseevent-movementy"}},[e._v("#")]),e._v(" MouseEvent.movementX，MouseEvent.movementY")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.movementX")]),e._v("属性返回当前位置与上一个"),v("code",[e._v("mousemove")]),e._v("事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("currentEvent.movementX = currentEvent.screenX - previousEvent.screenX\n")])])]),v("p",[v("code",[e._v("MouseEvent.movementY")]),e._v("属性返回当前位置与上一个"),v("code",[e._v("mousemove")]),e._v("事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。\n")])])]),v("p",[e._v("这两个属性都是只读属性。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-screenx-mouseevent-screeny"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-screenx-mouseevent-screeny"}},[e._v("#")]),e._v(" MouseEvent.screenX，MouseEvent.screenY")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.screenX")]),e._v("属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），"),v("code",[e._v("MouseEvent.screenY")]),e._v("属性返回垂直坐标。这两个属性都是只读属性。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <body onmousedown=\"showCoords(event)\">\nfunction showCoords(evt) {\n  console.log(\n    'screenX value: ' + evt.screenX + '\\n',\n    'screenY value: ' + evt.screenY + '\\n'\n  );\n}\n")])])]),v("h4",{attrs:{id:"mouseevent-offsetx-mouseevent-offsety"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-offsetx-mouseevent-offsety"}},[e._v("#")]),e._v(" MouseEvent.offsetX，MouseEvent.offsetY")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.offsetX")]),e._v("属性返回鼠标位置与目标节点左侧的"),v("code",[e._v("padding")]),e._v("边缘的水平距离（单位像素），"),v("code",[e._v("MouseEvent.offsetY")]),e._v("属性返回与目标节点上方的"),v("code",[e._v("padding")]),e._v("边缘的垂直距离。这两个属性都是只读属性。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n  <style>\n    p {\n      width: 100px;\n      height: 100px;\n      padding: 100px;\n    }\n  </style>\n  <p>Hello</p>\n*/\nvar p = document.querySelector('p');\np.addEventListener(\n  'click',\n  function (e) {\n    console.log(e.offsetX);\n    console.log(e.offsetY);\n  },\n  false\n);\n")])])]),v("p",[e._v("上面代码中，鼠标如果在"),v("code",[e._v("p")]),e._v("元素的中心位置点击，会返回"),v("code",[e._v("150 150")]),e._v("。因此中心位置距离左侧和上方的"),v("code",[e._v("padding")]),e._v("边缘，等于"),v("code",[e._v("padding")]),e._v("的宽度（100像素）加上元素内容区域一半的宽度（50像素）。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-pagex-mouseevent-pagey"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-pagex-mouseevent-pagey"}},[e._v("#")]),e._v(" MouseEvent.pageX，MouseEvent.pageY")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.pageX")]),e._v("属性返回鼠标位置与文档左侧边缘的距离（单位像素），"),v("code",[e._v("MouseEvent.pageY")]),e._v("属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n  <style>\n    body {\n      height: 2000px;\n    }\n  </style>\n*/\ndocument.body.addEventListener(\n  'click',\n  function (e) {\n    console.log(e.pageX);\n    console.log(e.pageY);\n  },\n  false\n);\n")])])]),v("p",[e._v("上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的"),v("code",[e._v("pageY")]),e._v("值会接近2000。")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-relatedtarget"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-relatedtarget"}},[e._v("#")]),e._v(" MouseEvent.relatedTarget")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.relatedTarget")]),e._v("属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回"),v("code",[e._v("null")]),e._v("。该属性只读。")]),e._v(" "),v("p",[e._v("下表列出不同事件的"),v("code",[e._v("target")]),e._v("属性值和"),v("code",[e._v("relatedTarget")]),e._v("属性值义。")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("事件名称")]),e._v(" "),v("th",[e._v("target 属性")]),e._v(" "),v("th",[e._v("relatedTarget 属性")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("focusin")]),e._v(" "),v("td",[e._v("接受焦点的节点")]),e._v(" "),v("td",[e._v("丧失焦点的节点")])]),e._v(" "),v("tr",[v("td",[e._v("focusout")]),e._v(" "),v("td",[e._v("丧失焦点的节点")]),e._v(" "),v("td",[e._v("接受焦点的节点")])]),e._v(" "),v("tr",[v("td",[e._v("mouseenter")]),e._v(" "),v("td",[e._v("将要进入的节点")]),e._v(" "),v("td",[e._v("将要离开的节点")])]),e._v(" "),v("tr",[v("td",[e._v("mouseleave")]),e._v(" "),v("td",[e._v("将要离开的节点")]),e._v(" "),v("td",[e._v("将要进入的节点")])]),e._v(" "),v("tr",[v("td",[e._v("mouseout")]),e._v(" "),v("td",[e._v("将要离开的节点")]),e._v(" "),v("td",[e._v("将要进入的节点")])]),e._v(" "),v("tr",[v("td",[e._v("mouseover")]),e._v(" "),v("td",[e._v("将要进入的节点")]),e._v(" "),v("td",[e._v("将要离开的节点")])]),e._v(" "),v("tr",[v("td",[e._v("dragenter")]),e._v(" "),v("td",[e._v("将要进入的节点")]),e._v(" "),v("td",[e._v("将要离开的节点")])]),e._v(" "),v("tr",[v("td",[e._v("dragexit")]),e._v(" "),v("td",[e._v("将要离开的节点")]),e._v(" "),v("td",[e._v("将要进入的节点")])])])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/*\n  HTML 代码如下\n  <div id=\"outer\" style=\"height:50px;width:50px;border:1px solid black;\">\n    <div id=\"inner\" style=\"height:25px;width:25px;border:1px solid black;\"></div>\n  </div>\n*/\n\nvar inner = document.getElementById('inner');\ninner.addEventListener('mouseover', function (event) {\n  console.log('进入' + event.target.id + ' 离开' + event.relatedTarget.id);\n}, false);\ninner.addEventListener('mouseenter', function (event) {\n  console.log('进入' + event.target.id + ' 离开' + event.relatedTarget.id);\n});\ninner.addEventListener('mouseout', function (event) {\n  console.log('离开' + event.target.id + ' 进入' + event.relatedTarget.id);\n});\ninner.addEventListener(\"mouseleave\", function (event){\n  console.log('离开' + event.target.id + ' 进入' + event.relatedTarget.id);\n});\n\n// 鼠标从 outer 进入inner，输出\n// 进入inner 离开outer\n// 进入inner 离开outer\n\n// 鼠标从 inner进入 outer，输出\n// 离开inner 进入outer\n// 离开inner 进入outer\n")])])]),v("h3",{attrs:{id:"mouseevent-接口的实例方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-接口的实例方法"}},[e._v("#")]),e._v(" MouseEvent 接口的实例方法")]),e._v(" "),v("h4",{attrs:{id:"mouseevent-getmodifierstate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent-getmodifierstate"}},[e._v("#")]),e._v(" MouseEvent.getModifierState()")]),e._v(" "),v("p",[v("code",[e._v("MouseEvent.getModifierState")]),e._v("方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示"),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko",target:"_blank",rel:"noopener noreferrer"}},[e._v("功能键"),v("OutboundLink")],1),e._v("的字符串。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.addEventListener('click', function (e) {\n  console.log(e.getModifierState('CapsLock'));\n}, false);\n")])])]),v("p",[e._v("上面的代码可以了解用户是否按下了大写键。")]),e._v(" "),v("h3",{attrs:{id:"wheelevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#wheelevent-接口"}},[e._v("#")]),e._v(" WheelEvent 接口")]),e._v(" "),v("h4",{attrs:{id:"概述-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("p",[e._v("WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个"),v("code",[e._v("wheel")]),e._v("事件，用户滚动鼠标的滚轮，就生成这个事件的实例。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("WheelEvent()")]),e._v("构造函数，用来生成"),v("code",[e._v("WheelEvent")]),e._v("实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var wheelEvent = new WheelEvent(type, options);\n")])])]),v("p",[v("code",[e._v("WheelEvent()")]),e._v("构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是"),v("code",[e._v("wheel")]),e._v("。第二个参数是事件的配置对象。该对象的属性除了"),v("code",[e._v("Event")]),e._v("、"),v("code",[e._v("UIEvent")]),e._v("的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("deltaX")]),e._v("：数值，表示滚轮的水平滚动量，默认值是 0.0。")]),e._v(" "),v("li",[v("code",[e._v("deltaY")]),e._v("：数值，表示滚轮的垂直滚动量，默认值是 0.0。")]),e._v(" "),v("li",[v("code",[e._v("deltaZ")]),e._v("：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。")]),e._v(" "),v("li",[v("code",[e._v("deltaMode")]),e._v("：数值，表示相关的滚动事件的单位，适用于上面三个属性。"),v("code",[e._v("0")]),e._v("表示滚动单位为像素，"),v("code",[e._v("1")]),e._v("表示单位为行，"),v("code",[e._v("2")]),e._v("表示单位为页，默认为"),v("code",[e._v("0")]),e._v("。")])]),e._v(" "),v("h4",{attrs:{id:"实例属性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例属性-2"}},[e._v("#")]),e._v(" 实例属性")]),e._v(" "),v("p",[v("code",[e._v("WheelEvent")]),e._v("事件实例除了具有"),v("code",[e._v("Event")]),e._v("和"),v("code",[e._v("MouseEvent")]),e._v("的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。")]),e._v(" "),v("p",[e._v("下面的属性都是只读属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("WheelEvent.deltaX")]),e._v("：数值，表示滚轮的水平滚动量。")]),e._v(" "),v("li",[v("code",[e._v("WheelEvent.deltaY")]),e._v("：数值，表示滚轮的垂直滚动量。")]),e._v(" "),v("li",[v("code",[e._v("WheelEvent.deltaZ")]),e._v("：数值，表示滚轮的 Z 轴滚动量。")]),e._v(" "),v("li",[v("code",[e._v("WheelEvent.deltaMode")]),e._v("：数值，表示上面三个属性的单位，"),v("code",[e._v("0")]),e._v("是像素，"),v("code",[e._v("1")]),e._v("是行，"),v("code",[e._v("2")]),e._v("是页。")])]),e._v(" "),v("h2",{attrs:{id:"键盘事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#键盘事件"}},[e._v("#")]),e._v(" 键盘事件")]),e._v(" "),v("h3",{attrs:{id:"键盘事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#键盘事件的种类"}},[e._v("#")]),e._v(" 键盘事件的种类")]),e._v(" "),v("p",[e._v("键盘事件由用户击打键盘触发，主要有"),v("code",[e._v("keydown")]),e._v("、"),v("code",[e._v("keypress")]),e._v("、"),v("code",[e._v("keyup")]),e._v("三个事件，它们都继承了"),v("code",[e._v("KeyboardEvent")]),e._v("接口。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("keydown")]),e._v("：按下键盘时触发。")]),e._v(" "),v("li",[v("code",[e._v("keypress")]),e._v("：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发"),v("code",[e._v("keydown")]),e._v("事件，再触发这个事件。")]),e._v(" "),v("li",[v("code",[e._v("keyup")]),e._v("：松开键盘时触发该事件。")])]),e._v(" "),v("p",[e._v("如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。")]),e._v(" "),v("ol",[v("li",[e._v("keydown")]),e._v(" "),v("li",[e._v("keypress")]),e._v(" "),v("li",[e._v("keydown")]),e._v(" "),v("li",[e._v("keypress")]),e._v(" "),v("li",[e._v("...（重复以上过程）")]),e._v(" "),v("li",[e._v("keyup")])]),e._v(" "),v("h3",{attrs:{id:"keyboardevent-接口概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-接口概述"}},[e._v("#")]),e._v(" KeyboardEvent 接口概述")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent")]),e._v("接口用来描述用户与键盘的互动。这个接口继承了"),v("code",[e._v("Event")]),e._v("接口，并且定义了自己的实例属性和实例方法。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("KeyboardEvent")]),e._v("构造函数，用来新建键盘事件的实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new KeyboardEvent(type, options)\n")])])]),v("p",[v("code",[e._v("KeyboardEvent")]),e._v("构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了"),v("code",[e._v("Event")]),e._v("接口提供的属性，还可以配置以下字段，它们都是可选。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("key")]),e._v("：字符串，当前按下的键，默认为空字符串。")]),e._v(" "),v("li",[v("code",[e._v("code")]),e._v("：字符串，表示当前按下的键的字符串形式，默认为空字符串。")]),e._v(" "),v("li",[v("code",[e._v("location")]),e._v("：整数，当前按下的键的位置，默认为"),v("code",[e._v("0")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("ctrlKey")]),e._v("：布尔值，是否按下 Ctrl 键，默认为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("shiftKey")]),e._v("：布尔值，是否按下 Shift 键，默认为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("altKey")]),e._v("：布尔值，是否按下 Alt 键，默认为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("metaKey")]),e._v("：布尔值，是否按下 Meta 键，默认为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("repeat")]),e._v("：布尔值，是否重复按键，默认为"),v("code",[e._v("false")]),e._v("。")])]),e._v(" "),v("h3",{attrs:{id:"keyboardevent-的实例属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-的实例属性"}},[e._v("#")]),e._v(" KeyboardEvent 的实例属性")]),e._v(" "),v("h4",{attrs:{id:"keyboardevent-altkey-keyboardevent-ctrlkey-keyboardevent-metakey-keyboardevent-shiftkey"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-altkey-keyboardevent-ctrlkey-keyboardevent-metakey-keyboardevent-shiftkey"}},[e._v("#")]),e._v(" KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey")]),e._v(" "),v("p",[e._v("以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("KeyboardEvent.altKey")]),e._v("：是否按下 Alt 键")]),e._v(" "),v("li",[v("code",[e._v("KeyboardEvent.ctrlKey")]),e._v("：是否按下 Ctrl 键")]),e._v(" "),v("li",[v("code",[e._v("KeyboardEvent.metaKey")]),e._v("：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）")]),e._v(" "),v("li",[v("code",[e._v("KeyboardEvent.shiftKey")]),e._v("：是否按下 Shift 键")])]),e._v(" "),v("p",[e._v("下面是一个示例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function showChar(e) {\n  console.log('ALT: ' + e.altKey);\n  console.log('CTRL: ' + e.ctrlKey);\n  console.log('Meta: ' + e.metaKey);\n  console.log('Shift: ' + e.shiftKey);\n}\n\ndocument.body.addEventListener('keydown', showChar, false);\n")])])]),v("h4",{attrs:{id:"keyboardevent-code"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-code"}},[e._v("#")]),e._v(" KeyboardEvent.code")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent.code")]),e._v("属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。")]),e._v(" "),v("p",[e._v("下面是一些常用键的字符串形式，其他键请查"),v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("ul",[v("li",[e._v("数字键0 - 9：返回"),v("code",[e._v("digit0")]),e._v(" - "),v("code",[e._v("digit9")])]),e._v(" "),v("li",[e._v("字母键A - z：返回"),v("code",[e._v("KeyA")]),e._v(" - "),v("code",[e._v("KeyZ")])]),e._v(" "),v("li",[e._v("功能键F1 - F12：返回 "),v("code",[e._v("F1")]),e._v(" - "),v("code",[e._v("F12")])]),e._v(" "),v("li",[e._v("方向键：返回"),v("code",[e._v("ArrowDown")]),e._v("、"),v("code",[e._v("ArrowUp")]),e._v("、"),v("code",[e._v("ArrowLeft")]),e._v("、"),v("code",[e._v("ArrowRight")])]),e._v(" "),v("li",[e._v("Alt 键：返回"),v("code",[e._v("AltLeft")]),e._v("或"),v("code",[e._v("AltRight")])]),e._v(" "),v("li",[e._v("Shift 键：返回"),v("code",[e._v("ShiftLeft")]),e._v("或"),v("code",[e._v("ShiftRight")])]),e._v(" "),v("li",[e._v("Ctrl 键：返回"),v("code",[e._v("ControlLeft")]),e._v("或"),v("code",[e._v("ControlRight")])])]),e._v(" "),v("h4",{attrs:{id:"keyboardevent-key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-key"}},[e._v("#")]),e._v(" KeyboardEvent.key")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent.key")]),e._v("属性返回一个字符串，表示按下的键名。该属性只读。")]),e._v(" "),v("p",[e._v("如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。")]),e._v(" "),v("p",[e._v("如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。")]),e._v(" "),v("p",[e._v("如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回"),v("code",[e._v("a")]),e._v("；按下 Shift + a，则返回大写的"),v("code",[e._v("A")]),e._v("。")]),e._v(" "),v("p",[e._v("如果无法识别键名，返回字符串"),v("code",[e._v("Unidentified")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"keyboardevent-location"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-location"}},[e._v("#")]),e._v(" KeyboardEvent.location")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent.location")]),e._v("属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。")]),e._v(" "),v("ul",[v("li",[e._v("0：处在键盘的主区域，或者无法判断处于哪一个区域。")]),e._v(" "),v("li",[e._v("1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。")]),e._v(" "),v("li",[e._v("2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。")]),e._v(" "),v("li",[e._v("3：处在数字小键盘。")])]),e._v(" "),v("h4",{attrs:{id:"keyboardevent-repeat"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-repeat"}},[e._v("#")]),e._v(" KeyboardEvent.repeat")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent.repeat")]),e._v("返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发"),v("code",[e._v("keydown")]),e._v("和"),v("code",[e._v("keypress")]),e._v("事件，直到用户松开手为止。")]),e._v(" "),v("h3",{attrs:{id:"keyboardevent-的实例方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-的实例方法"}},[e._v("#")]),e._v(" KeyboardEvent 的实例方法")]),e._v(" "),v("h4",{attrs:{id:"keyboardevent-getmodifierstate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-getmodifierstate"}},[e._v("#")]),e._v(" KeyboardEvent.getModifierState()")]),e._v(" "),v("p",[v("code",[e._v("KeyboardEvent.getModifierState()")]),e._v("方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Alt")]),e._v("：Alt 键")]),e._v(" "),v("li",[v("code",[e._v("CapsLock")]),e._v("：大写锁定键")]),e._v(" "),v("li",[v("code",[e._v("Control")]),e._v("：Ctrl 键")]),e._v(" "),v("li",[v("code",[e._v("Meta")]),e._v("：Meta 键")]),e._v(" "),v("li",[v("code",[e._v("NumLock")]),e._v("：数字键盘开关键")]),e._v(" "),v("li",[v("code",[e._v("Shift")]),e._v("：Shift 键")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("if (\n  event.getModifierState('Control') +\n  event.getModifierState('Alt') +\n  event.getModifierState('Meta') > 1\n) {\n  return;\n}\n")])])]),v("p",[e._v("上面代码表示，只要"),v("code",[e._v("Control")]),e._v("、"),v("code",[e._v("Alt")]),e._v("、"),v("code",[e._v("Meta")]),e._v("里面，同时按下任意两个或两个以上的键就返回。")]),e._v(" "),v("h2",{attrs:{id:"进度事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进度事件"}},[e._v("#")]),e._v(" 进度事件")]),e._v(" "),v("h3",{attrs:{id:"进度事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进度事件的种类"}},[e._v("#")]),e._v(" 进度事件的种类")]),e._v(" "),v("p",[e._v("进度事件用来描述资源加载的进度，主要由 AJAX 请求、"),v("code",[e._v("<img>")]),e._v("、"),v("code",[e._v("<audio>")]),e._v("、"),v("code",[e._v("<video>")]),e._v("、"),v("code",[e._v("<style>")]),e._v("、"),v("code",[e._v("<link>")]),e._v("等外部资源的加载触发，继承了"),v("code",[e._v("ProgressEvent")]),e._v("接口。它主要包含以下几种事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("abort")]),e._v("：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。")]),e._v(" "),v("li",[v("code",[e._v("error")]),e._v("：由于错误导致外部资源无法加载时触发。")]),e._v(" "),v("li",[v("code",[e._v("load")]),e._v("：外部资源加载成功时触发。")]),e._v(" "),v("li",[v("code",[e._v("loadstart")]),e._v("：外部资源开始加载时触发。")]),e._v(" "),v("li",[v("code",[e._v("loadend")]),e._v("：外部资源停止加载时触发，发生顺序排在"),v("code",[e._v("error")]),e._v("、"),v("code",[e._v("abort")]),e._v("、"),v("code",[e._v("load")]),e._v("等事件的后面。")]),e._v(" "),v("li",[v("code",[e._v("progress")]),e._v("：外部资源加载过程中不断触发。")]),e._v(" "),v("li",[v("code",[e._v("timeout")]),e._v("：加载超时时触发。")])]),e._v(" "),v("p",[e._v("注意，除了资源下载，文件上传也存在这些事件。")]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("image.addEventListener('load', function (event) {\n  image.classList.add('finished');\n});\n\nimage.addEventListener('error', function (event) {\n  image.style.display = 'none';\n});\n")])])]),v("p",[e._v("上面代码在图片元素加载完成后，为图片元素添加一个"),v("code",[e._v("finished")]),e._v("的 Class。如果加载失败，就把图片元素的样式设置为不显示。")]),e._v(" "),v("p",[e._v("有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能"),v("code",[e._v("load")]),e._v("和"),v("code",[e._v("error")]),e._v("事件的监听函数根本不会执行。所以，比较可靠的方式，是用"),v("code",[e._v("complete")]),e._v("属性先判断一下是否加载完成。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function loaded() {\n  // ...\n}\n\nif (image.complete) {\n  loaded();\n} else {\n  image.addEventListener('load', loaded);\n}\n")])])]),v("p",[e._v("由于 DOM 的元素节点没有提供是否加载错误的属性，所以"),v("code",[e._v("error")]),e._v("事件的监听函数最好放在"),v("code",[e._v("<img>")]),e._v("元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<img src="/wrong/url" onerror="this.style.display=\'none\';" />\n')])])]),v("p",[v("code",[e._v("loadend")]),e._v("事件的监听函数，可以用来取代"),v("code",[e._v("abort")]),e._v("事件、"),v("code",[e._v("load")]),e._v("事件、"),v("code",[e._v("error")]),e._v("事件的监听函数，因为它总是在这些事件之后发生。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("req.addEventListener('loadend', loadEnd, false);\n\nfunction loadEnd(e) {\n  console.log('传输结束，成功失败未知');\n}\n")])])]),v("p",[v("code",[e._v("loadend")]),e._v("事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。")]),e._v(" "),v("p",[e._v("另外，"),v("code",[e._v("error")]),e._v("事件有一个特殊的性质，就是不会冒泡。所以，子元素的"),v("code",[e._v("error")]),e._v("事件，不会触发父元素的"),v("code",[e._v("error")]),e._v("事件监听函数。")]),e._v(" "),v("h3",{attrs:{id:"progressevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#progressevent-接口"}},[e._v("#")]),e._v(" ProgressEvent 接口")]),e._v(" "),v("p",[v("code",[e._v("ProgressEvent")]),e._v("接口主要用来描述外部资源加载的进度，比如 AJAX 加载、"),v("code",[e._v("<img>")]),e._v("、"),v("code",[e._v("<video>")]),e._v("、"),v("code",[e._v("<style>")]),e._v("、"),v("code",[e._v("<link>")]),e._v("等外部资源加载。进度相关的事件都继承了这个接口。")]),e._v(" "),v("p",[e._v("浏览器原生提供了"),v("code",[e._v("ProgressEvent()")]),e._v("构造函数，用来生成事件实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new ProgressEvent(type, options)\n")])])]),v("p",[v("code",[e._v("ProgressEvent()")]),e._v("构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用"),v("code",[e._v("Event")]),e._v("接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("lengthComputable")]),e._v("：布尔值，表示加载的总量是否可以计算，默认是"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("loaded")]),e._v("：整数，表示已经加载的量，默认是"),v("code",[e._v("0")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("total")]),e._v("：整数，表示需要加载的总量，默认是"),v("code",[e._v("0")]),e._v("。")])]),e._v(" "),v("p",[v("code",[e._v("ProgressEvent")]),e._v("具有对应的实例属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("ProgressEvent.lengthComputable")])]),e._v(" "),v("li",[v("code",[e._v("ProgressEvent.loaded")])]),e._v(" "),v("li",[v("code",[e._v("ProgressEvent.total")])])]),e._v(" "),v("p",[e._v("如果"),v("code",[e._v("ProgressEvent.lengthComputable")]),e._v("为"),v("code",[e._v("false")]),e._v("，"),v("code",[e._v("ProgressEvent.total")]),e._v("实际上是没有意义的。")]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var p = new ProgressEvent('load', {\n  lengthComputable: true,\n  loaded: 30,\n  total: 100,\n});\n\ndocument.body.addEventListener('load', function (e) {\n  console.log('已经加载：' + (e.loaded / e.total) * 100 + '%');\n});\n\ndocument.body.dispatchEvent(p);\n// 已经加载：30%\n")])])]),v("p",[e._v("上面代码先构造一个"),v("code",[e._v("load")]),e._v("事件，抛出后被监听函数捕捉到。")]),e._v(" "),v("p",[e._v("下面是一个实际的例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var xhr = new XMLHttpRequest();\n\nxhr.addEventListener('progress', updateProgress, false);\nxhr.addEventListener('load', transferComplete, false);\nxhr.addEventListener('error', transferFailed, false);\nxhr.addEventListener('abort', transferCanceled, false);\n\nxhr.open();\n\nfunction updateProgress(e) {\n  if (e.lengthComputable) {\n    var percentComplete = e.loaded / e.total;\n  } else {\n    console.log('不能计算进度');\n  }\n}\n\nfunction transferComplete(e) {\n  console.log('传输结束');\n}\n\nfunction transferFailed(evt) {\n  console.log('传输过程中发生错误');\n}\n\nfunction transferCanceled(evt) {\n  console.log('用户取消了传输');\n}\n")])])]),v("p",[e._v("上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在"),v("code",[e._v("XMLHttpRequest.upload")]),e._v("对象上面。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var xhr = new XMLHttpRequest();\n\nxhr.upload.addEventListener('progress', updateProgress, false);\nxhr.upload.addEventListener('load', transferComplete, false);\nxhr.upload.addEventListener('error', transferFailed, false);\nxhr.upload.addEventListener('abort', transferCanceled, false);\n\nxhr.open();\n")])])]),v("h2",{attrs:{id:"表单事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表单事件"}},[e._v("#")]),e._v(" 表单事件")]),e._v(" "),v("h3",{attrs:{id:"表单事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表单事件的种类"}},[e._v("#")]),e._v(" 表单事件的种类")]),e._v(" "),v("h4",{attrs:{id:"input-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#input-事件"}},[e._v("#")]),e._v(" input 事件")]),e._v(" "),v("p",[v("code",[e._v("input")]),e._v("事件当"),v("code",[e._v("<input>")]),e._v("、"),v("code",[e._v("<select>")]),e._v("、"),v("code",[e._v("<textarea>")]),e._v("的值发生变化时触发。对于复选框（"),v("code",[e._v("<input type=checkbox>")]),e._v("）或单选框（"),v("code",[e._v("<input type=radio>")]),e._v("），用户改变选项时，也会触发这个事件。另外，对于打开"),v("code",[e._v("contenteditable")]),e._v("属性的元素，只要值发生变化，也会触发"),v("code",[e._v("input")]),e._v("事件。")]),e._v(" "),v("p",[v("code",[e._v("input")]),e._v("事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次"),v("code",[e._v("input")]),e._v("事件。")]),e._v(" "),v("p",[v("code",[e._v("input")]),e._v("事件对象继承了"),v("code",[e._v("InputEvent")]),e._v("接口。")]),e._v(" "),v("p",[e._v("该事件跟"),v("code",[e._v("change")]),e._v("事件很像，不同之处在于"),v("code",[e._v("input")]),e._v("事件在元素的值发生变化后立即发生，而"),v("code",[e._v("change")]),e._v("在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，"),v("code",[e._v("input")]),e._v("事件会触发多次，而"),v("code",[e._v("change")]),e._v("事件只在失去焦点时触发一次。")]),e._v(" "),v("p",[e._v("下面是"),v("code",[e._v("<select>")]),e._v("元素的例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('/* HTML 代码如下\n<select id="mySelect">\n  <option value="1">1</option>\n  <option value="2">2</option>\n  <option value="3">3</option>\n</select>\n*/\n\nfunction inputHandler(e) {\n  console.log(e.target.value)\n}\n\nvar mySelect = document.querySelector(\'#mySelect\');\nmySelect.addEventListener(\'input\', inputHandler);\n')])])]),v("p",[e._v("上面代码中，改变下拉框选项时，会触发"),v("code",[e._v("input")]),e._v("事件，从而执行回调函数"),v("code",[e._v("inputHandler")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"select-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#select-事件"}},[e._v("#")]),e._v(" select 事件")]),e._v(" "),v("p",[v("code",[e._v("select")]),e._v("事件当在"),v("code",[e._v("<input>")]),e._v("、"),v("code",[e._v("<textarea>")]),e._v("里面选中文本时触发。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// HTML 代码如下\n// <input id="test" type="text" value="Select me!" />\n\nvar elem = document.getElementById(\'test\');\nelem.addEventListener(\'select\', function (e) {\n  console.log(e.type); // "select"\n}, false);\n')])])]),v("p",[e._v("选中的文本可以通过"),v("code",[e._v("event.target")]),e._v("元素的"),v("code",[e._v("selectionDirection")]),e._v("、"),v("code",[e._v("selectionEnd")]),e._v("、"),v("code",[e._v("selectionStart")]),e._v("和"),v("code",[e._v("value")]),e._v("属性拿到。")]),e._v(" "),v("h4",{attrs:{id:"change-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#change-事件"}},[e._v("#")]),e._v(" change 事件")]),e._v(" "),v("p",[v("code",[e._v("change")]),e._v("事件当"),v("code",[e._v("<input>")]),e._v("、"),v("code",[e._v("<select>")]),e._v("、"),v("code",[e._v("<textarea>")]),e._v("的值发生变化时触发。它与"),v("code",[e._v("input")]),e._v("事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面"),v("code",[e._v("input")]),e._v("事件必然伴随"),v("code",[e._v("change")]),e._v("事件。具体来说，分成以下几种情况。")]),e._v(" "),v("ul",[v("li",[e._v("激活单选框（radio）或复选框（checkbox）时触发。")]),e._v(" "),v("li",[e._v("用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。")]),e._v(" "),v("li",[e._v("当文本框或"),v("code",[e._v("<textarea>")]),e._v("元素的值发生改变，并且丧失焦点时触发。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// HTML 代码如下\n// <select size="1" onchange="changeEventHandler(event);">\n//   <option>chocolate</option>\n//   <option>strawberry</option>\n//   <option>vanilla</option>\n// </select>\n\nfunction changeEventHandler(event) {\n  console.log(event.target.value);\n}\n')])])]),v("p",[e._v("如果比较一下上面"),v("code",[e._v("input")]),e._v("事件的例子，你会发现对于"),v("code",[e._v("<select>")]),e._v("元素来说，"),v("code",[e._v("input")]),e._v("和"),v("code",[e._v("change")]),e._v("事件基本是等价的。")]),e._v(" "),v("h4",{attrs:{id:"invalid-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#invalid-事件"}},[e._v("#")]),e._v(" invalid 事件")]),e._v(" "),v("p",[e._v("用户提交表单时，如果表单元素的值不满足校验条件，就会触发"),v("code",[e._v("invalid")]),e._v("事件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<form>\n  <input type="text" required oninvalid="console.log(\'invalid input\')" />\n  <button type="submit">提交</button>\n</form>\n')])])]),v("p",[e._v("上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的"),v("code",[e._v("invalid")]),e._v("事件，导致提交被取消。")]),e._v(" "),v("h4",{attrs:{id:"reset-事件-submit-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reset-事件-submit-事件"}},[e._v("#")]),e._v(" reset 事件，submit 事件")]),e._v(" "),v("p",[e._v("这两个事件发生在表单对象"),v("code",[e._v("<form>")]),e._v("上，而不是发生在表单的成员上。")]),e._v(" "),v("p",[v("code",[e._v("reset")]),e._v("事件当表单重置（所有表单成员变回默认值）时触发。")]),e._v(" "),v("p",[v("code",[e._v("submit")]),e._v("事件当表单数据向服务器提交时触发。注意，"),v("code",[e._v("submit")]),e._v("事件的发生对象是"),v("code",[e._v("<form>")]),e._v("元素，而不是"),v("code",[e._v("<button>")]),e._v("元素，因为提交的是表单，而不是按钮。")]),e._v(" "),v("h3",{attrs:{id:"inputevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#inputevent-接口"}},[e._v("#")]),e._v(" InputEvent 接口")]),e._v(" "),v("p",[v("code",[e._v("InputEvent")]),e._v("接口主要用来描述"),v("code",[e._v("input")]),e._v("事件的实例。该接口继承了"),v("code",[e._v("Event")]),e._v("接口，还定义了一些自己的实例属性和实例方法。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("InputEvent()")]),e._v("构造函数，用来生成实例对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new InputEvent(type, options)\n")])])]),v("p",[v("code",[e._v("InputEvent")]),e._v("构造函数可以接受两个参数。第一个参数是字符串，表示事件名称，该参数是必需的。第二个参数是一个配置对象，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了"),v("code",[e._v("Event")]),e._v("构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("inputType")]),e._v("：字符串，表示发生变更的类型（详见下文）。")]),e._v(" "),v("li",[v("code",[e._v("data")]),e._v("：字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回"),v("code",[e._v("null")]),e._v("或空字符串。")]),e._v(" "),v("li",[v("code",[e._v("dataTransfer")]),e._v("：返回一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。")])]),e._v(" "),v("p",[v("code",[e._v("InputEvent")]),e._v("的实例属性主要就是上面三个属性，这三个实例属性都是只读的。")]),e._v(" "),v("p",[v("strong",[e._v("（1）InputEvent.data")])]),e._v(" "),v("p",[v("code",[e._v("InputEvent.data")]),e._v("属性返回一个字符串，表示变动的内容。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <input type=\"text\" id=\"myInput\">\nvar input = document.getElementById('myInput');\ninput.addEventListener('input', myFunction, false);\n\nfunction myFunction(e) {\n  console.log(e.data);\n}\n")])])]),v("p",[e._v("上面代码中，如果手动在输入框里面输入"),v("code",[e._v("abc")]),e._v("，控制台会先输出"),v("code",[e._v("a")]),e._v("，再在下一行输出"),v("code",[e._v("b")]),e._v("，再在下一行输出"),v("code",[e._v("c")]),e._v("。然后选中"),v("code",[e._v("abc")]),e._v("，一次性将它们删除，控制台会输出"),v("code",[e._v("null")]),e._v("或一个空字符串。")]),e._v(" "),v("p",[v("strong",[e._v("（2）InputEvent.inputType")])]),e._v(" "),v("p",[v("code",[e._v("InputEvent.inputType")]),e._v("属性返回一个字符串，表示字符串发生变更的类型。")]),e._v(" "),v("p",[e._v("对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考"),v("a",{attrs:{href:"https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("ul",[v("li",[e._v("手动插入文本："),v("code",[e._v("insertText")])]),e._v(" "),v("li",[e._v("粘贴插入文本："),v("code",[e._v("insertFromPaste")])]),e._v(" "),v("li",[e._v("向后删除："),v("code",[e._v("deleteContentBackward")])]),e._v(" "),v("li",[e._v("向前删除："),v("code",[e._v("deleteContentForward")])])]),e._v(" "),v("p",[v("strong",[e._v("（3）InputEvent.dataTransfer")])]),e._v(" "),v("p",[v("code",[e._v("InputEvent.dataTransfer")]),e._v("属性返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（"),v("code",[e._v("insertFromDrop")]),e._v("）时才有效。")]),e._v(" "),v("h2",{attrs:{id:"触摸事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触摸事件"}},[e._v("#")]),e._v(" 触摸事件")]),e._v(" "),v("h3",{attrs:{id:"触摸操作概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触摸操作概述"}},[e._v("#")]),e._v(" 触摸操作概述")]),e._v(" "),v("p",[e._v("浏览器的触摸 API 由三个部分组成。")]),e._v(" "),v("ul",[v("li",[e._v("Touch：一个触摸点")]),e._v(" "),v("li",[e._v("TouchList：多个触摸点的集合")]),e._v(" "),v("li",[e._v("TouchEvent：触摸引发的事件实例")])]),e._v(" "),v("p",[v("code",[e._v("Touch")]),e._v("接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由"),v("code",[e._v("TouchList")]),e._v("接口的实例对象表示。"),v("code",[e._v("TouchEvent")]),e._v("接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。")]),e._v(" "),v("p",[e._v("很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用"),v("code",[e._v("event.preventDefault")]),e._v("方法阻止发出鼠标事件。")]),e._v(" "),v("h3",{attrs:{id:"touch-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#touch-接口"}},[e._v("#")]),e._v(" Touch 接口")]),e._v(" "),v("h4",{attrs:{id:"touch-接口概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#touch-接口概述"}},[e._v("#")]),e._v(" Touch 接口概述")]),e._v(" "),v("p",[e._v("Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("Touch")]),e._v("构造函数，用来生成"),v("code",[e._v("Touch")]),e._v("实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var touch = new Touch(touchOptions);\n")])])]),v("p",[v("code",[e._v("Touch")]),e._v("构造函数接受一个配置对象作为参数，它有以下属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("identifier")]),e._v("：必需，类型为整数，表示触摸点的唯一 ID。")]),e._v(" "),v("li",[v("code",[e._v("target")]),e._v("：必需，类型为元素节点，表示触摸点开始时所在的网页元素。")]),e._v(" "),v("li",[v("code",[e._v("clientX")]),e._v("：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("clientY")]),e._v("：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("screenX")]),e._v("：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("screenY")]),e._v("：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("pageX")]),e._v("：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。")]),e._v(" "),v("li",[v("code",[e._v("pageY")]),e._v("：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。")]),e._v(" "),v("li",[v("code",[e._v("radiusX")]),e._v("：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("radiusY")]),e._v("：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。")]),e._v(" "),v("li",[v("code",[e._v("rotationAngle")]),e._v("：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。")]),e._v(" "),v("li",[v("code",[e._v("force")]),e._v("：可选，类型为数值，范围在"),v("code",[e._v("0")]),e._v("到"),v("code",[e._v("1")]),e._v("之间，表示触摸压力。"),v("code",[e._v("0")]),e._v("代表没有压力，"),v("code",[e._v("1")]),e._v("代表硬件所能识别的最大压力，默认为"),v("code",[e._v("0")]),e._v("。")])]),e._v(" "),v("h4",{attrs:{id:"touch-接口的实例属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#touch-接口的实例属性"}},[e._v("#")]),e._v(" Touch 接口的实例属性")]),e._v(" "),v("p",[v("strong",[e._v("（1）Touch.identifier")])]),e._v(" "),v("p",[v("code",[e._v("Touch.identifier")]),e._v("属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("someElement.addEventListener('touchmove', function (e) {\n  for (var i = 0; i < e.changedTouches.length; i++) {\n    console.log(e.changedTouches[i].identifier);\n  }\n}, false);\n")])])]),v("p",[v("strong",[e._v("（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY")])]),e._v(" "),v("p",[v("code",[e._v("Touch.screenX")]),e._v("属性和"),v("code",[e._v("Touch.screenY")]),e._v("属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。")]),e._v(" "),v("p",[v("code",[e._v("Touch.clientX")]),e._v("属性和"),v("code",[e._v("Touch.clientY")]),e._v("属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。")]),e._v(" "),v("p",[v("code",[e._v("Touch.pageX")]),e._v("属性和"),v("code",[e._v("Touch.pageY")]),e._v("属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。")]),e._v(" "),v("p",[v("strong",[e._v("（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle")])]),e._v(" "),v("p",[v("code",[e._v("Touch.radiusX")]),e._v("属性和"),v("code",[e._v("Touch.radiusY")]),e._v("属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。")]),e._v(" "),v("p",[v("code",[e._v("Touch.rotationAngle")]),e._v("属性表示触摸区域的椭圆的旋转角度，单位为度数，在"),v("code",[e._v("0")]),e._v("到"),v("code",[e._v("90")]),e._v("度之间。")]),e._v(" "),v("p",[e._v("上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。")]),e._v(" "),v("p",[e._v("下面是一个示例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('touchstart', rotate);\ndiv.addEventListener('touchmove', rotate);\ndiv.addEventListener('touchend', rotate);\n\nfunction rotate(e) {\n  var touch = e.changedTouches.item(0);\n  e.preventDefault();\n\n  src.style.width = touch.radiusX * 2 + 'px';\n  src.style.height = touch.radiusY * 2 + 'px';\n  src.style.transform = 'rotate(' + touch.rotationAngle + 'deg)';\n};\n")])])]),v("p",[v("strong",[e._v("（4）Touch.force")])]),e._v(" "),v("p",[v("code",[e._v("Touch.force")]),e._v("属性返回一个"),v("code",[e._v("0")]),e._v("到"),v("code",[e._v("1")]),e._v("之间的数值，表示触摸压力。"),v("code",[e._v("0")]),e._v("代表没有压力，"),v("code",[e._v("1")]),e._v("代表硬件所能识别的最大压力。")]),e._v(" "),v("p",[v("strong",[e._v("（5）Touch.target")])]),e._v(" "),v("p",[v("code",[e._v("Touch.target")]),e._v("属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。")]),e._v(" "),v("h3",{attrs:{id:"touchlist-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#touchlist-接口"}},[e._v("#")]),e._v(" TouchList 接口")]),e._v(" "),v("p",[v("code",[e._v("TouchList")]),e._v("接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是"),v("code",[e._v("Touch")]),e._v("的实例对象，表示所有触摸点。用户用三根手指触摸，产生的"),v("code",[e._v("TouchList")]),e._v("实例就会包含三个成员，每根手指的触摸点对应一个"),v("code",[e._v("Touch")]),e._v("实例对象。")]),e._v(" "),v("p",[e._v("它的实例主要通过触摸事件的"),v("code",[e._v("TouchEvent.touches")]),e._v("、"),v("code",[e._v("TouchEvent.changedTouches")]),e._v("、"),v("code",[e._v("TouchEvent.targetTouches")]),e._v("这几个属性获取。")]),e._v(" "),v("p",[e._v("它的实例属性和实例方法只有两个。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("TouchList.length")]),e._v("：数值，表示成员数量（即触摸点的数量）。")]),e._v(" "),v("li",[v("code",[e._v("TouchList.item()")]),e._v("：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。")])]),e._v(" "),v("h3",{attrs:{id:"touchevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#touchevent-接口"}},[e._v("#")]),e._v(" TouchEvent 接口")]),e._v(" "),v("h3",{attrs:{id:"概述-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("p",[e._v("TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("TouchEvent()")]),e._v("构造函数，用来生成触摸事件的实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new TouchEvent(type, options)\n")])])]),v("p",[v("code",[e._v("TouchEvent()")]),e._v("构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了"),v("code",[e._v("Event")]),e._v("接口的配置属性，该接口还有一些自己的配置属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("touches")]),e._v("："),v("code",[e._v("TouchList")]),e._v("实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组"),v("code",[e._v("[]")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("targetTouches")]),e._v("："),v("code",[e._v("TouchList")]),e._v("实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组"),v("code",[e._v("[]")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("changedTouches")]),e._v("："),v("code",[e._v("TouchList")]),e._v("实例，代表本次触摸事件的相关触摸点，默认值是一个空数组"),v("code",[e._v("[]")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("ctrlKey")]),e._v("：布尔值，表示 Ctrl 键是否同时按下，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("shiftKey")]),e._v("：布尔值，表示 Shift 键是否同时按下，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("altKey")]),e._v("：布尔值，表示 Alt 键是否同时按下，默认值为"),v("code",[e._v("false")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("metaKey")]),e._v("：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为"),v("code",[e._v("false")]),e._v("。")])]),e._v(" "),v("h3",{attrs:{id:"实例属性-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例属性-3"}},[e._v("#")]),e._v(" 实例属性")]),e._v(" "),v("p",[e._v("TouchEvent 接口的实例具有"),v("code",[e._v("Event")]),e._v("实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。")]),e._v(" "),v("p",[v("strong",[e._v("（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("TouchEvent.altKey")]),e._v("：布尔值，表示触摸时是否按下了 Alt 键。")]),e._v(" "),v("li",[v("code",[e._v("TouchEvent.ctrlKey")]),e._v("：布尔值，表示触摸时是否按下了 Ctrl 键。")]),e._v(" "),v("li",[v("code",[e._v("TouchEvent.shiftKey")]),e._v("：布尔值：表示触摸时是否按下了 Shift 键。")]),e._v(" "),v("li",[v("code",[e._v("TouchEvent.metaKey")]),e._v("：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。")])]),e._v(" "),v("p",[e._v("下面是一个示例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("someElement.addEventListener('touchstart', function (e) {\n  console.log('altKey = ' + e.altKey);\n  console.log('ctrlKey = ' + e.ctrlKey);\n  console.log('metaKey = ' + e.metaKey);\n  console.log('shiftKey = ' + e.shiftKey);\n}, false);\n")])])]),v("p",[v("strong",[e._v("（2）TouchEvent.changedTouches")])]),e._v(" "),v("p",[v("code",[e._v("TouchEvent.changedTouches")]),e._v("属性返回一个"),v("code",[e._v("TouchList")]),e._v("实例，成员是一组"),v("code",[e._v("Touch")]),e._v("实例对象，表示本次触摸事件的相关触摸点。")]),e._v(" "),v("p",[e._v("对于不同的时间，该属性的含义有所不同。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("touchstart")]),e._v("事件：被激活的触摸点")]),e._v(" "),v("li",[v("code",[e._v("touchmove")]),e._v("事件：发生变化的触摸点")]),e._v(" "),v("li",[v("code",[e._v("touchend")]),e._v("事件：消失的触摸点（即不再被触碰的点）")])]),e._v(" "),v("p",[e._v("下面是一个示例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("someElement.addEventListener('touchmove', function (e) {\n  for (var i = 0; i < e.changedTouches.length; i++) {\n    console.log(e.changedTouches[i].identifier);\n  }\n}, false);\n")])])]),v("p",[v("strong",[e._v("（3）TouchEvent.touches")])]),e._v(" "),v("p",[v("code",[e._v("TouchEvent.touches")]),e._v("属性返回一个"),v("code",[e._v("TouchList")]),e._v("实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。")]),e._v(" "),v("p",[e._v("下面是一个示例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("someElement.addEventListener('touchstart', function (e) {\n  switch (e.touches.length) {\n    // 一根手指触摸\n    case 1: handle_one_touch(e); break;\n    // 两根手指触摸\n    case 2: handle_two_touches(e); break;\n    // 三根手指触摸\n    case 3: handle_three_touches(e); break;\n    // 其他情况\n    default: console.log('Not supported'); break;\n  }\n}, false);\n")])])]),v("p",[v("strong",[e._v("（4）TouchEvent.targetTouches")])]),e._v(" "),v("p",[v("code",[e._v("TouchEvent.targetTouches")]),e._v("属性返回一个"),v("code",[e._v("TouchList")]),e._v("实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function touches_in_target(ev) {\n  return (ev.touches.length === ev.targetTouches.length ? true : false);\n}\n")])])]),v("p",[e._v("上面代码用来判断，是否所有触摸点都在目标元素内。")]),e._v(" "),v("h3",{attrs:{id:"触摸事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#触摸事件的种类"}},[e._v("#")]),e._v(" 触摸事件的种类")]),e._v(" "),v("p",[e._v("触摸引发的事件，有以下几种。可以通过"),v("code",[e._v("TouchEvent.type")]),e._v("属性，查看到底发生的是哪一种事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("touchstart")]),e._v("：用户开始触摸时触发，它的"),v("code",[e._v("target")]),e._v("属性返回发生触摸的元素节点。")]),e._v(" "),v("li",[v("code",[e._v("touchend")]),e._v("：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的"),v("code",[e._v("target")]),e._v("属性与"),v("code",[e._v("touchstart")]),e._v("事件一致的，就是开始触摸时所在的元素节点。它的"),v("code",[e._v("changedTouches")]),e._v("属性返回一个"),v("code",[e._v("TouchList")]),e._v("实例，包含所有不再触摸的触摸点（即"),v("code",[e._v("Touch")]),e._v("实例对象）。")]),e._v(" "),v("li",[v("code",[e._v("touchmove")]),e._v("：用户移动触摸点时触发，它的"),v("code",[e._v("target")]),e._v("属性与"),v("code",[e._v("touchstart")]),e._v("事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。")]),e._v(" "),v("li",[v("code",[e._v("touchcancel")]),e._v("：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var el = document.getElementsByTagName('canvas')[0];\nel.addEventListener('touchstart', handleStart, false);\nel.addEventListener('touchmove', handleMove, false);\n\nfunction handleStart(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    console.log(touches[i].pageX, touches[i].pageY);\n  }\n}\n\nfunction handleMove(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    console.log(touch.pageX, touch.pageY);\n  }\n}\n")])])]),v("h2",{attrs:{id:"拖拉事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拖拉事件"}},[e._v("#")]),e._v(" 拖拉事件")]),e._v(" "),v("h3",{attrs:{id:"拖拉事件的种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拖拉事件的种类"}},[e._v("#")]),e._v(" 拖拉事件的种类")]),e._v(" "),v("p",[e._v("拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。")]),e._v(" "),v("p",[e._v("拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的"),v("code",[e._v("draggable")]),e._v("属性设为"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div draggable="true">\n  此区域可拖拉\n</div>\n')])])]),v("p",[e._v("上面代码的"),v("code",[e._v("div")]),e._v("区块，在网页中可以直接用鼠标拖动。松开鼠标键时，拖动效果就会消失，该区块依然在原来的位置。")]),e._v(" "),v("p",[v("code",[e._v("draggable")]),e._v("属性可用于任何元素节点，但是图片（"),v("code",[e._v("<img>")]),e._v("）和链接（"),v("code",[e._v("<a>")]),e._v("）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为"),v("code",[e._v("false")]),e._v("，防止拖拉这两种元素。")]),e._v(" "),v("p",[e._v("注意，一旦某个元素节点的"),v("code",[e._v("draggable")]),e._v("属性设为"),v("code",[e._v("true")]),e._v("，就无法再用鼠标选中该节点内部的文字或子节点了。")]),e._v(" "),v("p",[e._v("当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("drag")]),e._v("：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。")]),e._v(" "),v("li",[v("code",[e._v("dragstart")]),e._v("：用户开始拖拉时，在被拖拉的节点上触发，该事件的"),v("code",[e._v("target")]),e._v("属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。")]),e._v(" "),v("li",[v("code",[e._v("dragend")]),e._v("：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的"),v("code",[e._v("target")]),e._v("属性是被拖拉的节点。它与"),v("code",[e._v("dragstart")]),e._v("事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，"),v("code",[e._v("dragend")]),e._v("事件总是会触发的。")]),e._v(" "),v("li",[v("code",[e._v("dragenter")]),e._v("：拖拉进入当前节点时，在当前节点上触发一次，该事件的"),v("code",[e._v("target")]),e._v("属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。")]),e._v(" "),v("li",[v("code",[e._v("dragover")]),e._v("：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的"),v("code",[e._v("target")]),e._v("属性是当前节点。该事件与"),v("code",[e._v("dragenter")]),e._v("事件的区别是，"),v("code",[e._v("dragenter")]),e._v("事件在进入该节点时触发，然后只要没有离开这个节点，"),v("code",[e._v("dragover")]),e._v("事件会持续触发。")]),e._v(" "),v("li",[v("code",[e._v("dragleave")]),e._v("：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的"),v("code",[e._v("target")]),e._v("属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。")]),e._v(" "),v("li",[v("code",[e._v("drop")]),e._v("：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许"),v("code",[e._v("drop")]),e._v("，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。")])]),e._v(" "),v("p",[e._v("下面的例子展示，如何动态改变被拖动节点的背景色。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('dragstart', function (e) {\n  this.style.backgroundColor = 'red';\n}, false);\n\ndiv.addEventListener('dragend', function (e) {\n  this.style.backgroundColor = 'green';\n}, false);\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("div")]),e._v("节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。")]),e._v(" "),v("p",[e._v("下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n <div class=\"dropzone\">\n   <div id=\"draggable\" draggable=\"true\">\n     该节点可拖拉\n   </div>\n </div>\n <div class=\"dropzone\"></div>\n <div class=\"dropzone\"></div>\n <div class=\"dropzone\"></div>\n*/\n\n// 被拖拉节点\nvar dragged;\n\ndocument.addEventListener('dragstart', function (event) {\n  // 保存被拖拉节点\n  dragged = event.target;\n  // 被拖拉节点的背景色变透明\n  event.target.style.opacity = 0.5;\n}, false);\n\ndocument.addEventListener('dragend', function (event) {\n  // 被拖拉节点的背景色恢复正常\n  event.target.style.opacity = '';\n}, false);\n\ndocument.addEventListener('dragover', function (event) {\n  // 防止拖拉效果被重置，允许被拖拉的节点放入目标节点\n  event.preventDefault();\n}, false);\n\ndocument.addEventListener('dragenter', function (event) {\n  // 目标节点的背景色变紫色\n  // 由于该事件会冒泡，所以要过滤节点\n  if (event.target.className === 'dropzone') {\n    event.target.style.background = 'purple';\n  }\n}, false);\n\ndocument.addEventListener('dragleave', function( event ) {\n  // 目标节点的背景色恢复原样\n  if (event.target.className === 'dropzone') {\n    event.target.style.background = '';\n  }\n}, false);\n\ndocument.addEventListener('drop', function( event ) {\n  // 防止事件默认行为（比如某些元素节点上可以打开链接），\n  event.preventDefault();\n  if (event.target.className === 'dropzone') {\n    // 恢复目标节点背景色\n    event.target.style.background = '';\n    // 将被拖拉节点插入目标节点\n    dragged.parentNode.removeChild(dragged);\n    event.target.appendChild( dragged );\n  }\n}, false);\n")])])]),v("p",[e._v("关于拖拉事件，有以下几个注意点。")]),e._v(" "),v("ul",[v("li",[e._v("拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。")]),e._v(" "),v("li",[e._v("将文件从操作系统拖拉进浏览器，不会触发"),v("code",[e._v("dragstart")]),e._v("和"),v("code",[e._v("dragend")]),e._v("事件。")]),e._v(" "),v("li",[v("code",[e._v("dragenter")]),e._v("和"),v("code",[e._v("dragover")]),e._v("事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div ondragover="return false">\n<div ondragover="event.preventDefault()">\n')])])]),v("p",[e._v("上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在"),v("code",[e._v("div")]),e._v("节点上放下被拖拉的节点。")]),e._v(" "),v("h3",{attrs:{id:"dragevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dragevent-接口"}},[e._v("#")]),e._v(" DragEvent 接口")]),e._v(" "),v("p",[e._v("拖拉事件都继承了"),v("code",[e._v("DragEvent")]),e._v("接口，这个接口又继承了"),v("code",[e._v("MouseEvent")]),e._v("接口和"),v("code",[e._v("Event")]),e._v("接口。")]),e._v(" "),v("p",[e._v("浏览器原生提供一个"),v("code",[e._v("DragEvent()")]),e._v("构造函数，用来生成拖拉事件的实例对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new DragEvent(type, options)\n")])])]),v("p",[v("code",[e._v("DragEvent()")]),e._v("构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受"),v("code",[e._v("MouseEvent")]),e._v("接口和"),v("code",[e._v("Event")]),e._v("接口的配置属性，还可以设置"),v("code",[e._v("dataTransfer")]),e._v("属性要么是"),v("code",[e._v("null")]),e._v("，要么是一个"),v("code",[e._v("DataTransfer")]),e._v("接口的实例。")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer")]),e._v("的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。")]),e._v(" "),v("h3",{attrs:{id:"datatransfer-接口概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-接口概述"}},[e._v("#")]),e._v(" DataTransfer 接口概述")]),e._v(" "),v("p",[e._v("所有拖拉事件的实例都有一个"),v("code",[e._v("DragEvent.dataTransfer")]),e._v("属性，用来读写需要传递的数据。这个属性的值是一个"),v("code",[e._v("DataTransfer")]),e._v("接口的实例。")]),e._v(" "),v("p",[e._v("浏览器原生提供一个"),v("code",[e._v("DataTransfer()")]),e._v("构造函数，用来生成"),v("code",[e._v("DataTransfer")]),e._v("实例对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var dataTrans = new DataTransfer();\n")])])]),v("p",[v("code",[e._v("DataTransfer()")]),e._v("构造函数不接受参数。")]),e._v(" "),v("p",[e._v("拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如"),v("code",[e._v("text/plain")]),e._v("、"),v("code",[e._v("image/jpeg")]),e._v("），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。")]),e._v(" "),v("p",[e._v("拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过"),v("code",[e._v("dragenter")]),e._v("和"),v("code",[e._v("dragover")]),e._v("事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为"),v("code",[e._v("text/uri-list")]),e._v("。")]),e._v(" "),v("p",[e._v("发生"),v("code",[e._v("drop")]),e._v("事件时，监听函数取出拖拉的数据，对其进行处理。")]),e._v(" "),v("h3",{attrs:{id:"datatransfer-的实例属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-的实例属性"}},[e._v("#")]),e._v(" DataTransfer 的实例属性")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-dropeffect"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-dropeffect"}},[e._v("#")]),e._v(" DataTransfer.dropEffect")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.dropEffect")]),e._v("属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。")]),e._v(" "),v("ul",[v("li",[e._v("copy：复制被拖拉的节点")]),e._v(" "),v("li",[e._v("move：移动被拖拉的节点")]),e._v(" "),v("li",[e._v("link：创建指向被拖拉的节点的链接")]),e._v(" "),v("li",[e._v("none：无法放下被拖拉的节点")])]),e._v(" "),v("p",[e._v("除了上面这些值，设置其他的值都是无效的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("target.addEventListener('dragover', function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.dataTransfer.dropEffect = 'copy';\n});\n")])])]),v("p",[e._v("上面代码中，被拖拉元素一旦"),v("code",[e._v("drop")]),e._v("，接受的区域会复制该节点。")]),e._v(" "),v("p",[v("code",[e._v("dropEffect")]),e._v("属性一般在"),v("code",[e._v("dragenter")]),e._v("和"),v("code",[e._v("dragover")]),e._v("事件的监听函数中设置，对于"),v("code",[e._v("dragstart")]),e._v("、"),v("code",[e._v("drag")]),e._v("、"),v("code",[e._v("dragleave")]),e._v("这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-effectallowed"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-effectallowed"}},[e._v("#")]),e._v(" DataTransfer.effectAllowed")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.effectAllowed")]),e._v("属性设置本次拖拉中允许的效果。它可能取下面的值。")]),e._v(" "),v("ul",[v("li",[e._v("copy：复制被拖拉的节点")]),e._v(" "),v("li",[e._v("move：移动被拖拉的节点")]),e._v(" "),v("li",[e._v("link：创建指向被拖拉节点的链接")]),e._v(" "),v("li",[e._v("copyLink：允许"),v("code",[e._v("copy")]),e._v("或"),v("code",[e._v("link")])]),e._v(" "),v("li",[e._v("copyMove：允许"),v("code",[e._v("copy")]),e._v("或"),v("code",[e._v("move")])]),e._v(" "),v("li",[e._v("linkMove：允许"),v("code",[e._v("link")]),e._v("或"),v("code",[e._v("move")])]),e._v(" "),v("li",[e._v("all：允许所有效果")]),e._v(" "),v("li",[e._v("none：无法放下被拖拉的节点")]),e._v(" "),v("li",[e._v("uninitialized：默认值，等同于"),v("code",[e._v("all")])])]),e._v(" "),v("p",[e._v("如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。")]),e._v(" "),v("p",[e._v("这个属性与"),v("code",[e._v("dropEffect")]),e._v("属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。")]),e._v(" "),v("p",[v("code",[e._v("dragstart")]),e._v("事件的监听函数，可以用来设置这个属性。其他事件的监听函数里面设置这个属性是无效的。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("source.addEventListener('dragstart', function (e) {\n  e.dataTransfer.effectAllowed = 'move';\n});\n\ntarget.addEventListener('dragover', function (e) {\n  e.dataTransfer.dropEffect = 'move';\n});\n")])])]),v("p",[e._v("只要"),v("code",[e._v("dropEffect")]),e._v("属性和"),v("code",[e._v("effectAllowed")]),e._v("属性之中，有一个为"),v("code",[e._v("none")]),e._v("，就无法在目标节点上完成"),v("code",[e._v("drop")]),e._v("操作。")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-files"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-files"}},[e._v("#")]),e._v(" DataTransfer.files")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.files")]),e._v("属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。")]),e._v(" "),v("p",[e._v("下面就是一个接收拖拉文件的例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// HTML 代码如下\n// <div id="output" style="min-height: 200px;border: 1px solid black;">\n//   文件拖拉到这里\n// </div>\n\nvar div = document.getElementById(\'output\');\n\ndiv.addEventListener("dragenter", function( event ) {\n  div.textContent = \'\';\n  event.stopPropagation();\n  event.preventDefault();\n}, false);\n\ndiv.addEventListener("dragover", function( event ) {\n  event.stopPropagation();\n  event.preventDefault();\n}, false);\n\ndiv.addEventListener("drop", function( event ) {\n  event.stopPropagation();\n  event.preventDefault();\n  var files = event.dataTransfer.files;\n  for (var i = 0; i < files.length; i++) {\n    div.textContent += files[i].name + \' \' + files[i].size + \'字节\\n\';\n  }\n}, false);\n')])])]),v("p",[e._v("上面代码中，通过"),v("code",[e._v("dataTransfer.files")]),e._v("属性读取被拖拉的文件的信息。如果想要读取文件内容，就要使用"),v("code",[e._v("FileReader")]),e._v("对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('drop', function(e) {\n  e.preventDefault();\n  e.stopPropagation();\n\n  var fileList = e.dataTransfer.files;\n  if (fileList.length > 0) {\n    var file = fileList[0];\n    var reader = new FileReader();\n    reader.onloadend = function(e) {\n      if (e.target.readyState === FileReader.DONE) {\n        var content = reader.result;\n        div.innerHTML = 'File: ' + file.name + '\\n\\n' + content;\n      }\n    }\n    reader.readAsBinaryString(file);\n  }\n});\n")])])]),v("h4",{attrs:{id:"datatransfer-types"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-types"}},[e._v("#")]),e._v(" DataTransfer.types")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.types")]),e._v("属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是"),v("code",[e._v("text/plain")]),e._v("。")]),e._v(" "),v("p",[e._v("下面是一个例子，通过检查"),v("code",[e._v("dataTransfer")]),e._v("属性的类型，决定是否允许在当前节点执行"),v("code",[e._v("drop")]),e._v("操作。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function contains(list, value){\n  for (var i = 0; i < list.length; ++i) {\n    if(list[i] === value) return true;\n  }\n  return false;\n}\n\nfunction doDragOver(event) {\n  var isLink = contains(event.dataTransfer.types, 'text/uri-list');\n  if (isLink) event.preventDefault();\n}\n")])])]),v("p",[e._v("上面代码中，只有当被拖拉的节点有一个是链接时，才允许在当前节点放下。")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-items"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-items"}},[e._v("#")]),e._v(" DataTransfer.items")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.items")]),e._v("属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。")]),e._v(" "),v("p",[e._v("DataTransferItemList 实例具有以下的属性和方法。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("length")]),e._v("：返回成员的数量")]),e._v(" "),v("li",[v("code",[e._v("add(data, type)")]),e._v("：增加一个指定内容和类型（比如"),v("code",[e._v("text/html")]),e._v("和"),v("code",[e._v("text/plain")]),e._v("）的字符串作为成员")]),e._v(" "),v("li",[v("code",[e._v("add(file)")]),e._v("："),v("code",[e._v("add")]),e._v("方法的另一种用法，增加一个文件作为成员")]),e._v(" "),v("li",[v("code",[e._v("remove(index)")]),e._v("：移除指定位置的成员")]),e._v(" "),v("li",[v("code",[e._v("clear()")]),e._v("：移除所有的成员")])]),e._v(" "),v("p",[e._v("DataTransferItem 实例具有以下的属性和方法。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("kind")]),e._v("：返回成员的种类（"),v("code",[e._v("string")]),e._v("还是"),v("code",[e._v("file")]),e._v("）。")]),e._v(" "),v("li",[v("code",[e._v("type")]),e._v("：返回成员的类型（通常是 MIME 值）。")]),e._v(" "),v("li",[v("code",[e._v("getAsFile()")]),e._v("：如果被拖拉是文件，返回该文件，否则返回"),v("code",[e._v("null")]),e._v("。")]),e._v(" "),v("li",[v("code",[e._v("getAsString(callback)")]),e._v("：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('drop', function (e) {\n  e.preventDefault();\n  if (e.dataTransfer.items != null) {\n    for (var i = 0; i < e.dataTransfer.items.length; i++) {\n      console.log(e.dataTransfer.items[i].kind + ': ' + e.dataTransfer.items[i].type);\n    }\n  }\n});\n")])])]),v("h3",{attrs:{id:"datatransfer-的实例方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-的实例方法"}},[e._v("#")]),e._v(" DataTransfer 的实例方法")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-setdata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-setdata"}},[e._v("#")]),e._v(" DataTransfer.setData()")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.setData()")]),e._v("方法用来设置拖拉事件所带有的数据。该方法没有返回值。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("event.dataTransfer.setData('text/plain', 'Text to drag');\n")])])]),v("p",[e._v("上面代码为当前的拖拉事件加入纯文本数据。")]),e._v(" "),v("p",[e._v("该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如"),v("code",[e._v("text/plain")]),e._v("），第二个参数是具体数据。如果指定类型的数据在"),v("code",[e._v("dataTransfer")]),e._v("属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。")]),e._v(" "),v("p",[e._v("如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到"),v("code",[e._v("dataTransfer")]),e._v("属性，不用手动指定。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('<div draggable="true">\n  aaa\n</div>\n')])])]),v("p",[e._v("上面代码中，拖拉这个"),v("code",[e._v("<div>")]),e._v("元素会自动带上文本数据"),v("code",[e._v("aaa")]),e._v("。")]),e._v(" "),v("p",[e._v("使用"),v("code",[e._v("setData")]),e._v("方法，可以替换到原有数据。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("<div\n  draggable=\"true\"\n  ondragstart=\"event.dataTransfer.setData('text/plain', 'bbb')\"\n>\n  aaa\n</div>\n")])])]),v("p",[e._v("上面代码中，拖拉数据实际上是"),v("code",[e._v("bbb")]),e._v("，而不是"),v("code",[e._v("aaa")]),e._v("。")]),e._v(" "),v("p",[e._v("下面是添加其他类型的数据。由于"),v("code",[e._v("text/plain")]),e._v("是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var dt = event.dataTransfer;\n\n// 添加链接\ndt.setData('text/uri-list', 'http://www.example.com');\ndt.setData('text/plain', 'http://www.example.com');\n\n// 添加 HTML 代码\ndt.setData('text/html', 'Hello there, <strong>stranger</strong>');\ndt.setData('text/plain', 'Hello there, <strong>stranger</strong>');\n\n// 添加图像的 URL\ndt.setData('text/uri-list', imageurl);\ndt.setData('text/plain', imageurl);\n")])])]),v("p",[e._v("可以一次提供多种格式的数据。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var dt = event.dataTransfer;\ndt.setData('application/x-bookmark', bookmarkString);\ndt.setData('text/uri-list', 'http://www.example.com');\ndt.setData('text/plain', 'http://www.example.com');\n")])])]),v("p",[e._v("上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，"),v("code",[e._v("drop")]),e._v("不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能"),v("code",[e._v("drop")]),e._v("（读取到）这个数据。")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-getdata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-getdata"}},[e._v("#")]),e._v(" DataTransfer.getData()")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.getData()")]),e._v("方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用"),v("code",[e._v("setData")]),e._v("方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有"),v("code",[e._v("drop")]),e._v("事件触发后，才能取出数据。")]),e._v(" "),v("p",[e._v("下面是一个"),v("code",[e._v("drop")]),e._v("事件的监听函数，用来取出指定类型的数据。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function onDrop(event) {\n  var data = event.dataTransfer.getData('text/plain');\n  event.target.textContent = data;\n  event.preventDefault();\n}\n")])])]),v("p",[e._v("上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。")]),e._v(" "),v("p",[v("code",[e._v("getData")]),e._v("方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function doDrop(event) {\n  var lines = event.dataTransfer.getData('text/uri-list').split('\\n');\n  for (let line of lines) {\n    let link = document.createElement('a');\n    link.href = line;\n    link.textContent = line;\n    event.target.appendChild(link);\n  }\n  event.preventDefault();\n}\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("getData")]),e._v("方法返回的是一组链接，就必须自行解析。")]),e._v(" "),v("p",[e._v("类型值指定为"),v("code",[e._v("URL")]),e._v("，可以取出第一个有效链接。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var link = event.dataTransfer.getData('URL');\n")])])]),v("p",[e._v("下面的例子是从多种类型的数据里面取出数据。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function doDrop(event) {\n  var types = event.dataTransfer.types;\n  var supportedTypes = ['text/uri-list', 'text/plain'];\n  types = supportedTypes.filter(function (value) { types.includes(value) });\n  if (types.length) {\n    var data = event.dataTransfer.getData(types[0]);\n  }\n  event.preventDefault();\n}\n")])])]),v("h4",{attrs:{id:"datatransfer-cleardata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-cleardata"}},[e._v("#")]),e._v(" DataTransfer.clearData()")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.clearData()")]),e._v("方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("event.dataTransfer.clearData('text/uri-list');\n")])])]),v("p",[e._v("上面代码清除事件所带的"),v("code",[e._v("text/uri-list")]),e._v("类型的数据。")]),e._v(" "),v("p",[e._v("该方法不会移除拖拉的文件，因此调用该方法后，"),v("code",[e._v("DataTransfer.types")]),e._v("属性可能依然会返回"),v("code",[e._v("Files")]),e._v("类型（前提是存在文件拖拉）。")]),e._v(" "),v("p",[e._v("注意，该方法只能在"),v("code",[e._v("dragstart")]),e._v("事件的监听函数之中使用，因为这是拖拉操作的数据唯一可写的时机。")]),e._v(" "),v("h4",{attrs:{id:"datatransfer-setdragimage"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-setdragimage"}},[e._v("#")]),e._v(" DataTransfer.setDragImage()")]),e._v(" "),v("p",[e._v("拖动过程中（"),v("code",[e._v("dragstart")]),e._v("事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。")]),e._v(" "),v("p",[v("code",[e._v("DataTransfer.setDragImage()")]),e._v("方法可以自定义这张图片。它接受三个参数。第一个是"),v("code",[e._v("<img>")]),e._v("节点或者"),v("code",[e._v("<canvas>")]),e._v("节点，如果省略或为"),v("code",[e._v("null")]),e._v("，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和纵坐标。")]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("/* HTML 代码如下\n <div id=\"drag-with-image\" class=\"dragdemo\" draggable=\"true\">\n   drag me\n </div>\n*/\n\nvar div = document.getElementById('drag-with-image');\ndiv.addEventListener('dragstart', function (e) {\n  var img = document.createElement('img');\n  img.src = 'http://path/to/img';\n  e.dataTransfer.setDragImage(img, 0, 0);\n}, false);\n")])])]),v("h2",{attrs:{id:"其他常见事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他常见事件"}},[e._v("#")]),e._v(" 其他常见事件")]),e._v(" "),v("h3",{attrs:{id:"资源事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#资源事件"}},[e._v("#")]),e._v(" 资源事件")]),e._v(" "),v("h4",{attrs:{id:"beforeunload-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforeunload-事件"}},[e._v("#")]),e._v(" beforeunload 事件")]),e._v(" "),v("p",[v("code",[e._v("beforeunload")]),e._v("事件在窗口、文档、各种资源将要卸载前触发。它可以用来防止用户不小心卸载资源。")]),e._v(" "),v("p",[e._v("如果该事件对象的"),v("code",[e._v("returnValue")]),e._v("属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('beforeunload', function (event) {\n  event.returnValue = '你确定离开吗？';\n});\n")])])]),v("p",[e._v("上面代码中，用户如果关闭窗口，浏览器会弹出一个窗口，要求用户确认。")]),e._v(" "),v("p",[e._v("浏览器对这个事件的行为很不一致，有的浏览器调用"),v("code",[e._v("event.preventDefault()")]),e._v("，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('beforeunload', function (e) {\n  var confirmationMessage = '确认关闭窗口？';\n\n  e.returnValue = confirmationMessage;\n  return confirmationMessage;\n});\n")])])]),v("p",[e._v("注意，许多手机浏览器（比如 Safari）默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭浏览器窗口，最好不要使用这个事件。")]),e._v(" "),v("p",[e._v("另外，一旦使用了"),v("code",[e._v("beforeunload")]),e._v("事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是为了网页状态，这时缓存页面的初始状态就没意义了。")]),e._v(" "),v("h4",{attrs:{id:"unload-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unload-事件"}},[e._v("#")]),e._v(" unload 事件")]),e._v(" "),v("p",[v("code",[e._v("unload")]),e._v("事件在窗口关闭或者"),v("code",[e._v("document")]),e._v("对象将要卸载时触发。它的触发顺序排在"),v("code",[e._v("beforeunload")]),e._v("、"),v("code",[e._v("pagehide")]),e._v("事件后面。")]),e._v(" "),v("p",[v("code",[e._v("unload")]),e._v("事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('unload', function(event) {\n  console.log('文档将要卸载');\n});\n")])])]),v("p",[e._v("手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟"),v("code",[e._v("beforeunload")]),e._v("事件一样，一旦使用了"),v("code",[e._v("unload")]),e._v("事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。")]),e._v(" "),v("p",[e._v("该事件可以用"),v("code",[e._v("pagehide")]),e._v("代替。")]),e._v(" "),v("h4",{attrs:{id:"load-事件-error-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#load-事件-error-事件"}},[e._v("#")]),e._v(" load 事件，error 事件")]),e._v(" "),v("p",[v("code",[e._v("load")]),e._v("事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发"),v("code",[e._v("load")]),e._v("事件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('load', function(event) {\n  console.log('所有资源都加载完成');\n});\n")])])]),v("p",[v("code",[e._v("error")]),e._v("事件是在页面或资源加载失败时触发。"),v("code",[e._v("abort")]),e._v("事件在用户取消加载时触发。")]),e._v(" "),v("p",[e._v("这三个事件实际上属于进度事件，不仅发生在"),v("code",[e._v("document")]),e._v("对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和"),v("code",[e._v("document")]),e._v("对象、"),v("code",[e._v("window")]),e._v("对象、XMLHttpRequestUpload 对象，都会触发"),v("code",[e._v("load")]),e._v("事件和"),v("code",[e._v("error")]),e._v("事件。")]),e._v(" "),v("p",[e._v("最后，页面的"),v("code",[e._v("load")]),e._v("事件也可以用"),v("code",[e._v("pageshow")]),e._v("事件代替。")]),e._v(" "),v("h3",{attrs:{id:"session-历史事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#session-历史事件"}},[e._v("#")]),e._v(" session 历史事件")]),e._v(" "),v("h4",{attrs:{id:"pageshow-事件-pagehide-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pageshow-事件-pagehide-事件"}},[e._v("#")]),e._v(" pageshow 事件，pagehide 事件")]),e._v(" "),v("p",[e._v("默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。")]),e._v(" "),v("p",[v("code",[e._v("pageshow")]),e._v("事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。")]),e._v(" "),v("p",[e._v("第一次加载时，它的触发顺序排在"),v("code",[e._v("load")]),e._v("事件后面。从缓存加载时，"),v("code",[e._v("load")]),e._v("事件不会触发，因为网页在缓存中的样子通常是"),v("code",[e._v("load")]),e._v("事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('pageshow', function(event) {\n  console.log('pageshow: ', event);\n});\n")])])]),v("p",[v("code",[e._v("pageshow")]),e._v("事件有一个"),v("code",[e._v("persisted")]),e._v("属性，返回一个布尔值。页面第一次加载时，这个属性是"),v("code",[e._v("false")]),e._v("；当页面从缓存加载时，这个属性是"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('pageshow', function(event){\n  if (event.persisted) {\n    // ...\n  }\n});\n")])])]),v("p",[v("code",[e._v("pagehide")]),e._v("事件与"),v("code",[e._v("pageshow")]),e._v("事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义"),v("code",[e._v("unload")]),e._v("事件的监听函数之后，页面不会保存在缓存中，而使用"),v("code",[e._v("pagehide")]),e._v("事件，页面会保存在缓存中。")]),e._v(" "),v("p",[v("code",[e._v("pagehide")]),e._v("事件实例也有一个"),v("code",[e._v("persisted")]),e._v("属性，将这个属性设为"),v("code",[e._v("true")]),e._v("，就表示页面要保存在缓存中；设为"),v("code",[e._v("false")]),e._v("，表示网页不保存在缓存中，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。")]),e._v(" "),v("p",[e._v("如果页面包含"),v("code",[e._v("<frame>")]),e._v("或"),v("code",[e._v("<iframe>")]),e._v("元素，则"),v("code",[e._v("<frame>")]),e._v("页面的"),v("code",[e._v("pageshow")]),e._v("事件和"),v("code",[e._v("pagehide")]),e._v("事件，都会在主页面之前触发。")]),e._v(" "),v("p",[e._v("注意，这两个事件只在浏览器的"),v("code",[e._v("history")]),e._v("对象发生变化时触发，跟网页是否可见没有关系。")]),e._v(" "),v("h4",{attrs:{id:"popstate-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#popstate-事件"}},[e._v("#")]),e._v(" popstate 事件")]),e._v(" "),v("p",[v("code",[e._v("popstate")]),e._v("事件在浏览器的"),v("code",[e._v("history")]),e._v("对象的当前记录发生显式切换时触发。注意，调用"),v("code",[e._v("history.pushState()")]),e._v("或"),v("code",[e._v("history.replaceState()")]),e._v("，并不会触发"),v("code",[e._v("popstate")]),e._v("事件。该事件只在用户在"),v("code",[e._v("history")]),e._v("记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用"),v("code",[e._v("history.back()")]),e._v("、"),v("code",[e._v("history.forward()")]),e._v("、"),v("code",[e._v("history.go()")]),e._v("时触发。")]),e._v(" "),v("p",[e._v("该事件对象有一个"),v("code",[e._v("state")]),e._v("属性，保存"),v("code",[e._v("history.pushState")]),e._v("方法和"),v("code",[e._v("history.replaceState")]),e._v("方法为当前记录添加的"),v("code",[e._v("state")]),e._v("对象。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.onpopstate = function (event) {\n  console.log('state: ' + event.state);\n};\nhistory.pushState({page: 1}, 'title 1', '?page=1');\nhistory.pushState({page: 2}, 'title 2', '?page=2');\nhistory.replaceState({page: 3}, 'title 3', '?page=3');\nhistory.back(); // state: {\"page\":1}\nhistory.back(); // state: null\nhistory.go(2);  // state: {\"page\":3}\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("pushState")]),e._v("方法向"),v("code",[e._v("history")]),e._v("添加了两条记录，然后"),v("code",[e._v("replaceState")]),e._v("方法替换掉当前记录。因此，连续两次"),v("code",[e._v("back")]),e._v("方法，会让当前条目退回到原始网址，它没有附带"),v("code",[e._v("state")]),e._v("对象，所以事件的"),v("code",[e._v("state")]),e._v("属性为"),v("code",[e._v("null")]),e._v("，然后前进两条记录，又回到"),v("code",[e._v("replaceState")]),e._v("方法添加的记录。")]),e._v(" "),v("p",[e._v("浏览器对于页面首次加载，是否触发"),v("code",[e._v("popstate")]),e._v("事件，处理不一样，Firefox 不触发该事件。")]),e._v(" "),v("h4",{attrs:{id:"hashchange-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashchange-事件"}},[e._v("#")]),e._v(" hashchange 事件")]),e._v(" "),v("p",[v("code",[e._v("hashchange")]),e._v("事件在 URL 的 hash 部分（即"),v("code",[e._v("#")]),e._v("号后面的部分，包括"),v("code",[e._v("#")]),e._v("号）发生变化时触发。该事件一般在"),v("code",[e._v("window")]),e._v("对象上监听。")]),e._v(" "),v("p",[v("code",[e._v("hashchange")]),e._v("的事件实例具有两个特有属性："),v("code",[e._v("oldURL")]),e._v("属性和"),v("code",[e._v("newURL")]),e._v("属性，分别表示变化前后的完整 URL。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// URL 是 http://www.example.com/\nwindow.addEventListener('hashchange', myFunction);\n\nfunction myFunction(e) {\n  console.log(e.oldURL);\n  console.log(e.newURL);\n}\n\nlocation.hash = 'part2';\n// http://www.example.com/\n// http://www.example.com/#part2\n")])])]),v("h3",{attrs:{id:"网页状态事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网页状态事件"}},[e._v("#")]),e._v(" 网页状态事件")]),e._v(" "),v("h4",{attrs:{id:"domcontentloaded-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded-事件"}},[e._v("#")]),e._v(" DOMContentLoaded 事件")]),e._v(" "),v("p",[e._v("网页下载并解析完成以后，浏览器就会在"),v("code",[e._v("document")]),e._v("对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比"),v("code",[e._v("load")]),e._v("事件，发生时间早得多。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.addEventListener('DOMContentLoaded', function (event) {\n  console.log('DOM生成');\n});\n")])])]),v("p",[e._v("注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发"),v("code",[e._v("DOMContentLoaded")]),e._v("事件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.addEventListener('DOMContentLoaded', function (event) {\n  console.log('DOM 生成');\n});\n\n// 这段代码会推迟触发 DOMContentLoaded 事件\nfor(var i = 0; i < 1000000000; i++) {\n  // ...\n}\n")])])]),v("h4",{attrs:{id:"readystatechange-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#readystatechange-事件"}},[e._v("#")]),e._v(" readystatechange 事件")]),e._v(" "),v("p",[v("code",[e._v("readystatechange")]),e._v("事件当 Document 对象和 XMLHttpRequest 对象的"),v("code",[e._v("readyState")]),e._v("属性发生变化时触发。"),v("code",[e._v("document.readyState")]),e._v("有三个可能的值："),v("code",[e._v("loading")]),e._v("（网页正在加载）、"),v("code",[e._v("interactive")]),e._v("（网页已经解析完成，但是外部资源仍然处在加载状态）和"),v("code",[e._v("complete")]),e._v("（网页和所有外部资源已经结束加载，"),v("code",[e._v("load")]),e._v("事件即将触发）。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.onreadystatechange = function () {\n  if (document.readyState === 'interactive') {\n    // ...\n  }\n}\n")])])]),v("p",[e._v("这个事件可以看作"),v("code",[e._v("DOMContentLoaded")]),e._v("事件的另一种实现方法。")]),e._v(" "),v("h3",{attrs:{id:"窗口事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#窗口事件"}},[e._v("#")]),e._v(" 窗口事件")]),e._v(" "),v("h4",{attrs:{id:"scroll-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scroll-事件"}},[e._v("#")]),e._v(" scroll 事件")]),e._v(" "),v("p",[v("code",[e._v("scroll")]),e._v("事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('scroll', callback);\n")])])]),v("p",[e._v("该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用"),v("code",[e._v("requestAnimationFrame")]),e._v("或"),v("code",[e._v("setTimeout")]),e._v("控制该事件的触发频率，然后可以结合"),v("code",[e._v("customEvent")]),e._v("抛出一个新事件。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("(function () {\n  var throttle = function (type, name, obj) {\n    var obj = obj || window;\n    var running = false;\n    var func = function () {\n      if (running) { return; }\n      running = true;\n      requestAnimationFrame(function() {\n        obj.dispatchEvent(new CustomEvent(name));\n        running = false;\n      });\n    };\n    obj.addEventListener(type, func);\n  };\n\n  // 将 scroll 事件转为 optimizedScroll 事件\n  throttle('scroll', 'optimizedScroll');\n})();\n\nwindow.addEventListener('optimizedScroll', function() {\n  console.log('Resource conscious scroll callback!');\n});\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("throttle()")]),e._v("函数用于控制事件触发频率，它有一个内部函数"),v("code",[e._v("func()")]),e._v("，每次"),v("code",[e._v("scroll")]),e._v("事件实际上触发的是这个函数。"),v("code",[e._v("func()")]),e._v("函数内部使用"),v("code",[e._v("requestAnimationFrame()")]),e._v("方法，保证只有每次页面重绘时（每秒60次），才可能会触发"),v("code",[e._v("optimizedScroll")]),e._v("事件，从而实际上将"),v("code",[e._v("scroll")]),e._v("事件转换为"),v("code",[e._v("optimizedScroll")]),e._v("事件，触发频率被控制在每秒最多60次。")]),e._v(" "),v("p",[e._v("改用"),v("code",[e._v("setTimeout()")]),e._v("方法，可以放置更大的时间间隔。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("(function() {\n  window.addEventListener('scroll', scrollThrottler, false);\n\n  var scrollTimeout;\n  function scrollThrottler() {\n    if (!scrollTimeout) {\n      scrollTimeout = setTimeout(function () {\n        scrollTimeout = null;\n        actualScrollHandler();\n      }, 66);\n    }\n  }\n\n  function actualScrollHandler() {\n    // ...\n  }\n}());\n")])])]),v("p",[e._v("上面代码中，每次"),v("code",[e._v("scroll")]),e._v("事件都会执行"),v("code",[e._v("scrollThrottler")]),e._v("函数。该函数里面有一个定时器"),v("code",[e._v("setTimeout")]),e._v("，每66毫秒触发一次（每秒15次）真正执行的任务"),v("code",[e._v("actualScrollHandler")]),e._v("。")]),e._v(" "),v("p",[e._v("下面是一个更一般的"),v("code",[e._v("throttle")]),e._v("函数的写法。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("function throttle(fn, wait) {\n  var time = Date.now();\n  return function() {\n    if ((time + wait - Date.now()) < 0) {\n      fn();\n      time = Date.now();\n    }\n  }\n}\n\nwindow.addEventListener('scroll', throttle(callback, 1000));\n")])])]),v("p",[e._v("上面的代码将"),v("code",[e._v("scroll")]),e._v("事件的触发频率，限制在一秒一次。")]),e._v(" "),v("p",[v("code",[e._v("lodash")]),e._v("函数库提供了现成的"),v("code",[e._v("throttle")]),e._v("函数，可以直接使用。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.addEventListener('scroll', _.throttle(callback, 1000));\n")])])]),v("p",[e._v("本书前面介绍过"),v("code",[e._v("debounce")]),e._v("的概念，"),v("code",[e._v("throttle")]),e._v("与它区别在于，"),v("code",[e._v("throttle")]),e._v("是“节流”，确保一段时间内只执行一次，而"),v("code",[e._v("debounce")]),e._v("是“防抖”，要连续操作结束后再执行。以网页滚动为例，"),v("code",[e._v("debounce")]),e._v("要等到用户停止滚动后才执行，"),v("code",[e._v("throttle")]),e._v("则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。")]),e._v(" "),v("h4",{attrs:{id:"resize-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#resize-事件"}},[e._v("#")]),e._v(" resize 事件")]),e._v(" "),v("p",[v("code",[e._v("resize")]),e._v("事件在改变浏览器窗口大小时触发，主要发生在"),v("code",[e._v("window")]),e._v("对象上面。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var resizeMethod = function () {\n  if (document.body.clientWidth < 768) {\n    console.log('移动设备的视口');\n  }\n};\n\nwindow.addEventListener('resize', resizeMethod, true);\n")])])]),v("p",[e._v("该事件也会连续地大量触发，所以最好像上面的"),v("code",[e._v("scroll")]),e._v("事件一样，通过"),v("code",[e._v("throttle")]),e._v("函数控制事件触发频率。")]),e._v(" "),v("h4",{attrs:{id:"fullscreenchange-事件-fullscreenerror-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fullscreenchange-事件-fullscreenerror-事件"}},[e._v("#")]),e._v(" fullscreenchange 事件，fullscreenerror 事件")]),e._v(" "),v("p",[v("code",[e._v("fullscreenchange")]),e._v("事件在进入或退出全屏状态时触发，该事件发生在"),v("code",[e._v("document")]),e._v("对象上面。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.addEventListener('fullscreenchange', function (event) {\n  console.log(document.fullscreenElement);\n});\n")])])]),v("p",[v("code",[e._v("fullscreenerror")]),e._v("事件在浏览器无法切换到全屏状态时触发。")]),e._v(" "),v("h3",{attrs:{id:"剪贴板事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#剪贴板事件"}},[e._v("#")]),e._v(" 剪贴板事件")]),e._v(" "),v("p",[e._v("以下三个事件属于剪贴板操作的相关事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("cut")]),e._v("：将选中的内容从文档中移除，加入剪贴板时触发。")]),e._v(" "),v("li",[v("code",[e._v("copy")]),e._v("：进行复制动作时触发。")]),e._v(" "),v("li",[v("code",[e._v("paste")]),e._v("：剪贴板内容粘贴到文档后触发。")])]),e._v(" "),v("p",[e._v("举例来说，如果希望禁止输入框的粘贴事件，可以使用下面的代码。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("inputElement.addEventListener('paste', e => e.preventDefault());\n")])])]),v("p",[e._v("上面的代码使得用户无法在"),v("code",[e._v("<input>")]),e._v("输入框里面粘贴内容。")]),e._v(" "),v("p",[v("code",[e._v("cut")]),e._v("、"),v("code",[e._v("copy")]),e._v("、"),v("code",[e._v("paste")]),e._v("这三个事件的事件对象都是"),v("code",[e._v("ClipboardEvent")]),e._v("接口的实例。"),v("code",[e._v("ClipboardEvent")]),e._v("有一个实例属性"),v("code",[e._v("clipboardData")]),e._v("，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.addEventListener('copy', function (e) {\n  e.clipboardData.setData('text/plain', 'Hello, world!');\n  e.clipboardData.setData('text/html', '<b>Hello, world!</b>');\n  e.preventDefault();\n});\n")])])]),v("p",[e._v("上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。")]),e._v(" "),v("h3",{attrs:{id:"焦点事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#焦点事件"}},[e._v("#")]),e._v(" 焦点事件")]),e._v(" "),v("p",[e._v("焦点事件发生在元素节点和"),v("code",[e._v("document")]),e._v("对象上面，与获得或失去焦点相关。它主要包括以下四个事件。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("focus")]),e._v("：元素节点获得焦点后触发，该事件不会冒泡。")]),e._v(" "),v("li",[v("code",[e._v("blur")]),e._v("：元素节点失去焦点后触发，该事件不会冒泡。")]),e._v(" "),v("li",[v("code",[e._v("focusin")]),e._v("：元素节点将要获得焦点时触发，发生在"),v("code",[e._v("focus")]),e._v("事件之前。该事件会冒泡。")]),e._v(" "),v("li",[v("code",[e._v("focusout")]),e._v("：元素节点将要失去焦点时触发，发生在"),v("code",[e._v("blur")]),e._v("事件之前。该事件会冒泡。")])]),e._v(" "),v("p",[e._v("这四个事件的事件对象都继承了"),v("code",[e._v("FocusEvent")]),e._v("接口。"),v("code",[e._v("FocusEvent")]),e._v("实例具有以下属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("FocusEvent.target")]),e._v("：事件的目标节点。")]),e._v(" "),v("li",[v("code",[e._v("FocusEvent.relatedTarget")]),e._v("：对于"),v("code",[e._v("focusin")]),e._v("事件，返回失去焦点的节点；对于"),v("code",[e._v("focusout")]),e._v("事件，返回将要接受焦点的节点；对于"),v("code",[e._v("focus")]),e._v("和"),v("code",[e._v("blur")]),e._v("事件，返回"),v("code",[e._v("null")]),e._v("。")])]),e._v(" "),v("p",[e._v("由于"),v("code",[e._v("focus")]),e._v("和"),v("code",[e._v("blur")]),e._v("事件不会冒泡，只能在捕获阶段触发，所以"),v("code",[e._v("addEventListener")]),e._v("方法的第三个参数需要设为"),v("code",[e._v("true")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("form.addEventListener('focus', function (event) {\n  event.target.style.background = 'pink';\n}, true);\n\nform.addEventListener('blur', function (event) {\n  event.target.style.background = '';\n}, true);\n")])])]),v("p",[e._v("上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。")]),e._v(" "),v("h3",{attrs:{id:"customevent-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#customevent-接口"}},[e._v("#")]),e._v(" CustomEvent 接口")]),e._v(" "),v("p",[e._v("CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。")]),e._v(" "),v("p",[e._v("浏览器原生提供"),v("code",[e._v("CustomEvent()")]),e._v("构造函数，用来生成 CustomEvent 事件实例。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("new CustomEvent(type, options)\n")])])]),v("p",[v("code",[e._v("CustomEvent()")]),e._v("构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。"),v("code",[e._v("CustomEvent")]),e._v("的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("detail")]),e._v("：表示事件的附带数据，默认为"),v("code",[e._v("null")]),e._v("。")])]),e._v(" "),v("p",[e._v("下面是一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var event = new CustomEvent('build', { 'detail': 'hello' });\n\nfunction eventHandler(e) {\n  console.log(e.detail);\n}\n\ndocument.body.addEventListener('build', function (e) {\n  console.log(e.detail);\n});\n\ndocument.body.dispatchEvent(event);\n")])])]),v("p",[e._v("上面代码中，我们手动定义了"),v("code",[e._v("build")]),e._v("事件。该事件触发后，会被监听到，从而输出该事件实例的"),v("code",[e._v("detail")]),e._v("属性（即字符串"),v("code",[e._v("hello")]),e._v("）。")]),e._v(" "),v("p",[e._v("下面是另一个例子。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("var myEvent = new CustomEvent('myevent', {\n  detail: {\n    foo: 'bar'\n  },\n  bubbles: true,\n  cancelable: false\n});\n\nel.addEventListener('myevent', function (event) {\n  console.log('Hello ' + event.detail.foo);\n});\n\nel.dispatchEvent(myEvent);\n")])])]),v("p",[e._v("上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有"),v("code",[e._v("detail")]),e._v("属性。")]),e._v(" "),v("h2",{attrs:{id:"globaleventhandlers-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-接口"}},[e._v("#")]),e._v(" GlobalEventHandlers 接口")]),e._v(" "),v("p",[e._v("指定事件的回调函数，推荐使用的方法是元素的"),v("code",[e._v("addEventListener")]),e._v("方法。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.addEventListener('click', clickHandler, false);\n")])])]),v("p",[e._v("除了之外，还有一种方法可以直接指定事件的回调函数。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("div.onclick = clickHandler;\n")])])]),v("p",[e._v("这个接口是由"),v("code",[e._v("GlobalEventHandlers")]),e._v("接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。")]),e._v(" "),v("p",[v("code",[e._v("HTMLElement")]),e._v("、"),v("code",[e._v("Document")]),e._v("和"),v("code",[e._v("Window")]),e._v("都继承了这个接口，也就是说，各种 HTML 元素、"),v("code",[e._v("document")]),e._v("对象、"),v("code",[e._v("window")]),e._v("对象上面都可以使用"),v("code",[e._v("GlobalEventHandlers")]),e._v("接口提供的属性。下面就列出这个接口提供的主要的事件属性。")]),e._v(" "),v("h3",{attrs:{id:"globaleventhandlers-onabort"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-onabort"}},[e._v("#")]),e._v(" GlobalEventHandlers.onabort")]),e._v(" "),v("p",[e._v("某个对象的"),v("code",[e._v("abort")]),e._v("事件（停止加载）发生时，就会调用"),v("code",[e._v("onabort")]),e._v("属性指定的回调函数。")]),e._v(" "),v("p",[e._v("各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在"),v("code",[e._v("<img>")]),e._v("元素上面。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// HTML 代码如下\n// <img src=\"example.jpg\" id=\"img\">\nvar img = document.getElementById('img');\nimg.onabort = function () {\n  console.log('image load aborted.');\n}\n")])])]),v("h3",{attrs:{id:"globaleventhandlers-onerror"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-onerror"}},[e._v("#")]),e._v(" GlobalEventHandlers.onerror")]),e._v(" "),v("p",[v("code",[e._v("error")]),e._v("事件发生时，就会调用"),v("code",[e._v("onerror")]),e._v("属性指定的回调函数。")]),e._v(" "),v("p",[v("code",[e._v("error")]),e._v("事件分成两种。")]),e._v(" "),v("p",[e._v("一种是 JavaScript 的运行时错误，这会传到"),v("code",[e._v("window")]),e._v("对象，导致"),v("code",[e._v("window.onerror()")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("window.onerror = function (message, source, lineno, colno, error) {\n  // ...\n}\n")])])]),v("p",[v("code",[e._v("window.onerror")]),e._v("的处理函数共接受五个参数，含义如下。")]),e._v(" "),v("ul",[v("li",[e._v("message：错误信息字符串")]),e._v(" "),v("li",[e._v("source：报错脚本的 URL")]),e._v(" "),v("li",[e._v("lineno：报错的行号，是一个整数")]),e._v(" "),v("li",[e._v("colno：报错的列号，是一个整数")]),e._v(" "),v("li",[e._v("error： 错误对象")])]),e._v(" "),v("p",[e._v("另一种是资源加载错误，比如"),v("code",[e._v("<img>")]),e._v("或"),v("code",[e._v("<script>")]),e._v("加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的"),v("code",[e._v("onerror")]),e._v("属性开始执行。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("element.onerror = function (event) {\n  // ...\n}\n")])])]),v("p",[e._v("注意，一般来说，资源的加载错误不会触发"),v("code",[e._v("window.onerror")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"globaleventhandlers-onload、globaleventhandlers-onloadstart"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-onload、globaleventhandlers-onloadstart"}},[e._v("#")]),e._v(" GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart")]),e._v(" "),v("p",[e._v("元素完成加载时，会触发"),v("code",[e._v("load")]),e._v("事件，执行"),v("code",[e._v("onload()")]),e._v("。它的典型使用场景是"),v("code",[e._v("window")]),e._v("对象和"),v("code",[e._v("<img>")]),e._v("元素。对于"),v("code",[e._v("window")]),e._v("对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发"),v("code",[e._v("load")]),e._v("事件。")]),e._v(" "),v("p",[e._v("对于"),v("code",[e._v("<img>")]),e._v("和"),v("code",[e._v("<video>")]),e._v("等元素，加载开始时还会触发"),v("code",[e._v("loadstart")]),e._v("事件，导致执行"),v("code",[e._v("onloadstart")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"globaleventhandlers-onfocus-globaleventhandlers-onblur"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-onfocus-globaleventhandlers-onblur"}},[e._v("#")]),e._v(" GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur")]),e._v(" "),v("p",[e._v("当前元素获得焦点时，会触发"),v("code",[e._v("element.onfocus")]),e._v("；失去焦点时，会触发"),v("code",[e._v("element.onblur")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('element.onfocus = function () {\n  console.log("onfocus event detected!");\n};\nelement.onblur = function () {\n  console.log("onblur event detected!");\n};\n')])])]),v("p",[e._v("注意，如果不是可以接受用户输入的元素，要触发"),v("code",[e._v("onfocus")]),e._v("，该元素必须有"),v("code",[e._v("tabindex")]),e._v("属性。")]),e._v(" "),v("h3",{attrs:{id:"globaleventhandlers-onscroll"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-onscroll"}},[e._v("#")]),e._v(" GlobalEventHandlers.onscroll")]),e._v(" "),v("p",[e._v("页面或元素滚动时，会触发"),v("code",[e._v("scroll")]),e._v("事件，导致执行"),v("code",[e._v("onscroll()")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"globaleventhandlers-oncontextmenu-globaleventhandlers-onshow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers-oncontextmenu-globaleventhandlers-onshow"}},[e._v("#")]),e._v(" GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow")]),e._v(" "),v("p",[e._v("用户在页面上按下鼠标的右键，会触发"),v("code",[e._v("contextmenu")]),e._v("事件，导致执行"),v("code",[e._v("oncontextmenu()")]),e._v("。如果该属性执行后返回"),v("code",[e._v("false")]),e._v("，就等于禁止了右键菜单。"),v("code",[e._v("document.oncontextmenu")]),e._v("与"),v("code",[e._v("window.oncontextmenu")]),e._v("效果一样。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("document.oncontextmenu = function () {\n  return false;\n};\n")])])]),v("p",[e._v("上面代码中，"),v("code",[e._v("oncontextmenu")]),e._v("属性执行后返回"),v("code",[e._v("false")]),e._v("，右键菜单就不会出现。")]),e._v(" "),v("p",[e._v("元素的右键菜单显示时，会触发该元素的"),v("code",[e._v("onshow")]),e._v("监听函数。")]),e._v(" "),v("h3",{attrs:{id:"其他的事件属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他的事件属性"}},[e._v("#")]),e._v(" 其他的事件属性")]),e._v(" "),v("p",[e._v("鼠标的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("onclick")]),e._v(" "),v("li",[e._v("ondblclick")]),e._v(" "),v("li",[e._v("onmousedown")]),e._v(" "),v("li",[e._v("onmouseenter")]),e._v(" "),v("li",[e._v("onmouseleave")]),e._v(" "),v("li",[e._v("onmousemove")]),e._v(" "),v("li",[e._v("onmouseout")]),e._v(" "),v("li",[e._v("onmouseover")]),e._v(" "),v("li",[e._v("onmouseup")]),e._v(" "),v("li",[e._v("onwheel")])]),e._v(" "),v("p",[e._v("键盘的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("onkeydown")]),e._v(" "),v("li",[e._v("onkeypress")]),e._v(" "),v("li",[e._v("onkeyup")])]),e._v(" "),v("p",[e._v("焦点的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("onblur")]),e._v(" "),v("li",[e._v("onfocus")])]),e._v(" "),v("p",[e._v("表单的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("oninput")]),e._v(" "),v("li",[e._v("onchange")]),e._v(" "),v("li",[e._v("onsubmit")]),e._v(" "),v("li",[e._v("onreset")]),e._v(" "),v("li",[e._v("oninvalid")]),e._v(" "),v("li",[e._v("onselect")])]),e._v(" "),v("p",[e._v("触摸的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("ontouchcancel")]),e._v(" "),v("li",[e._v("ontouchend")]),e._v(" "),v("li",[e._v("ontouchmove")]),e._v(" "),v("li",[e._v("ontouchstart")])]),e._v(" "),v("p",[e._v("拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。")]),e._v(" "),v("p",[e._v("被拖动元素的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("ondragstart：拖动开始")]),e._v(" "),v("li",[e._v("ondrag：拖动过程中，每隔几百毫秒触发一次")]),e._v(" "),v("li",[e._v("ondragend：拖动结束")])]),e._v(" "),v("p",[e._v("接收被拖动元素的容器元素的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("ondragenter：被拖动元素进入容器元素。")]),e._v(" "),v("li",[e._v("ondragleave：被拖动元素离开容器元素。")]),e._v(" "),v("li",[e._v("ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。")]),e._v(" "),v("li",[e._v("ondrop：松开鼠标后，被拖动元素放入容器元素。")])]),e._v(" "),v("p",[v("code",[e._v("<dialog>")]),e._v("对话框元素的事件属性。")]),e._v(" "),v("ul",[v("li",[e._v("oncancel")]),e._v(" "),v("li",[e._v("onclose")])])])}),[],!1,null,null,null);t.default=n.exports}}]);