(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{533:function(e,t,a){"use strict";a.r(t);var r=a(25),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"dubbo篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo篇"}},[e._v("#")]),e._v(" Dubbo篇")]),e._v(" "),a("p",[e._v("其实关于 Dubbo 的面试题，我觉得最好的文档应该还是官网，因为官网有中文版，照顾了很多阅读英文文档吃力的小伙伴。但是官网内容挺多的，于是这里就结合官网和平时面试被问的相对较多 的题目整理了一下。")]),e._v(" "),a("h2",{attrs:{id:"_1、-说说一次-dubbo-服务请求流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、-说说一次-dubbo-服务请求流程"}},[e._v("#")]),e._v(" 1、 说说一次 Dubbo 服务请求流程？")]),e._v(" "),a("p",[e._v("基本工作流程：")]),e._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:"media/image1.jpeg",alt:""}}),e._v('{width="6.844444444444444in" height="4.475694444444445in"}')])]),e._v(" "),a("p",[e._v("上图中角色说明：")]),e._v(" "),a("p",[a("img",{attrs:{src:"media/image2.png",alt:""}}),e._v('{width="4.5625in" height="2.3229166666666665in"}')]),e._v(" "),a("h2",{attrs:{id:"_2、说说-dubbo-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、说说-dubbo-工作原理"}},[e._v("#")]),e._v(" 2、说说 Dubbo 工作原理")]),e._v(" "),a("p",[e._v("工作原理分 10 层：")]),e._v(" "),a("blockquote",[a("p",[e._v("第一层：service 层，接口层，给服务提供者和消费者来实现的（留给开发人员来实现）； 第二层：conﬁg 层，配置层，主要是对 Dubbo 进行各种配置的，Dubbo 相关配置；")]),e._v(" "),a("p",[e._v("第三层：proxy 层，服务代理层，透明生成客户端的 stub 和服务单的 skeleton，调用的是接口，实现类没有，所以得生成代理，代理之间再进行网络通讯、负责均衡等；")]),e._v(" "),a("p",[e._v("第四层：registry 层，服务注册层，负责服务的注册与发现；")]),e._v(" "),a("p",[e._v("第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务；")]),e._v(" "),a("p",[e._v("第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控； 第七层：protocol 层，远程调用层，封装 rpc 调用；")]),e._v(" "),a("p",[e._v("第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步； 第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口； 第十层：serialize 层，数据序列化层。")])]),e._v(" "),a("p",[e._v("这是个很坑爹的面试题，但是很多面试官又喜欢问，你真的要背么？你能背那还是不错的，我建议 不要背，你就想想 Dubbo 服务调用过程中应该会涉及到哪些技术，把这些技术串起来就 OK 了。")]),e._v(" "),a("h4",{attrs:{id:"面试扩散"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试扩散"}},[e._v("#")]),e._v(" 面试扩散")]),e._v(" "),a("p",[e._v("如果让你设计一个 RPC 框架，你会怎么做？其实你就把上面这个工作原理中涉及的到技术点总结一下就行了。")]),e._v(" "),a("h2",{attrs:{id:"_3、dubbo-支持哪些协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、dubbo-支持哪些协议"}},[e._v("#")]),e._v(" 3、Dubbo 支持哪些协议？")]),e._v(" "),a("p",[a("img",{attrs:{src:"media/image3.png",alt:""}}),e._v('{width="6.764583333333333in" height="2.4965277777777777in"}')]),e._v(" "),a("p",[e._v("还有三种，混个眼熟就行：Memcached 协议、Redis 协议、Rest 协议。上图基本上把序列化的方式也罗列出来了。")]),e._v(" "),a("p",[e._v("详细请参考："),a("span",{staticClass:"underline"},[e._v("Dubbo 官网")]),e._v("："),a("span",{staticClass:"underline"},[e._v("http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dub")]),e._v(" "),a("span",{staticClass:"underline"},[e._v("bo.html")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"_4、注册中心挂了-consumer-还能不能调用-provider"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、注册中心挂了-consumer-还能不能调用-provider"}},[e._v("#")]),e._v(" 4、注册中心挂了，consumer 还能不能调用 provider？")]),e._v(" "),a("p",[e._v("可以。因为刚开始初始化的时候，consumer 会将需要的所有提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。但是 provider 挂了，那就没法调用了。")]),e._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:"media/image4.jpeg",alt:""}}),e._v('{width="6.805555555555555in" height="3.272222222222222in"}')])]),e._v(" "),a("p",[e._v("关键字：consumer 本地缓存服务列表。")]),e._v(" "),a("h2",{attrs:{id:"_5、怎么实现动态感知服务下线的呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、怎么实现动态感知服务下线的呢"}},[e._v("#")]),e._v(" 5、怎么实现动态感知服务下线的呢？")]),e._v(" "),a("blockquote",[a("p",[a("img",{attrs:{src:"media/image5.jpeg",alt:""}}),e._v('{width="5.041666666666667in" height="8.666666666666666in"}')])]),e._v(" "),a("p",[e._v("服务订阅通常有 pull 和 push 两种方式：")]),e._v(" "),a("blockquote",[a("p",[e._v("pull 模式需要客户端定时向注册中心拉取配置；")]),e._v(" "),a("p",[e._v("push 模式采用注册中心主动推送数据给客户端。")])]),e._v(" "),a("p",[e._v("Dubbo ZooKeeper 注册中心采用是事件通知与客户端拉取方式。服务第一次订阅的时候将会拉取对应目录下全量数据，然后在订阅的节点注册一个 watcher。一旦目录节点下发生任何数据变化， ZooKeeper 将会通过 watcher 通知客户端。客户端接到通知，将会重新拉取该目录下全量数据， 并重新注册 watcher。利用这个模式，Dubbo 服务就可以做到服务的动态发现。")]),e._v(" "),a("p",[e._v('注意：ZooKeeper 提供了"心跳检测"功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经"挂了"，并将其剔除。')]),e._v(" "),a("h2",{attrs:{id:"_6、dubbo-负载均衡策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、dubbo-负载均衡策略"}},[e._v("#")]),e._v(" 6、Dubbo 负载均衡策略？")]),e._v(" "),a("blockquote",[a("p",[e._v("随机（默认）：随机来轮训：一个一个来")]),e._v(" "),a("p",[e._v("活跃度：机器活跃度来负载")]),e._v(" "),a("p",[e._v("一致性 hash：落到同一台机器上")])]),e._v(" "),a("h2",{attrs:{id:"_7、-dubbo-容错策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、-dubbo-容错策略"}},[e._v("#")]),e._v(" 7、 Dubbo 容错策略")]),e._v(" "),a("h4",{attrs:{id:"failover-cluster-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-cluster-模式"}},[e._v("#")]),e._v(" failover cluster 模式")]),e._v(" "),a("p",[e._v("provider 宕机重试以后，请求会分到其他的 provider 上，默认两次，可以手动设置重试次数，建议把写操作重试次数设置成 0。")]),e._v(" "),a("h4",{attrs:{id:"failback-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failback-模式"}},[e._v("#")]),e._v(" failback 模式")]),e._v(" "),a("p",[e._v("失败自动恢复会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行 重试，适合执行消息通知等操作。")]),e._v(" "),a("h4",{attrs:{id:"failfast-cluster-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failfast-cluster-模式"}},[e._v("#")]),e._v(" failfast cluster 模式")]),e._v(" "),a("p",[e._v("快速失败只会进行一次调用，失败后立即抛出异常。适用于幂等操作、写操作，类似于 failover cluster 模式中重试次数设置为 0 的情况。")]),e._v(" "),a("h4",{attrs:{id:"failsafe-cluster-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failsafe-cluster-模式"}},[e._v("#")]),e._v(" failsafe cluster 模式")]),e._v(" "),a("p",[e._v("失败安全是指，当调用过程中出现异常时，仅会打印异常，而不会抛出异常。适用于写入审计日志 等操作。")]),e._v(" "),a("h4",{attrs:{id:"forking-cluster-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forking-cluster-模式"}},[e._v("#")]),e._v(" forking cluster 模式")]),e._v(" "),a("p",[e._v("并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多")]),e._v(" "),a("p",[e._v("服务资源。可通过")]),e._v(" "),a("h4",{attrs:{id:"broadcacst-cluster-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#broadcacst-cluster-模式"}},[e._v("#")]),e._v(" broadcacst cluster 模式")]),e._v(" "),a("p",[e._v("来设置最大并行数。")]),e._v(" "),a("p",[e._v("广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志 等本地资源信息。")]),e._v(" "),a("h2",{attrs:{id:"_8、dubbo-动态代理策略有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、dubbo-动态代理策略有哪些"}},[e._v("#")]),e._v(" 8、Dubbo 动态代理策略有哪些？")]),e._v(" "),a("p",[e._v("默认使用 javassist 动态字节码生成，创建代理类，但是可以通过 SPI 扩展机制配置自己的动态代理策略。")]),e._v(" "),a("h2",{attrs:{id:"_9、说说-dubbo-与-spring-cloud-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、说说-dubbo-与-spring-cloud-的区别"}},[e._v("#")]),e._v(" 9、说说 Dubbo 与 Spring Cloud 的区别？")]),e._v(" "),a("p",[e._v("这是很多面试官喜欢问的问题，本人认为其实他们没什么关联之处，但是硬是要问区别，那就说说 吧。")]),e._v(" "),a("p",[e._v("回答的时候主要围绕着四个关键点来说：通信方式、注册中心、监控、断路器，其余像 Spring 分布式配置、服务网关肯定得知道。")]),e._v(" "),a("h4",{attrs:{id:"通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通信方式"}},[e._v("#")]),e._v(" 通信方式")]),e._v(" "),a("p",[e._v("Dubbo 使用的是 RPC 通信；Spring Cloud 使用的是 HTTP RestFul 方式。"),a("strong",[e._v("注册中心")])]),e._v(" "),a("p",[e._v("Dubbo 使用 ZooKeeper（官方推荐），还有 Redis、Multicast、Simple 注册中心，但不推荐。；")]),e._v(" "),a("p",[e._v("Spring Cloud 使用的是 Spring Cloud Netﬂix Eureka。"),a("strong",[e._v("监控")])]),e._v(" "),a("p",[e._v("Dubbo 使用的是 Dubbo-monitor；Spring Cloud 使用的是 Spring Boot admin。"),a("strong",[e._v("断路器")])]),e._v(" "),a("p",[e._v("Dubbo 在断路器这方面还不完善，Spring Cloud 使用的是 Spring Cloud Netﬂix Hystrix。分布式配置、网关服务、服务跟踪、消息总线、批量任务等。")]),e._v(" "),a("p",[e._v("Dubbo 目前可以说还是空白，而 Spring Cloud 都有相应的组件来支撑。")]),e._v(" "),a("h2",{attrs:{id:"_10、zookeeper-和-dubbo-的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、zookeeper-和-dubbo-的关系"}},[e._v("#")]),e._v(" 10、Zookeeper 和 Dubbo 的关系？")]),e._v(" "),a("h4",{attrs:{id:"zookeeper的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper的作用"}},[e._v("#")]),e._v(" Zookeeper的作用")]),e._v(" "),a("p",[e._v("zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简 单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方 业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉 的机器提供服务。zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系 从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提 高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。")]),e._v(" "),a("h4",{attrs:{id:"dubbo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dubbo"}},[e._v("#")]),e._v(" dubbo")]),e._v(" "),a("p",[e._v("是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo 提供一个框架解决这个问题。 注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的 注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。")]),e._v(" "),a("h4",{attrs:{id:"zookeeper和dubbo的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper和dubbo的关系"}},[e._v("#")]),e._v(" zookeeper和dubbo的关系")]),e._v(" "),a("p",[e._v("Dubbo 的将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有")]),e._v(" "),a("p",[e._v("ZooKeeper，Memcached，Redis 等。")]),e._v(" "),a("p",[e._v("引入了 ZooKeeper 作为存储媒介，也就把 ZooKeeper 的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 ZooKeeper 群配合相应的 Web 应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不 够，节点之间的数据和资源需要同步，ZooKeeper 集群就天然具备有这样的功能；命名 服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向 ZooKeeper 上的")]),e._v(" "),a("p",[e._v("指定节点 目录下写入自己的 URL 地址，这个操作就完成了服")]),e._v(" "),a("p",[e._v("务的发布。 其他特性还有 Mast 选举，分布式锁等"),a("img",{attrs:{src:"media/image6.jpeg",alt:""}}),e._v('{width="5.208333333333333in" height="3.0in"}')])])}),[],!1,null,null,null);t.default=s.exports}}]);