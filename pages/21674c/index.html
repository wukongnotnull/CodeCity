<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据类型 | 悟空非空也</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="keywords" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.4a9c0c84.css" as="style"><link rel="preload" href="/assets/js/app.0772105c.js" as="script"><link rel="preload" href="/assets/js/2.6497fd29.js" as="script"><link rel="preload" href="/assets/js/210.c5ddee43.js" as="script"><link rel="prefetch" href="/assets/js/10.0a7a5c2a.js"><link rel="prefetch" href="/assets/js/100.6dd9a587.js"><link rel="prefetch" href="/assets/js/101.b1cb7166.js"><link rel="prefetch" href="/assets/js/102.6a888436.js"><link rel="prefetch" href="/assets/js/103.075294d1.js"><link rel="prefetch" href="/assets/js/104.7f9d5a4c.js"><link rel="prefetch" href="/assets/js/105.bcc3dd3e.js"><link rel="prefetch" href="/assets/js/106.9cadb287.js"><link rel="prefetch" href="/assets/js/107.1d6b3af1.js"><link rel="prefetch" href="/assets/js/108.7377cb7f.js"><link rel="prefetch" href="/assets/js/109.ca3ceab0.js"><link rel="prefetch" href="/assets/js/11.961408a3.js"><link rel="prefetch" href="/assets/js/110.79c5c987.js"><link rel="prefetch" href="/assets/js/111.63b3d196.js"><link rel="prefetch" href="/assets/js/112.ced4f0e9.js"><link rel="prefetch" href="/assets/js/113.657daa4e.js"><link rel="prefetch" href="/assets/js/114.e5d0a86b.js"><link rel="prefetch" href="/assets/js/115.a89005f0.js"><link rel="prefetch" href="/assets/js/116.bcbccecc.js"><link rel="prefetch" href="/assets/js/117.7acf9f16.js"><link rel="prefetch" href="/assets/js/118.75e4e713.js"><link rel="prefetch" href="/assets/js/119.0395ec5d.js"><link rel="prefetch" href="/assets/js/12.aab67183.js"><link rel="prefetch" href="/assets/js/120.93179733.js"><link rel="prefetch" href="/assets/js/121.e80fc142.js"><link rel="prefetch" href="/assets/js/122.41a175f0.js"><link rel="prefetch" href="/assets/js/123.028fd9cd.js"><link rel="prefetch" href="/assets/js/124.100b1fb0.js"><link rel="prefetch" href="/assets/js/125.13d51556.js"><link rel="prefetch" href="/assets/js/126.02c987a2.js"><link rel="prefetch" href="/assets/js/127.f7e115fe.js"><link rel="prefetch" href="/assets/js/128.eb930737.js"><link rel="prefetch" href="/assets/js/129.29fef1d1.js"><link rel="prefetch" href="/assets/js/13.7dd23d29.js"><link rel="prefetch" href="/assets/js/130.7e4c3bbc.js"><link rel="prefetch" href="/assets/js/131.16f04a03.js"><link rel="prefetch" href="/assets/js/132.c811b5cf.js"><link rel="prefetch" href="/assets/js/133.4a0d2ee8.js"><link rel="prefetch" href="/assets/js/134.aa288243.js"><link rel="prefetch" href="/assets/js/135.7d74b67e.js"><link rel="prefetch" href="/assets/js/136.f6a4d7dc.js"><link rel="prefetch" href="/assets/js/137.4a8c94fa.js"><link rel="prefetch" href="/assets/js/138.30103e18.js"><link rel="prefetch" href="/assets/js/139.cb62e822.js"><link rel="prefetch" href="/assets/js/14.7a045a57.js"><link rel="prefetch" href="/assets/js/140.4849d011.js"><link rel="prefetch" href="/assets/js/141.b53f0217.js"><link rel="prefetch" href="/assets/js/142.d2e12f6f.js"><link rel="prefetch" href="/assets/js/143.41effcfd.js"><link rel="prefetch" href="/assets/js/144.5ed3025f.js"><link rel="prefetch" href="/assets/js/145.ec71ac40.js"><link rel="prefetch" href="/assets/js/146.dc482dc8.js"><link rel="prefetch" href="/assets/js/147.f43c3786.js"><link rel="prefetch" href="/assets/js/148.e60884a5.js"><link rel="prefetch" href="/assets/js/149.fd305860.js"><link rel="prefetch" href="/assets/js/15.b07b6e42.js"><link rel="prefetch" href="/assets/js/150.e294561d.js"><link rel="prefetch" href="/assets/js/151.5cda3c43.js"><link rel="prefetch" href="/assets/js/152.ec1bec3f.js"><link rel="prefetch" href="/assets/js/153.411bc769.js"><link rel="prefetch" href="/assets/js/154.d0b70cd8.js"><link rel="prefetch" href="/assets/js/155.8013985e.js"><link rel="prefetch" href="/assets/js/156.9e9c91f4.js"><link rel="prefetch" href="/assets/js/157.0273d672.js"><link rel="prefetch" href="/assets/js/158.2612db04.js"><link rel="prefetch" href="/assets/js/159.9942bd3a.js"><link rel="prefetch" href="/assets/js/16.511be8ae.js"><link rel="prefetch" href="/assets/js/160.69e027a9.js"><link rel="prefetch" href="/assets/js/161.3d0255ab.js"><link rel="prefetch" href="/assets/js/162.4f223488.js"><link rel="prefetch" href="/assets/js/163.aca282a2.js"><link rel="prefetch" href="/assets/js/164.68c99b46.js"><link rel="prefetch" href="/assets/js/165.f455fb7b.js"><link rel="prefetch" href="/assets/js/166.a4d94e8d.js"><link rel="prefetch" href="/assets/js/167.dad8c77e.js"><link rel="prefetch" href="/assets/js/168.cb0717be.js"><link rel="prefetch" href="/assets/js/169.61a9bd6a.js"><link rel="prefetch" href="/assets/js/17.bbcfeede.js"><link rel="prefetch" href="/assets/js/170.f3785783.js"><link rel="prefetch" href="/assets/js/171.238d90d3.js"><link rel="prefetch" href="/assets/js/172.63852414.js"><link rel="prefetch" href="/assets/js/173.613fce9e.js"><link rel="prefetch" href="/assets/js/174.761ee99c.js"><link rel="prefetch" href="/assets/js/175.f2953a9b.js"><link rel="prefetch" href="/assets/js/176.415405fd.js"><link rel="prefetch" href="/assets/js/177.5c3782be.js"><link rel="prefetch" href="/assets/js/178.7c081109.js"><link rel="prefetch" href="/assets/js/179.038faa2b.js"><link rel="prefetch" href="/assets/js/18.c6108eaa.js"><link rel="prefetch" href="/assets/js/180.f498ca2e.js"><link rel="prefetch" href="/assets/js/181.ec14688f.js"><link rel="prefetch" href="/assets/js/182.1279a689.js"><link rel="prefetch" href="/assets/js/183.ced575fe.js"><link rel="prefetch" href="/assets/js/184.34f3c06c.js"><link rel="prefetch" href="/assets/js/185.b3d1acb8.js"><link rel="prefetch" href="/assets/js/186.b6efd99e.js"><link rel="prefetch" href="/assets/js/187.9b3f72f6.js"><link rel="prefetch" href="/assets/js/188.2e66f79c.js"><link rel="prefetch" href="/assets/js/189.4d12400d.js"><link rel="prefetch" href="/assets/js/19.192ec262.js"><link rel="prefetch" href="/assets/js/190.e353d2e5.js"><link rel="prefetch" href="/assets/js/191.7d655069.js"><link rel="prefetch" href="/assets/js/192.c33b286e.js"><link rel="prefetch" href="/assets/js/193.c9f461d3.js"><link rel="prefetch" href="/assets/js/194.32fdc071.js"><link rel="prefetch" href="/assets/js/195.03c708fc.js"><link rel="prefetch" href="/assets/js/196.54c890cf.js"><link rel="prefetch" href="/assets/js/197.68d0761d.js"><link rel="prefetch" href="/assets/js/198.efdf4f70.js"><link rel="prefetch" href="/assets/js/199.abaad0a6.js"><link rel="prefetch" href="/assets/js/20.d04c28bc.js"><link rel="prefetch" href="/assets/js/200.bd80bb59.js"><link rel="prefetch" href="/assets/js/201.4316ce7c.js"><link rel="prefetch" href="/assets/js/202.182fb8ad.js"><link rel="prefetch" href="/assets/js/203.7c514243.js"><link rel="prefetch" href="/assets/js/204.622bbe90.js"><link rel="prefetch" href="/assets/js/205.28f69f06.js"><link rel="prefetch" href="/assets/js/206.0c4c24eb.js"><link rel="prefetch" href="/assets/js/207.ea976c79.js"><link rel="prefetch" href="/assets/js/208.c4f49e55.js"><link rel="prefetch" href="/assets/js/209.4e2dacde.js"><link rel="prefetch" href="/assets/js/21.d8b6c127.js"><link rel="prefetch" href="/assets/js/211.2db8e6bf.js"><link rel="prefetch" href="/assets/js/212.9e5c2afe.js"><link rel="prefetch" href="/assets/js/213.9fc56fcc.js"><link rel="prefetch" href="/assets/js/214.b22b8fd0.js"><link rel="prefetch" href="/assets/js/215.b714511d.js"><link rel="prefetch" href="/assets/js/216.4045669d.js"><link rel="prefetch" href="/assets/js/217.b8bfc481.js"><link rel="prefetch" href="/assets/js/218.4cc6231a.js"><link rel="prefetch" href="/assets/js/219.b04f0864.js"><link rel="prefetch" href="/assets/js/22.a21d9c67.js"><link rel="prefetch" href="/assets/js/220.5c5efc16.js"><link rel="prefetch" href="/assets/js/221.b3cc4226.js"><link rel="prefetch" href="/assets/js/222.14568620.js"><link rel="prefetch" href="/assets/js/223.5ad9c326.js"><link rel="prefetch" href="/assets/js/224.bef27670.js"><link rel="prefetch" href="/assets/js/225.7e76ba96.js"><link rel="prefetch" href="/assets/js/226.c892c0a5.js"><link rel="prefetch" href="/assets/js/227.1a5c5dfe.js"><link rel="prefetch" href="/assets/js/228.a83d26e3.js"><link rel="prefetch" href="/assets/js/229.f69558a4.js"><link rel="prefetch" href="/assets/js/23.e6bed599.js"><link rel="prefetch" href="/assets/js/230.975e6807.js"><link rel="prefetch" href="/assets/js/231.3323c121.js"><link rel="prefetch" href="/assets/js/232.69b5135e.js"><link rel="prefetch" href="/assets/js/233.f27782e6.js"><link rel="prefetch" href="/assets/js/234.c1e937f3.js"><link rel="prefetch" href="/assets/js/235.500694bc.js"><link rel="prefetch" href="/assets/js/236.6b6f2f84.js"><link rel="prefetch" href="/assets/js/237.a529e2ba.js"><link rel="prefetch" href="/assets/js/238.d5bca3eb.js"><link rel="prefetch" href="/assets/js/239.0b79bd7b.js"><link rel="prefetch" href="/assets/js/24.1be4b8e9.js"><link rel="prefetch" href="/assets/js/240.baec5139.js"><link rel="prefetch" href="/assets/js/241.eef96f93.js"><link rel="prefetch" href="/assets/js/242.8208455c.js"><link rel="prefetch" href="/assets/js/243.4c8fdc98.js"><link rel="prefetch" href="/assets/js/244.e11ee13c.js"><link rel="prefetch" href="/assets/js/245.b1e7beba.js"><link rel="prefetch" href="/assets/js/246.4c24ee87.js"><link rel="prefetch" href="/assets/js/247.f3958ef5.js"><link rel="prefetch" href="/assets/js/248.3f533151.js"><link rel="prefetch" href="/assets/js/249.6d80f1cd.js"><link rel="prefetch" href="/assets/js/25.7420391b.js"><link rel="prefetch" href="/assets/js/250.2faf865a.js"><link rel="prefetch" href="/assets/js/251.88d81ef7.js"><link rel="prefetch" href="/assets/js/252.04a6a69c.js"><link rel="prefetch" href="/assets/js/253.32528c6e.js"><link rel="prefetch" href="/assets/js/254.312c70ad.js"><link rel="prefetch" href="/assets/js/255.ff88a488.js"><link rel="prefetch" href="/assets/js/256.8b782088.js"><link rel="prefetch" href="/assets/js/257.1e04db72.js"><link rel="prefetch" href="/assets/js/258.6b8e65a8.js"><link rel="prefetch" href="/assets/js/259.c1a78951.js"><link rel="prefetch" href="/assets/js/26.b979a08f.js"><link rel="prefetch" href="/assets/js/260.2910b3b5.js"><link rel="prefetch" href="/assets/js/261.b3c9ff4f.js"><link rel="prefetch" href="/assets/js/262.a4846d38.js"><link rel="prefetch" href="/assets/js/263.2fe51a99.js"><link rel="prefetch" href="/assets/js/264.790ac186.js"><link rel="prefetch" href="/assets/js/265.2da80512.js"><link rel="prefetch" href="/assets/js/266.86531545.js"><link rel="prefetch" href="/assets/js/267.2d8df6ee.js"><link rel="prefetch" href="/assets/js/268.caf4f057.js"><link rel="prefetch" href="/assets/js/269.5cb1755d.js"><link rel="prefetch" href="/assets/js/27.46acb058.js"><link rel="prefetch" href="/assets/js/270.93b039ff.js"><link rel="prefetch" href="/assets/js/271.a83d9432.js"><link rel="prefetch" href="/assets/js/272.f957cb9b.js"><link rel="prefetch" href="/assets/js/273.00fda4c5.js"><link rel="prefetch" href="/assets/js/274.90d11b33.js"><link rel="prefetch" href="/assets/js/275.a5ab6a4b.js"><link rel="prefetch" href="/assets/js/276.e1553171.js"><link rel="prefetch" href="/assets/js/277.fc579c76.js"><link rel="prefetch" href="/assets/js/278.eecaef76.js"><link rel="prefetch" href="/assets/js/279.4ccbe5fd.js"><link rel="prefetch" href="/assets/js/28.d679a88b.js"><link rel="prefetch" href="/assets/js/280.1a2df8d1.js"><link rel="prefetch" href="/assets/js/281.4d879315.js"><link rel="prefetch" href="/assets/js/282.1a638b6e.js"><link rel="prefetch" href="/assets/js/283.35d77274.js"><link rel="prefetch" href="/assets/js/284.236f6c0d.js"><link rel="prefetch" href="/assets/js/285.f911dc9c.js"><link rel="prefetch" href="/assets/js/286.f2032fe0.js"><link rel="prefetch" href="/assets/js/287.47be0dd9.js"><link rel="prefetch" href="/assets/js/288.805d6e1e.js"><link rel="prefetch" href="/assets/js/289.af37d311.js"><link rel="prefetch" href="/assets/js/29.9fb32fde.js"><link rel="prefetch" href="/assets/js/290.cc34cbe3.js"><link rel="prefetch" href="/assets/js/291.887bcdbb.js"><link rel="prefetch" href="/assets/js/292.88848329.js"><link rel="prefetch" href="/assets/js/293.c5e4486a.js"><link rel="prefetch" href="/assets/js/294.4cc2aedf.js"><link rel="prefetch" href="/assets/js/295.1072aab8.js"><link rel="prefetch" href="/assets/js/296.1b0b3008.js"><link rel="prefetch" href="/assets/js/297.0f879887.js"><link rel="prefetch" href="/assets/js/298.516a7d92.js"><link rel="prefetch" href="/assets/js/299.a039e1fa.js"><link rel="prefetch" href="/assets/js/3.8f0b1c2b.js"><link rel="prefetch" href="/assets/js/30.49c708c9.js"><link rel="prefetch" href="/assets/js/300.d7f284d1.js"><link rel="prefetch" href="/assets/js/301.d0b1dd6f.js"><link rel="prefetch" href="/assets/js/302.4b55dd23.js"><link rel="prefetch" href="/assets/js/303.feb01496.js"><link rel="prefetch" href="/assets/js/304.3ab97c4d.js"><link rel="prefetch" href="/assets/js/305.591a1558.js"><link rel="prefetch" href="/assets/js/306.adb43a3c.js"><link rel="prefetch" href="/assets/js/307.b05d288b.js"><link rel="prefetch" href="/assets/js/308.4567d4af.js"><link rel="prefetch" href="/assets/js/309.72c51c16.js"><link rel="prefetch" href="/assets/js/31.11f8cedc.js"><link rel="prefetch" href="/assets/js/310.3962fc11.js"><link rel="prefetch" href="/assets/js/311.75aa7b05.js"><link rel="prefetch" href="/assets/js/312.9ec9fde7.js"><link rel="prefetch" href="/assets/js/313.d6f6baa3.js"><link rel="prefetch" href="/assets/js/314.86cdfa89.js"><link rel="prefetch" href="/assets/js/315.25959c53.js"><link rel="prefetch" href="/assets/js/316.8fa91955.js"><link rel="prefetch" href="/assets/js/317.4248ad4c.js"><link rel="prefetch" href="/assets/js/318.3f9ca0c5.js"><link rel="prefetch" href="/assets/js/319.32be3008.js"><link rel="prefetch" href="/assets/js/32.4e2e98b3.js"><link rel="prefetch" href="/assets/js/320.b8a7b72b.js"><link rel="prefetch" href="/assets/js/321.a3f7c1a6.js"><link rel="prefetch" href="/assets/js/322.d0903e0c.js"><link rel="prefetch" href="/assets/js/323.99520c43.js"><link rel="prefetch" href="/assets/js/324.333a4f10.js"><link rel="prefetch" href="/assets/js/325.e502b8f9.js"><link rel="prefetch" href="/assets/js/326.8e57faf4.js"><link rel="prefetch" href="/assets/js/327.f0473fc3.js"><link rel="prefetch" href="/assets/js/328.eaa4bf5f.js"><link rel="prefetch" href="/assets/js/329.dc0763f7.js"><link rel="prefetch" href="/assets/js/33.90114516.js"><link rel="prefetch" href="/assets/js/330.1f60cb6e.js"><link rel="prefetch" href="/assets/js/331.4af5e363.js"><link rel="prefetch" href="/assets/js/332.2a2023db.js"><link rel="prefetch" href="/assets/js/333.4c5db27a.js"><link rel="prefetch" href="/assets/js/334.f52a66e5.js"><link rel="prefetch" href="/assets/js/335.a6481538.js"><link rel="prefetch" href="/assets/js/336.6bd556c7.js"><link rel="prefetch" href="/assets/js/337.58a4d668.js"><link rel="prefetch" href="/assets/js/338.22095960.js"><link rel="prefetch" href="/assets/js/339.c8da6647.js"><link rel="prefetch" href="/assets/js/34.225b456c.js"><link rel="prefetch" href="/assets/js/340.9f93002f.js"><link rel="prefetch" href="/assets/js/341.721ab41d.js"><link rel="prefetch" href="/assets/js/342.f129aa89.js"><link rel="prefetch" href="/assets/js/343.ea2d2309.js"><link rel="prefetch" href="/assets/js/344.15235001.js"><link rel="prefetch" href="/assets/js/345.eaaae5e5.js"><link rel="prefetch" href="/assets/js/346.73b19ced.js"><link rel="prefetch" href="/assets/js/347.6e11bced.js"><link rel="prefetch" href="/assets/js/348.3b9b7968.js"><link rel="prefetch" href="/assets/js/349.b60a2b56.js"><link rel="prefetch" href="/assets/js/35.e3ec78ba.js"><link rel="prefetch" href="/assets/js/350.e793c7b9.js"><link rel="prefetch" href="/assets/js/351.c86b1ea0.js"><link rel="prefetch" href="/assets/js/352.770038d5.js"><link rel="prefetch" href="/assets/js/353.fe8f38a5.js"><link rel="prefetch" href="/assets/js/354.d3bbf169.js"><link rel="prefetch" href="/assets/js/355.5bb68a7e.js"><link rel="prefetch" href="/assets/js/356.b380aecd.js"><link rel="prefetch" href="/assets/js/357.24fbf1ff.js"><link rel="prefetch" href="/assets/js/358.669b8aba.js"><link rel="prefetch" href="/assets/js/359.04af7f75.js"><link rel="prefetch" href="/assets/js/36.dedb6e42.js"><link rel="prefetch" href="/assets/js/360.73d170d7.js"><link rel="prefetch" href="/assets/js/361.c1f55230.js"><link rel="prefetch" href="/assets/js/362.967bb47e.js"><link rel="prefetch" href="/assets/js/363.7b39c192.js"><link rel="prefetch" href="/assets/js/364.7dbf94dd.js"><link rel="prefetch" href="/assets/js/365.8a1d46d7.js"><link rel="prefetch" href="/assets/js/366.997ec05e.js"><link rel="prefetch" href="/assets/js/367.cda39f93.js"><link rel="prefetch" href="/assets/js/368.1159aebc.js"><link rel="prefetch" href="/assets/js/369.8371cbf0.js"><link rel="prefetch" href="/assets/js/37.129a1339.js"><link rel="prefetch" href="/assets/js/370.b5bda99f.js"><link rel="prefetch" href="/assets/js/371.ca4c4c31.js"><link rel="prefetch" href="/assets/js/372.6ecb7277.js"><link rel="prefetch" href="/assets/js/373.d3d1f018.js"><link rel="prefetch" href="/assets/js/374.4901bb51.js"><link rel="prefetch" href="/assets/js/375.ab11fdff.js"><link rel="prefetch" href="/assets/js/376.f34fed60.js"><link rel="prefetch" href="/assets/js/377.8d8aa0d5.js"><link rel="prefetch" href="/assets/js/378.16a432ff.js"><link rel="prefetch" href="/assets/js/379.68163d64.js"><link rel="prefetch" href="/assets/js/38.e0e2c3b1.js"><link rel="prefetch" href="/assets/js/39.a33bdbc2.js"><link rel="prefetch" href="/assets/js/4.d96ebf17.js"><link rel="prefetch" href="/assets/js/40.d20c1395.js"><link rel="prefetch" href="/assets/js/41.a2d6458f.js"><link rel="prefetch" href="/assets/js/42.48c0ea87.js"><link rel="prefetch" href="/assets/js/43.e2e765f4.js"><link rel="prefetch" href="/assets/js/44.10b67e66.js"><link rel="prefetch" href="/assets/js/45.2cd4b906.js"><link rel="prefetch" href="/assets/js/46.7a02c8ab.js"><link rel="prefetch" href="/assets/js/47.d88632c9.js"><link rel="prefetch" href="/assets/js/48.ade443fe.js"><link rel="prefetch" href="/assets/js/49.4d2ddb3b.js"><link rel="prefetch" href="/assets/js/5.037e08ba.js"><link rel="prefetch" href="/assets/js/50.463230b1.js"><link rel="prefetch" href="/assets/js/51.83c9a564.js"><link rel="prefetch" href="/assets/js/52.56c5a325.js"><link rel="prefetch" href="/assets/js/53.72a3b829.js"><link rel="prefetch" href="/assets/js/54.8f59548e.js"><link rel="prefetch" href="/assets/js/55.0faca6a3.js"><link rel="prefetch" href="/assets/js/56.77474658.js"><link rel="prefetch" href="/assets/js/57.4e4789fa.js"><link rel="prefetch" href="/assets/js/58.9dc82ebc.js"><link rel="prefetch" href="/assets/js/59.2147b861.js"><link rel="prefetch" href="/assets/js/6.8af55c48.js"><link rel="prefetch" href="/assets/js/60.d0ff683a.js"><link rel="prefetch" href="/assets/js/61.331527c3.js"><link rel="prefetch" href="/assets/js/62.a9085bf0.js"><link rel="prefetch" href="/assets/js/63.ecaf766f.js"><link rel="prefetch" href="/assets/js/64.f9a1f00a.js"><link rel="prefetch" href="/assets/js/65.69eef128.js"><link rel="prefetch" href="/assets/js/66.7ce420d5.js"><link rel="prefetch" href="/assets/js/67.059927af.js"><link rel="prefetch" href="/assets/js/68.d1e1fb62.js"><link rel="prefetch" href="/assets/js/69.a98be775.js"><link rel="prefetch" href="/assets/js/7.330a4708.js"><link rel="prefetch" href="/assets/js/70.c773f1fb.js"><link rel="prefetch" href="/assets/js/71.23db970d.js"><link rel="prefetch" href="/assets/js/72.3f45b262.js"><link rel="prefetch" href="/assets/js/73.cc16dadf.js"><link rel="prefetch" href="/assets/js/74.1f05b2b1.js"><link rel="prefetch" href="/assets/js/75.3cd7d993.js"><link rel="prefetch" href="/assets/js/76.1e78e542.js"><link rel="prefetch" href="/assets/js/77.d97d60f9.js"><link rel="prefetch" href="/assets/js/78.6997cb3a.js"><link rel="prefetch" href="/assets/js/79.e8ef607f.js"><link rel="prefetch" href="/assets/js/8.cca0e264.js"><link rel="prefetch" href="/assets/js/80.57d72889.js"><link rel="prefetch" href="/assets/js/81.7aee8496.js"><link rel="prefetch" href="/assets/js/82.0b920de1.js"><link rel="prefetch" href="/assets/js/83.429d7e6f.js"><link rel="prefetch" href="/assets/js/84.c74f1357.js"><link rel="prefetch" href="/assets/js/85.71d21661.js"><link rel="prefetch" href="/assets/js/86.d55ba6f0.js"><link rel="prefetch" href="/assets/js/87.6566a5fc.js"><link rel="prefetch" href="/assets/js/88.6cfa26b6.js"><link rel="prefetch" href="/assets/js/89.0a9ed463.js"><link rel="prefetch" href="/assets/js/9.ef46dc1c.js"><link rel="prefetch" href="/assets/js/90.507b8bb7.js"><link rel="prefetch" href="/assets/js/91.0c374e4a.js"><link rel="prefetch" href="/assets/js/92.1f6e9c9d.js"><link rel="prefetch" href="/assets/js/93.33a64374.js"><link rel="prefetch" href="/assets/js/94.68d20253.js"><link rel="prefetch" href="/assets/js/95.2cf46b84.js"><link rel="prefetch" href="/assets/js/96.9b292e88.js"><link rel="prefetch" href="/assets/js/97.1575dbac.js"><link rel="prefetch" href="/assets/js/98.b8682f4a.js"><link rel="prefetch" href="/assets/js/99.0039b460.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4a9c0c84.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/favicon.ico" alt="悟空非空也" class="logo"> <span class="site-name can-hide">悟空非空也</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/wuKongNotNull/images-hosting/wukong-website/wukong-favicon-nobg.png"> <div class="blogger-info"><h3>悟空非空也</h3> <span>精通各语言拼写的野生程序员</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础教程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>青铜</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>入门</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>数据类型</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/21674c/" aria-current="page" class="active sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#typeof-运算符" class="sidebar-link">typeof 运算符</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#null-udefined和布尔值" class="sidebar-link">null,udefined和布尔值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#null-和-undefined" class="sidebar-link">null 和 undefined</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#布尔值" class="sidebar-link">布尔值</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-2" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数值" class="sidebar-link">数值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#概述-3" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数值的表示法" class="sidebar-link">数值的表示法</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数值的进制" class="sidebar-link">数值的进制</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#特殊数值" class="sidebar-link">特殊数值</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#与数值相关的全局方法" class="sidebar-link">与数值相关的全局方法</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-3" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#字符串" class="sidebar-link">字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#概述-4" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#字符集" class="sidebar-link">字符集</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#base64-转码" class="sidebar-link">Base64 转码</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-4" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#对象" class="sidebar-link">对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#概述-5" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#属性的操作" class="sidebar-link">属性的操作</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#with-语句" class="sidebar-link">with 语句</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-5" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#概述-6" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#函数的属性和方法" class="sidebar-link">函数的属性和方法</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#函数作用域" class="sidebar-link">函数作用域</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参数" class="sidebar-link">参数</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#函数的其他知识点" class="sidebar-link">函数的其他知识点</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#eval-命令" class="sidebar-link">eval 命令</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-6" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数值-2" class="sidebar-link">数值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/21674c/#定义-3" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数组的本质" class="sidebar-link">数组的本质</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#length-属性-3" class="sidebar-link">length 属性</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#in-运算符" class="sidebar-link">in 运算符</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#for-in-循环和数组的遍历" class="sidebar-link">for...in 循环和数组的遍历</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#数组的空位" class="sidebar-link">数组的空位</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#类似数组的对象" class="sidebar-link">类似数组的对象</a></li><li class="sidebar-sub-header"><a href="/pages/21674c/#参考链接-7" class="sidebar-link">参考链接</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>运算符</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/pages/36f9e8/" class="sidebar-link">语法专题</a></li><li><a href="/pages/3e3990/" class="sidebar-link">标准库</a></li><li><a href="/pages/32c5b1/" class="sidebar-link">面向对象编程</a></li><li><a href="/pages/73df15/" class="sidebar-link">异步操作</a></li><li><a href="/pages/91f216/" class="sidebar-link">DOM</a></li><li><a href="/pages/329076/" class="sidebar-link">事件</a></li><li><a href="/pages/229568/" class="sidebar-link">浏览器模型(一)</a></li><li><a href="/pages/ffb0a1/" class="sidebar-link">浏览器模型(二)</a></li><li><a href="/pages/b7cf03/" class="sidebar-link">浏览器模型(三)</a></li><li><a href="/pages/610238/" class="sidebar-link">浏览器模型(四)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《ES6 教程》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Vue》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《React》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《TypeScript 从零实现 axios》</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Git》学习笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript文章</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/fore" title="大前端-目录页" data-v-1cd794fe>大前端</a></li> <li data-v-1cd794fe><a href="/fore/#JavaScript基础教程" title="大前端#JavaScript基础教程" data-v-1cd794fe>JavaScript基础教程</a></li> <li data-v-1cd794fe><a href="/fore/#青铜" title="大前端#青铜" data-v-1cd794fe>青铜</a></li></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/wuKongNotNull" target="_blank" title="作者" class="beLink" data-v-1cd794fe>悟空非空也</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-12-05</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          数据类型
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><h1 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h1> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）</p> <ul><li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）。</li> <li>字符串（string）：文本（比如<code>Hello World</code>）。</li> <li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）。</li> <li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li> <li><code>null</code>：表示空值，即此处的值为空。</li> <li>对象（object）：各种值组成的集合。</li></ul> <p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。</p> <p>对象是最复杂的数据类型，又可以分成三个子类型。</p> <ul><li>狭义的对象（object）</li> <li>数组（array）</li> <li>函数（function）</li></ul> <p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p> <h3 id="typeof-运算符"><a href="#typeof-运算符" class="header-anchor">#</a> typeof 运算符</h3> <p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p> <ul><li><code>typeof</code>运算符</li> <li><code>instanceof</code>运算符</li> <li><code>Object.prototype.toString</code>方法</li></ul> <p><code>instanceof</code>运算符和<code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍<code>typeof</code>运算符。</p> <p><code>typeof</code>运算符可以返回一个值的数据类型。</p> <p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof 123 // &quot;number&quot;
typeof '123' // &quot;string&quot;
typeof false // &quot;boolean&quot;
</code></pre></div><p>函数返回<code>function</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>function f() {}
typeof f
// &quot;function&quot;
</code></pre></div><p><code>undefined</code>返回<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof undefined
// &quot;undefined&quot;
</code></pre></div><p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p> <div class="language- extra-class"><pre class="language-text"><code>v
// ReferenceError: v is not defined

typeof v
// &quot;undefined&quot;
</code></pre></div><p>上面代码中，变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。</p> <p>实际编程中，这个特点通常用在判断语句。</p> <div class="language- extra-class"><pre class="language-text"><code>// 错误的写法
if (v) {
  // ...
}
// ReferenceError: v is not defined

// 正确的写法
if (typeof v === &quot;undefined&quot;) {
  // ...
}
</code></pre></div><p>对象返回<code>object</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof window // &quot;object&quot;
typeof {} // &quot;object&quot;
typeof [] // &quot;object&quot;
</code></pre></div><p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，<code>instanceof</code>运算符可以区分数组和对象。<code>instanceof</code>运算符的详细解释，请见《面向对象编程》一章。</p> <div class="language- extra-class"><pre class="language-text"><code>var o = {};
var a = [];

o instanceof Array // false
a instanceof Array // true
</code></pre></div><p><code>null</code>返回<code>object</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof null // &quot;object&quot;
</code></pre></div><p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p> <h3 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h3> <ul><li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener noreferrer">Improving the JavaScript typeof operator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="null-udefined和布尔值"><a href="#null-udefined和布尔值" class="header-anchor">#</a> null,udefined和布尔值</h2> <h3 id="null-和-undefined"><a href="#null-和-undefined" class="header-anchor">#</a> null 和 undefined</h3> <h4 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h4> <p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = undefined;
// 或者
var a = null;
</code></pre></div><p>上面代码中，变量<code>a</code>分别被赋值为<code>undefined</code>和<code>null</code>，这两种写法的效果几乎等价。</p> <p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p> <div class="language- extra-class"><pre class="language-text"><code>if (!undefined) {
  console.log('undefined is false');
}
// undefined is false

if (!null) {
  console.log('null is false');
}
// null is false

undefined == null
// true
</code></pre></div><p>从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有<code>null</code>，没有<code>undefined</code>！</p> <p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。</p> <p>1995年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示&quot;无&quot;。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Number(null) // 0
5 + null // 5
</code></pre></div><p>上面代码中，<code>null</code>转为数字时，自动变成0。</p> <p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。</p> <p>因此，他又设计了一个<code>undefined</code>。区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示&quot;此处无定义&quot;的原始值，转为数值时为<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Number(undefined) // NaN
5 + undefined // NaN
</code></pre></div><h4 id="用法和含义"><a href="#用法和含义" class="header-anchor">#</a> 用法和含义</h4> <p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解。</p> <p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p> <p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p> <div class="language- extra-class"><pre class="language-text"><code>// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined
</code></pre></div><h3 id="布尔值"><a href="#布尔值" class="header-anchor">#</a> 布尔值</h3> <p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p> <p>下列运算符会返回布尔值：</p> <ul><li>前置逻辑运算符： <code>!</code> (Not)</li> <li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li> <li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li></ul> <p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p> <ul><li><code>undefined</code></li> <li><code>null</code></li> <li><code>false</code></li> <li><code>0</code></li> <li><code>NaN</code></li> <li><code>&quot;&quot;</code>或<code>''</code>（空字符串）</li></ul> <p>布尔值往往用于程序流程的控制，请看一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>if ('') {
  console.log('true');
}
// 没有任何输出
</code></pre></div><p>上面代码中，<code>if</code>命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值<code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p> <p>注意，空数组（<code>[]</code>）和空对象（<code>{}</code>）对应的布尔值，都是<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if ([]) {
  console.log('true');
}
// true

if ({}) {
  console.log('true');
}
// true
</code></pre></div><p>更多关于数据类型转换的介绍，参见《数据类型转换》一章。</p> <h3 id="参考链接-2"><a href="#参考链接-2" class="header-anchor">#</a> 参考链接</h3> <ul><li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener noreferrer">Categorizing values in JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="数值"><a href="#数值" class="header-anchor">#</a> 数值</h2> <h3 id="概述-3"><a href="#概述-3" class="header-anchor">#</a> 概述</h3> <h4 id="整数和浮点数"><a href="#整数和浮点数" class="header-anchor">#</a> 整数和浮点数</h4> <p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p> <div class="language- extra-class"><pre class="language-text"><code>1 === 1.0 // true
</code></pre></div><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。</p> <p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p> <div class="language- extra-class"><pre class="language-text"><code>0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
</code></pre></div><h4 id="数值精度"><a href="#数值精度" class="header-anchor">#</a> 数值精度</h4> <p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p> <ul><li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li> <li>第2位到第12位（共11位）：指数部分</li> <li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul> <p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p> <p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p> <div class="language- extra-class"><pre class="language-text"><code>(-1)^符号位 * 1.xx...xx * 2^指数部分
</code></pre></div><p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p> <p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996
</code></pre></div><p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.pow(2, 53)
// 9007199254740992

// 多出的三个有效数字，将无法保存
9007199254740992111
// 9007199254740992000
</code></pre></div><p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的<code>111</code>）都会无法保存，变成0。</p> <h4 id="数值范围"><a href="#数值范围" class="header-anchor">#</a> 数值范围</h4> <p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p> <p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.pow(2, 1024) // Infinity
</code></pre></div><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.pow(2, -1075) // 0
</code></pre></div><p>下面是一个实际的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var x = 0.5;

for(var i = 0; i &lt; 25; i++) {
  x = x * x;
}

x // 0
</code></pre></div><p>上面代码中，对<code>0.5</code>连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p> <p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p> <div class="language- extra-class"><pre class="language-text"><code>Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
</code></pre></div><h3 id="数值的表示法"><a href="#数值的表示法" class="header-anchor">#</a> 数值的表示法</h3> <p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。</p> <p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>123e3 // 123000
123e-3 // 0.123
-3.1E+12
.1e-23
</code></pre></div><p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p> <p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p> <p><strong>（1）小数点前的数字多于21位。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1234567890123456789012
// 1.2345678901234568e+21

123456789012345678901
// 123456789012345680000
</code></pre></div><p><strong>（2）小数点后的零多于5个。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 小数点后紧跟5个以上的零，
// 就自动转为科学计数法
0.0000003 // 3e-7

// 否则，就保持原来的字面形式
0.000003 // 0.000003
</code></pre></div><h3 id="数值的进制"><a href="#数值的进制" class="header-anchor">#</a> 数值的进制</h3> <p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p> <ul><li>十进制：没有前导0的数值。</li> <li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li> <li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li> <li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul> <p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p> <div class="language- extra-class"><pre class="language-text"><code>0xff // 255
0o377 // 255
0b11 // 3
</code></pre></div><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>0xzz // 报错
0o88 // 报错
0b22 // 报错
</code></pre></div><p>上面代码中，十六进制出现了字母<code>z</code>、八进制出现数字<code>8</code>、二进制出现数字<code>2</code>，因此报错。</p> <p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p> <div class="language- extra-class"><pre class="language-text"><code>0888 // 888
0777 // 511
</code></pre></div><p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p> <h3 id="特殊数值"><a href="#特殊数值" class="header-anchor">#</a> 特殊数值</h3> <p>JavaScript 提供了几个特殊的数值。</p> <h4 id="正零和负零"><a href="#正零和负零" class="header-anchor">#</a> 正零和负零</h4> <p>前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连<code>0</code>也不例外。</p> <p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p> <div class="language- extra-class"><pre class="language-text"><code>-0 === +0 // true
0 === -0 // true
0 === +0 // true
</code></pre></div><p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>+0 // 0
-0 // 0
(-0).toString() // '0'
(+0).toString() // '0'
</code></pre></div><p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p> <div class="language- extra-class"><pre class="language-text"><code>(1 / +0) === (1 / -0) // false
</code></pre></div><p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的（关于<code>Infinity</code>详见下文）。</p> <h4 id="nan"><a href="#nan" class="header-anchor">#</a> NaN</h4> <p><strong>（1）含义</strong></p> <p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p> <div class="language- extra-class"><pre class="language-text"><code>5 - 'x' // NaN
</code></pre></div><p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p> <p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.acos(2) // NaN
Math.log(-1) // NaN
Math.sqrt(-1) // NaN
</code></pre></div><p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>0 / 0 // NaN
</code></pre></div><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof NaN // 'number'
</code></pre></div><p><strong>（2）运算规则</strong></p> <p><code>NaN</code>不等于任何值，包括它本身。</p> <div class="language- extra-class"><pre class="language-text"><code>NaN === NaN // false
</code></pre></div><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p> <div class="language- extra-class"><pre class="language-text"><code>[NaN].indexOf(NaN) // -1
</code></pre></div><p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Boolean(NaN) // false
</code></pre></div><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>NaN + 32 // NaN
NaN - 32 // NaN
NaN * 32 // NaN
NaN / 32 // NaN
</code></pre></div><h4 id="infinity"><a href="#infinity" class="header-anchor">#</a> Infinity</h4> <p><strong>（1）含义</strong></p> <p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// 场景一
Math.pow(2, 1024)
// Infinity

// 场景二
0 / 0 // NaN
1 / 0 // Infinity
</code></pre></div><p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是<code>0</code>除以<code>0</code>会得到<code>NaN</code>，而非0数值除以<code>0</code>，会返回<code>Infinity</code>。</p> <p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p> <div class="language- extra-class"><pre class="language-text"><code>Infinity === -Infinity // false

1 / -0 // -Infinity
-1 / -0 // Infinity
</code></pre></div><p>上面代码中，非零正数除以<code>-0</code>，会得到<code>-Infinity</code>，负数除以<code>-0</code>，会得到<code>Infinity</code>。</p> <p>由于数值正向溢出（overflow）、负向溢出（underflow）和被<code>0</code>除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</p> <p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p> <div class="language- extra-class"><pre class="language-text"><code>Infinity &gt; 1000 // true
-Infinity &lt; -1000 // true
</code></pre></div><p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Infinity &gt; NaN // false
-Infinity &gt; NaN // false

Infinity &lt; NaN // false
-Infinity &lt; NaN // false
</code></pre></div><p><strong>（2）运算规则</strong></p> <p><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</p> <div class="language- extra-class"><pre class="language-text"><code>5 * Infinity // Infinity
5 - Infinity // -Infinity
Infinity / 5 // Infinity
5 / Infinity // 0
</code></pre></div><p>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>0 * Infinity // NaN
0 / Infinity // 0
Infinity / 0 // Infinity
</code></pre></div><p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Infinity + Infinity // Infinity
Infinity * Infinity // Infinity
</code></pre></div><p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Infinity - Infinity // NaN
Infinity / Infinity // NaN
</code></pre></div><p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</p> <div class="language- extra-class"><pre class="language-text"><code>null * Infinity // NaN
null / Infinity // 0
Infinity / null // Infinity
</code></pre></div><p><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>undefined + Infinity // NaN
undefined - Infinity // NaN
undefined * Infinity // NaN
undefined / Infinity // NaN
Infinity / undefined // NaN
</code></pre></div><h3 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="header-anchor">#</a> 与数值相关的全局方法</h3> <h4 id="parseint"><a href="#parseint" class="header-anchor">#</a> parseInt()</h4> <p><strong>（1）基本用法</strong></p> <p><code>parseInt</code>方法用于将字符串转为整数。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('123') // 123
</code></pre></div><p>如果字符串头部有空格，空格会被自动去除。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('   81') // 81
</code></pre></div><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt(1.23) // 1
// 等同于
parseInt('1.23') // 1
</code></pre></div><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('8a') // 8
parseInt('12**') // 12
parseInt('12.34') // 12
parseInt('15e2') // 15
parseInt('15px') // 15
</code></pre></div><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p> <p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('abc') // NaN
parseInt('.3') // NaN
parseInt('') // NaN
parseInt('+') // NaN
parseInt('+1') // 1
</code></pre></div><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p> <p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('0x10') // 16
</code></pre></div><p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('011') // 11
</code></pre></div><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt(1000000000000000000000.5) // 1
// 等同于
parseInt('1e+21') // 1

parseInt(0.0000008) // 8
// 等同于
parseInt('8e-7') // 8
</code></pre></div><p><strong>（2）进制转换</strong></p> <p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('1000') // 1000
// 等同于
parseInt('1000', 10) // 1000
</code></pre></div><p>下面是转换指定进制的数的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('1000', 2) // 8
parseInt('1000', 6) // 216
parseInt('1000', 8) // 512
</code></pre></div><p>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p> <p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('10', 37) // NaN
parseInt('10', 1) // NaN
parseInt('10', 0) // 10
parseInt('10', null) // 10
parseInt('10', undefined) // 10
</code></pre></div><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt('1546', 2) // 1
parseInt('546', 2) // NaN
</code></pre></div><p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p> <p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt(0x11, 36) // 43
parseInt(0x11, 2) // 1

// 等同于
parseInt(String(0x11), 36)
parseInt(String(0x11), 2)

// 等同于
parseInt('17', 36)
parseInt('17', 2)
</code></pre></div><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p> <p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p> <div class="language- extra-class"><pre class="language-text"><code>parseInt(011, 2) // NaN

// 等同于
parseInt(String(011), 2)

// 等同于
parseInt(String(9), 2)
</code></pre></div><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt('011', 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p> <p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p> <h4 id="parsefloat"><a href="#parsefloat" class="header-anchor">#</a> parseFloat()</h4> <p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat('3.14') // 3.14
</code></pre></div><p>如果字符串符合科学计数法，则会进行相应的转换。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat('314e-2') // 3.14
parseFloat('0.0314E+2') // 3.14
</code></pre></div><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat('3.14more non-digit characters') // 3.14
</code></pre></div><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat('\t\v\r12.34\n ') // 12.34
</code></pre></div><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat([]) // NaN
parseFloat('FF2') // NaN
parseFloat('') // NaN
</code></pre></div><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p> <p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p> <div class="language- extra-class"><pre class="language-text"><code>parseFloat(true)  // NaN
Number(true) // 1

parseFloat(null) // NaN
Number(null) // 0

parseFloat('') // NaN
Number('') // 0

parseFloat('123.45#') // 123.45
Number('123.45#') // NaN
</code></pre></div><h4 id="isnan"><a href="#isnan" class="header-anchor">#</a> isNaN()</h4> <p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>isNaN(NaN) // true
isNaN(123) // false
</code></pre></div><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>isNaN('Hello') // true
// 相当于
isNaN(Number('Hello')) // true
</code></pre></div><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>isNaN({}) // true
// 等同于
isNaN(Number({})) // true

isNaN(['xzy']) // true
// 等同于
isNaN(Number(['xzy'])) // true
</code></pre></div><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>isNaN([]) // false
isNaN([123]) // false
isNaN(['123']) // false
</code></pre></div><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p> <p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p> <div class="language- extra-class"><pre class="language-text"><code>function myIsNaN(value) {
  return typeof value === 'number' &amp;&amp; isNaN(value);
}
</code></pre></div><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p> <div class="language- extra-class"><pre class="language-text"><code>function myIsNaN(value) {
  return value !== value;
}
</code></pre></div><h4 id="isfinite"><a href="#isfinite" class="header-anchor">#</a> isFinite()</h4> <p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p> <div class="language- extra-class"><pre class="language-text"><code>isFinite(Infinity) // false
isFinite(-Infinity) // false
isFinite(NaN) // false
isFinite(undefined) // false
isFinite(null) // true
isFinite(-1) // true
</code></pre></div><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p> <h3 id="参考链接-3"><a href="#参考链接-3" class="header-anchor">#</a> 参考链接</h3> <ul><li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2012/04/number-encoding.html" target="_blank" rel="noopener noreferrer">How numbers are encoded in JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Humphry, <a href="http://blog.segmentfault.com/humphry/1190000000407658" target="_blank" rel="noopener noreferrer">JavaScript 中 Number 的一些表示上/下限<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h2> <h3 id="概述-4"><a href="#概述-4" class="header-anchor">#</a> 概述</h3> <h4 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h4> <p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p> <div class="language- extra-class"><pre class="language-text"><code>'abc'
&quot;abc&quot;
</code></pre></div><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p> <div class="language- extra-class"><pre class="language-text"><code>'key = &quot;value&quot;'
&quot;It's a long journey&quot;
</code></pre></div><p>上面两个都是合法的字符串。</p> <p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p> <div class="language- extra-class"><pre class="language-text"><code>'Did she say \'Hello\'?'
// &quot;Did she say 'Hello'?&quot;

&quot;Did she say \&quot;Hello\&quot;?&quot;
// &quot;Did she say &quot;Hello&quot;?&quot;
</code></pre></div><p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p> <p>字符串默认只能写在一行内，分成多行将会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>'a
b
c'
// SyntaxError: Unexpected token ILLEGAL
</code></pre></div><p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p> <p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p> <div class="language- extra-class"><pre class="language-text"><code>var longString = 'Long \
long \
long \
string';

longString
// &quot;Long long long string&quot;
</code></pre></div><p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p> <p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p> <div class="language- extra-class"><pre class="language-text"><code>var longString = 'Long '
  + 'long '
  + 'long '
  + 'string';
</code></pre></div><p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p> <div class="language- extra-class"><pre class="language-text"><code>(function () { /*
line 1
line 2
line 3
*/}).toString().split('\n').slice(1, -1).join('\n')
// &quot;line 1
// line 2
// line 3&quot;
</code></pre></div><p>上面的例子中，输出的字符串就是多行。</p> <h4 id="转义"><a href="#转义" class="header-anchor">#</a> 转义</h4> <p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p> <p>需要用反斜杠转义的特殊字符，主要有下面这些。</p> <ul><li><code>\0</code> ：null（<code>\u0000</code>）</li> <li><code>\b</code> ：后退键（<code>\u0008</code>）</li> <li><code>\f</code> ：换页符（<code>\u000C</code>）</li> <li><code>\n</code> ：换行符（<code>\u000A</code>）</li> <li><code>\r</code> ：回车键（<code>\u000D</code>）</li> <li><code>\t</code> ：制表符（<code>\u0009</code>）</li> <li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li> <li><code>\'</code> ：单引号（<code>\u0027</code>）</li> <li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li> <li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li></ul> <p>上面这些字符前面加上反斜杠，都表示特殊含义。</p> <div class="language- extra-class"><pre class="language-text"><code>console.log('1\n2')
// 1
// 2
</code></pre></div><p>上面代码中，<code>\n</code>表示换行，输出的时候就分成了两行。</p> <p>反斜杠还有三种特殊用法。</p> <p>（1）<code>\HHH</code></p> <p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p> <p>（2）<code>\xHH</code></p> <p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p> <p>（3）<code>\uXXXX</code></p> <p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p> <p>下面是这三种字符特殊写法的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>'\251' // &quot;©&quot;
'\xA9' // &quot;©&quot;
'\u00A9' // &quot;©&quot;

'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
</code></pre></div><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p> <div class="language- extra-class"><pre class="language-text"><code>'\a'
// &quot;a&quot;
</code></pre></div><p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p> <p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;Prev \\ Next&quot;
// &quot;Prev \ Next&quot;
</code></pre></div><h4 id="字符串与数组"><a href="#字符串与数组" class="header-anchor">#</a> 字符串与数组</h4> <p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'hello';
s[0] // &quot;h&quot;
s[1] // &quot;e&quot;
s[4] // &quot;o&quot;

// 直接对字符串使用方括号运算符
'hello'[1] // &quot;e&quot;
</code></pre></div><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>'abc'[3] // undefined
'abc'[-1] // undefined
'abc'['x'] // undefined
</code></pre></div><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'hello';

delete s[0];
s // &quot;hello&quot;

s[1] = 'a';
s // &quot;hello&quot;

s[5] = '!';
s // &quot;hello&quot;
</code></pre></div><p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p> <h4 id="length-属性"><a href="#length-属性" class="header-anchor">#</a> length 属性</h4> <p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'hello';
s.length // 5

s.length = 3;
s.length // 5

s.length = 7;
s.length // 5
</code></pre></div><p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。</p> <h3 id="字符集"><a href="#字符集" class="header-anchor">#</a> 字符集</h3> <p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p> <p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = '\u00A9';
s // &quot;©&quot;
</code></pre></div><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p> <div class="language- extra-class"><pre class="language-text"><code>var f\u006F\u006F = 'abc';
foo // &quot;abc&quot;
</code></pre></div><p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p> <p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p> <p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p> <p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p> <div class="language- extra-class"><pre class="language-text"><code>'𝌆'.length // 2
</code></pre></div><p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p> <p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p> <h3 id="base64-转码"><a href="#base64-转码" class="header-anchor">#</a> Base64 转码</h3> <p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p> <p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p> <p>JavaScript 原生提供两个 Base64 相关的方法。</p> <ul><li><code>btoa()</code>：任意值转为 Base64 编码</li> <li><code>atob()</code>：Base64 编码转为原来的值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var string = 'Hello World!';
btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;
atob('SGVsbG8gV29ybGQh') // &quot;Hello World!&quot;
</code></pre></div><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>btoa('你好') // 报错
</code></pre></div><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p> <div class="language- extra-class"><pre class="language-text"><code>function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // &quot;你好&quot;
</code></pre></div><h3 id="参考链接-4"><a href="#参考链接-4" class="header-anchor">#</a> 参考链接</h3> <ul><li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/javascript-encoding" target="_blank" rel="noopener noreferrer">JavaScript’s internal character encoding: UCS-2 or UTF-16?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Mathias Bynens, <a href="https://mathiasbynens.be/notes/javascript-unicode" target="_blank" rel="noopener noreferrer">JavaScript has a Unicode problem<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa" target="_blank" rel="noopener noreferrer">Window.btoa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h2> <h3 id="概述-5"><a href="#概述-5" class="header-anchor">#</a> 概述</h3> <h4 id="生成方法"><a href="#生成方法" class="header-anchor">#</a> 生成方法</h4> <p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p> <p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  foo: 'Hello',
  bar: 'World'
};
</code></pre></div><p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: 'Hello'</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是<code>bar: 'World'</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔。</p> <h4 id="键名"><a href="#键名" class="header-anchor">#</a> 键名</h4> <p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  'foo': 'Hello',
  'bar': 'World'
};
</code></pre></div><p>如果键名是数值，会被自动转为字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  1: 'a',
  3.2: 'b',
  1e2: true,
  1e-2: true,
  .234: true,
  0xFF: true
};

obj
// Object {
//   1: &quot;a&quot;,
//   3.2: &quot;b&quot;,
//   100: true,
//   0.01: true,
//   0.234: true,
//   255: true
// }

obj['100'] // true
</code></pre></div><p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p> <p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 报错
var obj = {
  1p: 'Hello World'
};

// 不报错
var obj = {
  '1p': 'Hello World',
  'h w': 'Hello World',
  'p+q': 'Hello World'
};
</code></pre></div><p>上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。</p> <p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  p: function (x) {
    return 2 * x;
  }
};

obj.p(1) // 2
</code></pre></div><p>上面代码中，对象<code>obj</code>的属性<code>p</code>，就指向一个函数。</p> <p>如果属性的值还是一个对象，就形成了链式引用。</p> <div class="language- extra-class"><pre class="language-text"><code>var o1 = {};
var o2 = { bar: 'hello' };

o1.foo = o2;
o1.foo.bar // &quot;hello&quot;
</code></pre></div><p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p> <p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  p: 123,
  m: function () { ... },
}
</code></pre></div><p>上面的代码中，<code>m</code>属性后面的那个逗号，有没有都可以。</p> <p>属性可以动态创建，不必在对象声明时就指定。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
obj.foo = 123;
obj.foo // 123
</code></pre></div><p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p> <h4 id="对象的引用"><a href="#对象的引用" class="header-anchor">#</a> 对象的引用</h4> <p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var o1 = {};
var o2 = o1;

o1.a = 1;
o2.a // 1

o2.b = 2;
o1.b // 2
</code></pre></div><p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p> <p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}
</code></pre></div><p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p> <p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p> <div class="language- extra-class"><pre class="language-text"><code>var x = 1;
var y = x;

x = 2;
y // 1
</code></pre></div><p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p> <h4 id="表达式还是语句"><a href="#表达式还是语句" class="header-anchor">#</a> 表达式还是语句？</h4> <p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p> <div class="language- extra-class"><pre class="language-text"><code>{ foo: 123 }
</code></pre></div><p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p> <p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p> <div class="language- extra-class"><pre class="language-text"><code>{ console.log(123) } // 123
</code></pre></div><p>上面的语句是一个代码块，而且只有解释为代码块，才能执行。</p> <p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p> <div class="language- extra-class"><pre class="language-text"><code>({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
</code></pre></div><p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p> <div class="language- extra-class"><pre class="language-text"><code>eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
</code></pre></div><p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p> <h3 id="属性的操作"><a href="#属性的操作" class="header-anchor">#</a> 属性的操作</h3> <h4 id="属性的读取"><a href="#属性的读取" class="header-anchor">#</a> 属性的读取</h4> <p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  p: 'Hello World'
};

obj.p // &quot;Hello World&quot;
obj['p'] // &quot;Hello World&quot;
</code></pre></div><p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p> <p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = 'bar';

var obj = {
  foo: 1,
  bar: 2
};

obj.foo  // 1
obj[foo]  // 2
</code></pre></div><p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p> <p>方括号运算符内部还可以使用表达式。</p> <div class="language- extra-class"><pre class="language-text"><code>obj['hello' + ' world']
obj[3 + 3]
</code></pre></div><p>数字键可以不加引号，因为会自动转成字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  0.7: 'Hello World'
};

obj['0.7'] // &quot;Hello World&quot;
obj[0.7] // &quot;Hello World&quot;
</code></pre></div><p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p> <p>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  123: 'hello world'
};

obj.123 // 报错
obj[123] // &quot;hello world&quot;
</code></pre></div><p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。</p> <h4 id="属性的赋值"><a href="#属性的赋值" class="header-anchor">#</a> 属性的赋值</h4> <p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};

obj.foo = 'Hello';
obj['bar'] = 'World';
</code></pre></div><p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值。</p> <p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = { p: 1 };

// 等价于

var obj = {};
obj.p = 1;
</code></pre></div><h4 id="属性的查看"><a href="#属性的查看" class="header-anchor">#</a> 属性的查看</h4> <p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  key1: 1,
  key2: 2
};

Object.keys(obj);
// ['key1', 'key2']
</code></pre></div><h4 id="属性的删除-delete-命令"><a href="#属性的删除-delete-命令" class="header-anchor">#</a> 属性的删除：delete 命令</h4> <p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = { p: 1 };
Object.keys(obj) // [&quot;p&quot;]

delete obj.p // true
obj.p // undefined
Object.keys(obj) // []
</code></pre></div><p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p> <p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
delete obj.p // true
</code></pre></div><p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p> <p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

obj.p // 123
delete obj.p // false
</code></pre></div><p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>（关于<code>Object.defineProperty</code>方法的介绍，请看《标准库》的 Object 对象一章）。</p> <p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
delete obj.toString // true
obj.toString // function toString() { [native code] }
</code></pre></div><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p> <h4 id="属性是否存在-in-运算符"><a href="#属性是否存在-in-运算符" class="header-anchor">#</a> 属性是否存在：in 运算符</h4> <p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = { p: 1 };
'p' in obj // true
'toString' in obj // true
</code></pre></div><p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p> <p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString')) // false
}
</code></pre></div><h4 id="属性的遍历-for-in-循环"><a href="#属性的遍历-for-in-循环" class="header-anchor">#</a> 属性的遍历：for...in 循环</h4> <p><code>for...in</code>循环用来遍历一个对象的全部属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {a: 1, b: 2, c: 3};

for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
// 键名： a
// 键值： 1
// 键名： b
// 键值： 2
// 键名： c
// 键值： 3
</code></pre></div><p><code>for...in</code>循环有两个使用注意点。</p> <ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li> <li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul> <p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};

// toString 属性是存在的
obj.toString // toString() { [native code] }

for (var p in obj) {
  console.log(p);
} // 没有任何输出
</code></pre></div><p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。</p> <p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var person = { name: '老张' };

for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name
</code></pre></div><h3 id="with-语句"><a href="#with-语句" class="header-anchor">#</a> with 语句</h3> <p><code>with</code>语句的格式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>with (对象) {
  语句;
}
</code></pre></div><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p> <div class="language- extra-class"><pre class="language-text"><code>// 例一
var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
</code></pre></div><p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1 // undefined
p1 // 4
</code></pre></div><p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p> <p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p> <div class="language- extra-class"><pre class="language-text"><code>with (obj) {
  console.log(x);
}
</code></pre></div><p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>with(obj1.obj2.obj3) {
  console.log(p1 + p2);
}

// 可以写成
var temp = obj1.obj2.obj3;
console.log(temp.p1 + temp.p2);
</code></pre></div><h3 id="参考链接-5"><a href="#参考链接-5" class="header-anchor">#</a> 参考链接</h3> <ul><li>Dr. Axel Rauschmayer，<a href="http://www.2ality.com/2012/10/javascript-properties.html" target="_blank" rel="noopener noreferrer">Object properties in JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Lakshan Perera, <a href="http://www.laktek.com/2012/12/29/revisiting-javascript-objects/" target="_blank" rel="noopener noreferrer">Revisiting JavaScript Objects<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Angus Croll, <a href="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" target="_blank" rel="noopener noreferrer">The Secret Life of JavaScript Primitives<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>i</li> <li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2011/06/with-statement.html" target="_blank" rel="noopener noreferrer">JavaScript’s with statement and why it’s deprecated<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p> <h3 id="概述-6"><a href="#概述-6" class="header-anchor">#</a> 概述</h3> <h4 id="函数的声明"><a href="#函数的声明" class="header-anchor">#</a> 函数的声明</h4> <p>JavaScript 有三种声明函数的方法。</p> <p><strong>（1）function 命令</strong></p> <p><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</p> <div class="language- extra-class"><pre class="language-text"><code>function print(s) {
  console.log(s);
}
</code></pre></div><p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。</p> <p><strong>（2）函数表达式</strong></p> <p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法。</p> <div class="language- extra-class"><pre class="language-text"><code>var print = function(s) {
  console.log(s);
};
</code></pre></div><p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。</p> <p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p> <div class="language- extra-class"><pre class="language-text"><code>var print = function x(){
  console.log(typeof x);
};

x
// ReferenceError: x is not defined

print()
// function
</code></pre></div><p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function f() {};
</code></pre></div><p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p> <p><strong>（3）Function 构造函数</strong></p> <p>第三种声明函数的方式是<code>Function</code>构造函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var add = new Function(
  'x',
  'y',
  'return x + y'
);

// 等同于
function add(x, y) {
  return x + y;
}
</code></pre></div><p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。</p> <p>你可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = new Function(
  'return &quot;hello world&quot;;'
);

// 等同于
function foo() {
  return 'hello world';
}
</code></pre></div><p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p> <p>总的来说，这种声明函数的方式非常不直观，几乎无人使用。</p> <h4 id="函数的重复声明"><a href="#函数的重复声明" class="header-anchor">#</a> 函数的重复声明</h4> <p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p> <div class="language- extra-class"><pre class="language-text"><code>function f() {
  console.log(1);
}
f() // 2

function f() {
  console.log(2);
}
f() // 2
</code></pre></div><p>上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。</p> <h4 id="圆括号运算符-return-语句和递归"><a href="#圆括号运算符-return-语句和递归" class="header-anchor">#</a> 圆括号运算符，return 语句和递归</h4> <p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p> <div class="language- extra-class"><pre class="language-text"><code>function add(x, y) {
  return x + y;
}

add(1, 1) // 2
</code></pre></div><p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。</p> <p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>。</p> <p>函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。</p> <div class="language- extra-class"><pre class="language-text"><code>function fib(num) {
  if (num === 0) return 0;
  if (num === 1) return 1;
  return fib(num - 2) + fib(num - 1);
}

fib(6) // 8
</code></pre></div><p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8。</p> <h4 id="第一等公民"><a href="#第一等公民" class="header-anchor">#</a> 第一等公民</h4> <p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p> <p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p> <div class="language- extra-class"><pre class="language-text"><code>function add(x, y) {
  return x + y;
}

// 将函数赋值给一个变量
var operator = add;

// 将函数作为参数和返回值
function a(op){
  return op;
}
a(add)(1, 1)
// 2
</code></pre></div><h4 id="函数名的提升"><a href="#函数名的提升" class="header-anchor">#</a> 函数名的提升</h4> <p>JavaScript 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>f();

function f() {}
</code></pre></div><p>表面上，上面代码好像在声明之前就调用了函数<code>f</code>。但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>f();
var f = function (){};
// TypeError: undefined is not a function
</code></pre></div><p>上面的代码等同于下面的形式。</p> <div class="language- extra-class"><pre class="language-text"><code>var f;
f();
f = function () {};
</code></pre></div><p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错。</p> <p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f() // 1
</code></pre></div><p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来。</p> <h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="header-anchor">#</a> 函数的属性和方法</h3> <h4 id="name-属性"><a href="#name-属性" class="header-anchor">#</a> name 属性</h4> <p>函数的<code>name</code>属性返回函数的名字。</p> <div class="language- extra-class"><pre class="language-text"><code>function f1() {}
f1.name // &quot;f1&quot;
</code></pre></div><p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名。</p> <div class="language- extra-class"><pre class="language-text"><code>var f2 = function () {};
f2.name // &quot;f2&quot;
</code></pre></div><p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名。</p> <div class="language- extra-class"><pre class="language-text"><code>var f3 = function myName() {};
f3.name // 'myName'
</code></pre></div><p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用。</p> <p><code>name</code>属性的一个用处，就是获取参数函数的名字。</p> <div class="language- extra-class"><pre class="language-text"><code>var myFunc = function () {};

function test(f) {
  console.log(f.name);
}

test(myFunc) // myFunc
</code></pre></div><p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数。</p> <h4 id="length-属性-2"><a href="#length-属性-2" class="header-anchor">#</a> length 属性</h4> <p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, b) {}
f.length // 2
</code></pre></div><p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于2。</p> <p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。</p> <h4 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString()</h4> <p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码。</p> <div class="language- extra-class"><pre class="language-text"><code>function f() {
  a();
  b();
  c();
}

f.toString()
// function f() {
//  a();
//  b();
//  c();
// }
</code></pre></div><p>上面示例中，函数<code>f</code>的<code>toString()</code>方法返回了<code>f</code>的源码，包含换行符在内。</p> <p>对于那些原生的函数，<code>toString()</code>方法返回<code>function (){[native code]}</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>Math.sqrt.toString()
// &quot;function sqrt() { [native code] }&quot;
</code></pre></div><p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p> <p>函数内部的注释也可以返回。</p> <div class="language- extra-class"><pre class="language-text"><code>function f() {/*
  这是一个
  多行注释
*/}

f.toString()
// &quot;function f(){/*
//   这是一个
//   多行注释
// */}&quot;
</code></pre></div><p>利用这一点，可以变相实现多行字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var multiline = function (fn) {
  var arr = fn.toString().split('\n');
  return arr.slice(1, arr.length - 1).join('\n');
};

function f() {/*
  这是一个
  多行注释
*/}

multiline(f);
// &quot; 这是一个
//   多行注释&quot;
</code></pre></div><p>上面示例中，函数<code>f</code>内部有一个多行注释，<code>toString()</code>方法拿到<code>f</code>的源码后，去掉首尾两行，就得到了一个多行字符串。</p> <h3 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h3> <h4 id="定义-2"><a href="#定义-2" class="header-anchor">#</a> 定义</h4> <p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。</p> <p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p> <div class="language- extra-class"><pre class="language-text"><code>var v = 1;

function f() {
  console.log(v);
}

f()
// 1
</code></pre></div><p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>。</p> <p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(){
  var v = 1;
}

v // ReferenceError: v is not defined
</code></pre></div><p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p> <p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var v = 1;

function f(){
  var v = 2;
  console.log(v);
}

f() // 2
v // 1
</code></pre></div><p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>。</p> <p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p> <div class="language- extra-class"><pre class="language-text"><code>if (true) {
  var x = 5;
}
console.log(x);  // 5
</code></pre></div><p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p> <h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="header-anchor">#</a> 函数内部的变量提升</h4> <p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(x) {
  if (x &gt; 100) {
    var tmp = x - 100;
  }
}

// 等同于
function foo(x) {
  var tmp;
  if (x &gt; 100) {
    tmp = x - 100;
  };
}
</code></pre></div><h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="header-anchor">#</a> 函数本身的作用域</h4> <p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1
</code></pre></div><p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p> <p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p> <p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var x = function () {
  console.log(a);
};

function y(f) {
  var a = 2;
  f();
}

y(x)
// ReferenceError: a is not defined
</code></pre></div><p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p> <p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  var x = 1;
  function bar() {
    console.log(x);
  }
  return bar;
}

var x = 2;
var f = foo();
f() // 1
</code></pre></div><p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <h4 id="概述-7"><a href="#概述-7" class="header-anchor">#</a> 概述</h4> <p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p> <div class="language- extra-class"><pre class="language-text"><code>function square(x) {
  return x * x;
}

square(2) // 4
square(3) // 9
</code></pre></div><p>上式的<code>x</code>就是<code>square</code>函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p> <h4 id="参数的省略"><a href="#参数的省略" class="header-anchor">#</a> 参数的省略</h4> <p>函数参数不是必需的，JavaScript 允许省略参数。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, b) {
  return a;
}

f(1, 2, 3) // 1
f(1) // 1
f() // undefined

f.length // 2
</code></pre></div><p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为<code>undefined</code>。需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p> <p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, b) {
  return a;
}

f( , 1) // SyntaxError: Unexpected token ,(…)
f(undefined, 1) // undefined
</code></pre></div><p>上面代码中，如果省略第一个参数，就会报错。</p> <h4 id="传递方式"><a href="#传递方式" class="header-anchor">#</a> 传递方式</h4> <p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = 2;

function f(p) {
  p = 3;
}
f(p);

p // 2
</code></pre></div><p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p> <p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = { p: 1 };

function f(o) {
  o.p = 2;
}
f(obj);

obj.p // 2
</code></pre></div><p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值。</p> <p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = [1, 2, 3];

function f(o) {
  o = [2, 3, 4];
}
f(obj);

obj // [1, 2, 3]
</code></pre></div><p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p> <h4 id="同名参数"><a href="#同名参数" class="header-anchor">#</a> 同名参数</h4> <p>如果有同名的参数，则取最后出现的那个值。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, a) {
  console.log(a);
}

f(1, 2) // 2
</code></pre></div><p>上面代码中，函数<code>f()</code>有两个参数，且参数名都是<code>a</code>。取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, a) {
  console.log(a);
}

f(1) // undefined
</code></pre></div><p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>function f(a, a) {
  console.log(arguments[0]);
}

f(1) // 1
</code></pre></div><h4 id="arguments-对象"><a href="#arguments-对象" class="header-anchor">#</a> arguments 对象</h4> <p><strong>（1）定义</strong></p> <p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p> <p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function (one) {
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

f(1, 2, 3)
// 1
// 2
// 3
</code></pre></div><p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function(a, b) {
  arguments[0] = 3;
  arguments[1] = 2;
  return a + b;
}

f(1, 1) // 5
</code></pre></div><p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p> <p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function(a, b) {
  'use strict'; // 开启严格模式
  arguments[0] = 3;
  arguments[1] = 2;
  return a + b;
}

f(1, 1) // 2
</code></pre></div><p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p> <p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p> <div class="language- extra-class"><pre class="language-text"><code>function f() {
  return arguments.length;
}

f(1, 2, 3) // 3
f(1) // 1
f() // 0
</code></pre></div><p><strong>（2）与数组的关系</strong></p> <p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p> <p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var args = Array.prototype.slice.call(arguments);

// 或者
var args = [];
for (var i = 0; i &lt; arguments.length; i++) {
  args.push(arguments[i]);
}
</code></pre></div><p><strong>（3）callee 属性</strong></p> <p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function () {
  console.log(arguments.callee === f);
}

f() // true
</code></pre></div><p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p> <h3 id="函数的其他知识点"><a href="#函数的其他知识点" class="header-anchor">#</a> 函数的其他知识点</h3> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <p>闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p> <p>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p> <div class="language- extra-class"><pre class="language-text"><code>var n = 999;

function f1() {
  console.log(n);
}
f1() // 999
</code></pre></div><p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p> <p>但是，正常情况下，函数外部无法读取函数内部声明的变量。</p> <div class="language- extra-class"><pre class="language-text"><code>function f1() {
  var n = 999;
}

console.log(n)
// Uncaught ReferenceError: n is not defined(
</code></pre></div><p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p> <p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p> <div class="language- extra-class"><pre class="language-text"><code>function f1() {
  var n = 999;
  function f2() {
　　console.log(n); // 999
  }
}
</code></pre></div><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的&quot;链式作用域&quot;结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p> <p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p> <div class="language- extra-class"><pre class="language-text"><code>function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
</code></pre></div><p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p> <p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p> <p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p> <div class="language- extra-class"><pre class="language-text"><code>function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7
</code></pre></div><p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p> <p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p> <p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
</code></pre></div><p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p> <p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p> <h4 id="立即调用的函数表达式-iife"><a href="#立即调用的函数表达式-iife" class="header-anchor">#</a> 立即调用的函数表达式（IIFE）</h4> <p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数。</p> <p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p> <div class="language- extra-class"><pre class="language-text"><code>function(){ /* code */ }();
// SyntaxError: Unexpected token (
</code></pre></div><p>产生这个错误的原因是，<code>function</code>这个关键字既可以当作语句，也可以当作表达式。</p> <div class="language- extra-class"><pre class="language-text"><code>// 语句
function f() {}

// 表达式
var f = function f() {}
</code></pre></div><p>当作表达式时，函数可以定义后直接加圆括号调用。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = function f(){ return 1}();
f // 1
</code></pre></div><p>上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。</p> <p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p> <p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p> <div class="language- extra-class"><pre class="language-text"><code>(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();
</code></pre></div><p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p> <p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 报错
(function(){ /* code */ }())
(function(){ /* code */ }())
</code></pre></div><p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p> <p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p> <div class="language- extra-class"><pre class="language-text"><code>var i = function(){ return 10; }();
true &amp;&amp; function(){ /* code */ }();
0, function(){ /* code */ }();
</code></pre></div><p>甚至像下面这样写，也是可以的。</p> <div class="language- extra-class"><pre class="language-text"><code>!function () { /* code */ }();
~function () { /* code */ }();
-function () { /* code */ }();
+function () { /* code */ }();
</code></pre></div><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p> <div class="language- extra-class"><pre class="language-text"><code>// 写法一
var tmp = newData;
processData(tmp);
storeData(tmp);

// 写法二
(function () {
  var tmp = newData;
  processData(tmp);
  storeData(tmp);
}());
</code></pre></div><p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p> <h3 id="eval-命令"><a href="#eval-命令" class="header-anchor">#</a> eval 命令</h3> <h4 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h4> <p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p> <div class="language- extra-class"><pre class="language-text"><code>eval('var a = 1;');
a // 1
</code></pre></div><p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p> <p>如果参数字符串无法当作语句运行，那么就会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>eval('3x') // Uncaught SyntaxError: Invalid or unexpected token
</code></pre></div><p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>eval('return;'); // Uncaught SyntaxError: Illegal return statement
</code></pre></div><p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用。</p> <p>如果<code>eval</code>的参数不是字符串，那么会原样返回。</p> <div class="language- extra-class"><pre class="language-text"><code>eval(123) // 123
</code></pre></div><p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = 1;
eval('a = 2');

a // 2
</code></pre></div><p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。由于这个原因，<code>eval</code>有安全风险。</p> <p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域。</p> <div class="language- extra-class"><pre class="language-text"><code>(function f() {
  'use strict';
  eval('var foo = 123');
  console.log(foo);  // ReferenceError: foo is not defined
})()
</code></pre></div><p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部。</p> <p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量。</p> <div class="language- extra-class"><pre class="language-text"><code>(function f() {
  'use strict';
  var foo = 1;
  eval('foo = 2');
  console.log(foo);  // 2
})()
</code></pre></div><p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p> <p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p> <h4 id="eval-的别名调用"><a href="#eval-的别名调用" class="header-anchor">#</a> eval 的别名调用</h4> <p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var m = eval;
m('var x = 1');
x // 1
</code></pre></div><p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m('var x = 1')</code>执行的是<code>eval</code>命令。</p> <p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = 1;

function f() {
  var a = 2;
  var e = eval;
  e('console.log(a)');
}

f() // 1
</code></pre></div><p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p> <p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p> <div class="language- extra-class"><pre class="language-text"><code>eval.call(null, '...')
window.eval('...')
(1, eval)('...')
(eval, eval)('...')
</code></pre></div><p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域。</p> <h3 id="参考链接-6"><a href="#参考链接-6" class="header-anchor">#</a> 参考链接</h3> <ul><li>Ben Alman, <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="noopener noreferrer">Immediately-Invoked Function Expression (IIFE)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Mark Daggett, <a href="http://markdaggett.com/blog/2013/02/15/functions-explained/" target="_blank" rel="noopener noreferrer">Functions Explained<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Juriy Zaytsev, <a href="https://kangax.github.com/nfe/" target="_blank" rel="noopener noreferrer">Named function expressions demystified<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Marco Rogers polotek, <a href="http://docs.nodejitsu.com/articles/javascript-conventions/what-is-the-arguments-object" target="_blank" rel="noopener noreferrer">What is the arguments object?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Juriy Zaytsev, <a href="http://perfectionkills.com/global-eval-what-are-the-options/" target="_blank" rel="noopener noreferrer">Global eval. What are the options?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Axel Rauschmayer, <a href="http://www.2ality.com/2014/01/eval.html" target="_blank" rel="noopener noreferrer">Evaluating JavaScript code via eval() and new Function()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="数值-2"><a href="#数值-2" class="header-anchor">#</a> 数值</h2> <h3 id="定义-3"><a href="#定义-3" class="header-anchor">#</a> 定义</h3> <p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = ['a', 'b', 'c'];
</code></pre></div><p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置。</p> <p>除了在定义时赋值，数组也可以先定义后赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [];

arr[0] = 'a';
arr[1] = 'b';
arr[2] = 'c';
</code></pre></div><p>任何类型的数据，都可以放入数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [
  {a: 1},
  [1, 2, 3],
  function() {return true;}
];

arr[0] // Object {a: 1}
arr[1] // [1, 2, 3]
arr[2] // function (){return true;}
</code></pre></div><p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数。</p> <p>如果数组的元素还是数组，就形成了多维数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [[1, 2], [3, 4]];
a[0][1] // 2
a[1][1] // 4
</code></pre></div><h3 id="数组的本质"><a href="#数组的本质" class="header-anchor">#</a> 数组的本质</h3> <p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof [1, 2, 3] // &quot;object&quot;
</code></pre></div><p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象。</p> <p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = ['a', 'b', 'c'];

Object.keys(arr)
// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]
</code></pre></div><p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p> <p>由于数组成员的键名是固定的（默认总是0、1、2...），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = ['a', 'b', 'c'];

arr['0'] // 'a'
arr[0] // 'a'
</code></pre></div><p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p> <p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [];

a[1.00] = 6;
a[1] // 6
</code></pre></div><p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p> <p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.0 // SyntaxError
</code></pre></div><p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p> <h3 id="length-属性-3"><a href="#length-属性-3" class="header-anchor">#</a> length 属性</h3> <p>数组的<code>length</code>属性，返回数组的成员数量。</p> <div class="language- extra-class"><pre class="language-text"><code>['a', 'b', 'c'].length // 3
</code></pre></div><p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p> <p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = ['a', 'b'];
arr.length // 2

arr[2] = 'c';
arr.length // 3

arr[9] = 'd';
arr.length // 10

arr[1000] = 'e';
arr.length // 1001
</code></pre></div><p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p> <p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [ 'a', 'b', 'c' ];
arr.length // 3

arr.length = 2;
arr // [&quot;a&quot;, &quot;b&quot;]
</code></pre></div><p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了。</p> <p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [ 'a', 'b', 'c' ];

arr.length = 0;
arr // []
</code></pre></div><p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = ['a'];

a.length = 3;
a[1] // undefined
</code></pre></div><p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p> <p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 设置负值
[].length = -1
// RangeError: Invalid array length

// 数组元素个数大于等于2的32次方
[].length = Math.pow(2, 32)
// RangeError: Invalid array length

// 设置字符串
[].length = 'abc'
// RangeError: Invalid array length
</code></pre></div><p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [];

a['p'] = 'abc';
a.length // 0

a[2.1] = 'abc';
a.length // 0
</code></pre></div><p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p> <p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [];
arr[-1] = 'a';
arr[Math.pow(2, 32)] = 'b';

arr.length // 0
arr[-1] // &quot;a&quot;
arr[4294967296] // &quot;b&quot;
</code></pre></div><p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p> <h3 id="in-运算符"><a href="#in-运算符" class="header-anchor">#</a> in 运算符</h3> <p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [ 'a', 'b', 'c' ];
2 in arr  // true
'2' in arr // true
4 in arr // false
</code></pre></div><p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p> <p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [];
arr[100] = 'a';

100 in arr // true
1 in arr // false
</code></pre></div><p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p> <h3 id="for-in-循环和数组的遍历"><a href="#for-in-循环和数组的遍历" class="header-anchor">#</a> for...in 循环和数组的遍历</h3> <p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, 2, 3];

for (var i in a) {
  console.log(a[i]);
}
// 1
// 2
// 3
</code></pre></div><p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, 2, 3];
a.foo = true;

for (var key in a) {
  console.log(key);
}
// 0
// 1
// 2
// foo
</code></pre></div><p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组。</p> <p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, 2, 3];

// for循环
for(var i = 0; i &lt; a.length; i++) {
  console.log(a[i]);
}

// while循环
var i = 0;
while (i &lt; a.length) {
  console.log(a[i]);
  i++;
}

var l = a.length;
while (l--) {
  console.log(a[l]);
}
</code></pre></div><p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p> <p>数组的<code>forEach</code>方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。</p> <div class="language- extra-class"><pre class="language-text"><code>var colors = ['red', 'green', 'blue'];
colors.forEach(function (color) {
  console.log(color);
});
// red
// green
// blue
</code></pre></div><h3 id="数组的空位"><a href="#数组的空位" class="header-anchor">#</a> 数组的空位</h3> <p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, , 1];
a.length // 3
</code></pre></div><p>上面代码表明，数组的空位不影响<code>length</code>属性。虽然这个位置没有值，引擎依然认为这个位置是有效的。</p> <p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, 2, 3,];

a.length // 3
a // [1, 2, 3]
</code></pre></div><p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p> <p>数组的空位是可以读取的，返回<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [, , ,];
a[1] // undefined
</code></pre></div><p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1, 2, 3];
delete a[1];

a[1] // undefined
a.length // 3
</code></pre></div><p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p> <p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [, , ,];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
})
// 不产生任何输出

for (var i in a) {
  console.log(i);
}
// 不产生任何输出

Object.keys(a)
// []
</code></pre></div><p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [undefined, undefined, undefined];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
});
// 0. undefined
// 1. undefined
// 2. undefined

for (var i in a) {
  console.log(i);
}
// 0
// 1
// 2

Object.keys(a)
// ['0', '1', '2']
</code></pre></div><p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p> <h3 id="类似数组的对象"><a href="#类似数组的对象" class="header-anchor">#</a> 类似数组的对象</h3> <p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};

obj[0] // 'a'
obj[1] // 'b'
obj.length // 3
obj.push('d') // TypeError: obj.push is not a function
</code></pre></div><p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p> <p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {
  length: 0
};
obj[3] = 'd';
obj.length // 0
</code></pre></div><p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p> <p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>// arguments对象
function args() { return arguments }
var arrayLike = args('a', 'b');

arrayLike[0] // 'a'
arrayLike.length // 2
arrayLike instanceof Array // false

// DOM元素集
var elts = document.getElementsByTagName('h3');
elts.length // 3
elts instanceof Array // false

// 字符串
'abc'[1] // 'b'
'abc'.length // 3
'abc' instanceof Array // false
</code></pre></div><p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p> <p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = Array.prototype.slice.call(arrayLike);
</code></pre></div><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p> <div class="language- extra-class"><pre class="language-text"><code>function print(value, index) {
  console.log(index + ' : ' + value);
}

Array.prototype.forEach.call(arrayLike, print);
</code></pre></div><p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p> <p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>// forEach 方法
function logArgs() {
  Array.prototype.forEach.call(arguments, function (elem, i) {
    console.log(i + '. ' + elem);
  });
}

// 等同于 for 循环
function logArgs() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(i + '. ' + arguments[i]);
  }
}
</code></pre></div><p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p> <div class="language- extra-class"><pre class="language-text"><code>Array.prototype.forEach.call('abc', function (chr) {
  console.log(chr);
});
// a
// b
// c
</code></pre></div><p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = Array.prototype.slice.call('abc');
arr.forEach(function (chr) {
  console.log(chr);
});
// a
// b
// c
</code></pre></div><h3 id="参考链接-7"><a href="#参考链接-7" class="header-anchor">#</a> 参考链接</h3> <ul><li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/12/arrays.html" target="_blank" rel="noopener noreferrer">Arrays in JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/06/dense-arrays.html" target="_blank" rel="noopener noreferrer">JavaScript: sparse arrays vs. dense arrays<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Felix Bohm, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/what-they-didnt-tell-you-about-es5s-array-extras/" target="_blank" rel="noopener noreferrer">What They Didn’t Tell You About ES5′s Array Extras<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Juriy Zaytsev, <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/" target="_blank" rel="noopener noreferrer">How ECMAScript 5 still does not allow to subclass an array<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/01/15, 11:11:38</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/49877d/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">入门篇</div></a> <a href="/pages/69c69e/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">运算符</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/49877d/" class="prev">入门篇</a></span> <span class="next"><a href="/pages/69c69e/">运算符</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/610238/"><div>浏览器模型(四)</div></a> <span>12-12</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/229568/"><div>浏览器模型(一)</div></a> <span>12-11</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/ffb0a1/"><div>浏览器模型(二)</div></a> <span>12-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1390128154@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wuKongNotNull" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2022
    <span>悟空非空也 | <a href="https://github.com/WuKongNotNull/wukong-post/blob/main/LICENSE" target="_blank">Apache License 2.0</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0772105c.js" defer></script><script src="/assets/js/2.6497fd29.js" defer></script><script src="/assets/js/210.c5ddee43.js" defer></script>
  </body>
</html>