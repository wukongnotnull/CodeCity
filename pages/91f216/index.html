<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DOM | 悟空非空也</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="keywords" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.4a9c0c84.css" as="style"><link rel="preload" href="/assets/js/app.0772105c.js" as="script"><link rel="preload" href="/assets/js/2.6497fd29.js" as="script"><link rel="preload" href="/assets/js/216.4045669d.js" as="script"><link rel="prefetch" href="/assets/js/10.0a7a5c2a.js"><link rel="prefetch" href="/assets/js/100.6dd9a587.js"><link rel="prefetch" href="/assets/js/101.b1cb7166.js"><link rel="prefetch" href="/assets/js/102.6a888436.js"><link rel="prefetch" href="/assets/js/103.075294d1.js"><link rel="prefetch" href="/assets/js/104.7f9d5a4c.js"><link rel="prefetch" href="/assets/js/105.bcc3dd3e.js"><link rel="prefetch" href="/assets/js/106.9cadb287.js"><link rel="prefetch" href="/assets/js/107.1d6b3af1.js"><link rel="prefetch" href="/assets/js/108.7377cb7f.js"><link rel="prefetch" href="/assets/js/109.ca3ceab0.js"><link rel="prefetch" href="/assets/js/11.961408a3.js"><link rel="prefetch" href="/assets/js/110.79c5c987.js"><link rel="prefetch" href="/assets/js/111.63b3d196.js"><link rel="prefetch" href="/assets/js/112.ced4f0e9.js"><link rel="prefetch" href="/assets/js/113.657daa4e.js"><link rel="prefetch" href="/assets/js/114.e5d0a86b.js"><link rel="prefetch" href="/assets/js/115.a89005f0.js"><link rel="prefetch" href="/assets/js/116.bcbccecc.js"><link rel="prefetch" href="/assets/js/117.7acf9f16.js"><link rel="prefetch" href="/assets/js/118.75e4e713.js"><link rel="prefetch" href="/assets/js/119.0395ec5d.js"><link rel="prefetch" href="/assets/js/12.aab67183.js"><link rel="prefetch" href="/assets/js/120.93179733.js"><link rel="prefetch" href="/assets/js/121.e80fc142.js"><link rel="prefetch" href="/assets/js/122.41a175f0.js"><link rel="prefetch" href="/assets/js/123.028fd9cd.js"><link rel="prefetch" href="/assets/js/124.100b1fb0.js"><link rel="prefetch" href="/assets/js/125.13d51556.js"><link rel="prefetch" href="/assets/js/126.02c987a2.js"><link rel="prefetch" href="/assets/js/127.f7e115fe.js"><link rel="prefetch" href="/assets/js/128.eb930737.js"><link rel="prefetch" href="/assets/js/129.29fef1d1.js"><link rel="prefetch" href="/assets/js/13.7dd23d29.js"><link rel="prefetch" href="/assets/js/130.7e4c3bbc.js"><link rel="prefetch" href="/assets/js/131.16f04a03.js"><link rel="prefetch" href="/assets/js/132.c811b5cf.js"><link rel="prefetch" href="/assets/js/133.4a0d2ee8.js"><link rel="prefetch" href="/assets/js/134.aa288243.js"><link rel="prefetch" href="/assets/js/135.7d74b67e.js"><link rel="prefetch" href="/assets/js/136.f6a4d7dc.js"><link rel="prefetch" href="/assets/js/137.4a8c94fa.js"><link rel="prefetch" href="/assets/js/138.30103e18.js"><link rel="prefetch" href="/assets/js/139.cb62e822.js"><link rel="prefetch" href="/assets/js/14.7a045a57.js"><link rel="prefetch" href="/assets/js/140.4849d011.js"><link rel="prefetch" href="/assets/js/141.b53f0217.js"><link rel="prefetch" href="/assets/js/142.d2e12f6f.js"><link rel="prefetch" href="/assets/js/143.41effcfd.js"><link rel="prefetch" href="/assets/js/144.5ed3025f.js"><link rel="prefetch" href="/assets/js/145.ec71ac40.js"><link rel="prefetch" href="/assets/js/146.dc482dc8.js"><link rel="prefetch" href="/assets/js/147.f43c3786.js"><link rel="prefetch" href="/assets/js/148.e60884a5.js"><link rel="prefetch" href="/assets/js/149.fd305860.js"><link rel="prefetch" href="/assets/js/15.b07b6e42.js"><link rel="prefetch" href="/assets/js/150.e294561d.js"><link rel="prefetch" href="/assets/js/151.5cda3c43.js"><link rel="prefetch" href="/assets/js/152.ec1bec3f.js"><link rel="prefetch" href="/assets/js/153.411bc769.js"><link rel="prefetch" href="/assets/js/154.d0b70cd8.js"><link rel="prefetch" href="/assets/js/155.8013985e.js"><link rel="prefetch" href="/assets/js/156.9e9c91f4.js"><link rel="prefetch" href="/assets/js/157.0273d672.js"><link rel="prefetch" href="/assets/js/158.2612db04.js"><link rel="prefetch" href="/assets/js/159.9942bd3a.js"><link rel="prefetch" href="/assets/js/16.511be8ae.js"><link rel="prefetch" href="/assets/js/160.69e027a9.js"><link rel="prefetch" href="/assets/js/161.3d0255ab.js"><link rel="prefetch" href="/assets/js/162.4f223488.js"><link rel="prefetch" href="/assets/js/163.aca282a2.js"><link rel="prefetch" href="/assets/js/164.68c99b46.js"><link rel="prefetch" href="/assets/js/165.f455fb7b.js"><link rel="prefetch" href="/assets/js/166.a4d94e8d.js"><link rel="prefetch" href="/assets/js/167.dad8c77e.js"><link rel="prefetch" href="/assets/js/168.cb0717be.js"><link rel="prefetch" href="/assets/js/169.61a9bd6a.js"><link rel="prefetch" href="/assets/js/17.bbcfeede.js"><link rel="prefetch" href="/assets/js/170.f3785783.js"><link rel="prefetch" href="/assets/js/171.238d90d3.js"><link rel="prefetch" href="/assets/js/172.63852414.js"><link rel="prefetch" href="/assets/js/173.613fce9e.js"><link rel="prefetch" href="/assets/js/174.761ee99c.js"><link rel="prefetch" href="/assets/js/175.f2953a9b.js"><link rel="prefetch" href="/assets/js/176.415405fd.js"><link rel="prefetch" href="/assets/js/177.5c3782be.js"><link rel="prefetch" href="/assets/js/178.7c081109.js"><link rel="prefetch" href="/assets/js/179.038faa2b.js"><link rel="prefetch" href="/assets/js/18.c6108eaa.js"><link rel="prefetch" href="/assets/js/180.f498ca2e.js"><link rel="prefetch" href="/assets/js/181.ec14688f.js"><link rel="prefetch" href="/assets/js/182.1279a689.js"><link rel="prefetch" href="/assets/js/183.ced575fe.js"><link rel="prefetch" href="/assets/js/184.34f3c06c.js"><link rel="prefetch" href="/assets/js/185.b3d1acb8.js"><link rel="prefetch" href="/assets/js/186.b6efd99e.js"><link rel="prefetch" href="/assets/js/187.9b3f72f6.js"><link rel="prefetch" href="/assets/js/188.2e66f79c.js"><link rel="prefetch" href="/assets/js/189.4d12400d.js"><link rel="prefetch" href="/assets/js/19.192ec262.js"><link rel="prefetch" href="/assets/js/190.e353d2e5.js"><link rel="prefetch" href="/assets/js/191.7d655069.js"><link rel="prefetch" href="/assets/js/192.c33b286e.js"><link rel="prefetch" href="/assets/js/193.c9f461d3.js"><link rel="prefetch" href="/assets/js/194.32fdc071.js"><link rel="prefetch" href="/assets/js/195.03c708fc.js"><link rel="prefetch" href="/assets/js/196.54c890cf.js"><link rel="prefetch" href="/assets/js/197.68d0761d.js"><link rel="prefetch" href="/assets/js/198.efdf4f70.js"><link rel="prefetch" href="/assets/js/199.abaad0a6.js"><link rel="prefetch" href="/assets/js/20.d04c28bc.js"><link rel="prefetch" href="/assets/js/200.bd80bb59.js"><link rel="prefetch" href="/assets/js/201.4316ce7c.js"><link rel="prefetch" href="/assets/js/202.182fb8ad.js"><link rel="prefetch" href="/assets/js/203.7c514243.js"><link rel="prefetch" href="/assets/js/204.622bbe90.js"><link rel="prefetch" href="/assets/js/205.28f69f06.js"><link rel="prefetch" href="/assets/js/206.0c4c24eb.js"><link rel="prefetch" href="/assets/js/207.ea976c79.js"><link rel="prefetch" href="/assets/js/208.c4f49e55.js"><link rel="prefetch" href="/assets/js/209.4e2dacde.js"><link rel="prefetch" href="/assets/js/21.d8b6c127.js"><link rel="prefetch" href="/assets/js/210.c5ddee43.js"><link rel="prefetch" href="/assets/js/211.2db8e6bf.js"><link rel="prefetch" href="/assets/js/212.9e5c2afe.js"><link rel="prefetch" href="/assets/js/213.9fc56fcc.js"><link rel="prefetch" href="/assets/js/214.b22b8fd0.js"><link rel="prefetch" href="/assets/js/215.b714511d.js"><link rel="prefetch" href="/assets/js/217.b8bfc481.js"><link rel="prefetch" href="/assets/js/218.4cc6231a.js"><link rel="prefetch" href="/assets/js/219.b04f0864.js"><link rel="prefetch" href="/assets/js/22.a21d9c67.js"><link rel="prefetch" href="/assets/js/220.5c5efc16.js"><link rel="prefetch" href="/assets/js/221.b3cc4226.js"><link rel="prefetch" href="/assets/js/222.14568620.js"><link rel="prefetch" href="/assets/js/223.5ad9c326.js"><link rel="prefetch" href="/assets/js/224.bef27670.js"><link rel="prefetch" href="/assets/js/225.7e76ba96.js"><link rel="prefetch" href="/assets/js/226.c892c0a5.js"><link rel="prefetch" href="/assets/js/227.1a5c5dfe.js"><link rel="prefetch" href="/assets/js/228.a83d26e3.js"><link rel="prefetch" href="/assets/js/229.f69558a4.js"><link rel="prefetch" href="/assets/js/23.e6bed599.js"><link rel="prefetch" href="/assets/js/230.975e6807.js"><link rel="prefetch" href="/assets/js/231.3323c121.js"><link rel="prefetch" href="/assets/js/232.69b5135e.js"><link rel="prefetch" href="/assets/js/233.f27782e6.js"><link rel="prefetch" href="/assets/js/234.c1e937f3.js"><link rel="prefetch" href="/assets/js/235.500694bc.js"><link rel="prefetch" href="/assets/js/236.6b6f2f84.js"><link rel="prefetch" href="/assets/js/237.a529e2ba.js"><link rel="prefetch" href="/assets/js/238.d5bca3eb.js"><link rel="prefetch" href="/assets/js/239.0b79bd7b.js"><link rel="prefetch" href="/assets/js/24.1be4b8e9.js"><link rel="prefetch" href="/assets/js/240.baec5139.js"><link rel="prefetch" href="/assets/js/241.eef96f93.js"><link rel="prefetch" href="/assets/js/242.8208455c.js"><link rel="prefetch" href="/assets/js/243.4c8fdc98.js"><link rel="prefetch" href="/assets/js/244.e11ee13c.js"><link rel="prefetch" href="/assets/js/245.b1e7beba.js"><link rel="prefetch" href="/assets/js/246.4c24ee87.js"><link rel="prefetch" href="/assets/js/247.f3958ef5.js"><link rel="prefetch" href="/assets/js/248.3f533151.js"><link rel="prefetch" href="/assets/js/249.6d80f1cd.js"><link rel="prefetch" href="/assets/js/25.7420391b.js"><link rel="prefetch" href="/assets/js/250.2faf865a.js"><link rel="prefetch" href="/assets/js/251.88d81ef7.js"><link rel="prefetch" href="/assets/js/252.04a6a69c.js"><link rel="prefetch" href="/assets/js/253.32528c6e.js"><link rel="prefetch" href="/assets/js/254.312c70ad.js"><link rel="prefetch" href="/assets/js/255.ff88a488.js"><link rel="prefetch" href="/assets/js/256.8b782088.js"><link rel="prefetch" href="/assets/js/257.1e04db72.js"><link rel="prefetch" href="/assets/js/258.6b8e65a8.js"><link rel="prefetch" href="/assets/js/259.c1a78951.js"><link rel="prefetch" href="/assets/js/26.b979a08f.js"><link rel="prefetch" href="/assets/js/260.2910b3b5.js"><link rel="prefetch" href="/assets/js/261.b3c9ff4f.js"><link rel="prefetch" href="/assets/js/262.a4846d38.js"><link rel="prefetch" href="/assets/js/263.2fe51a99.js"><link rel="prefetch" href="/assets/js/264.790ac186.js"><link rel="prefetch" href="/assets/js/265.2da80512.js"><link rel="prefetch" href="/assets/js/266.86531545.js"><link rel="prefetch" href="/assets/js/267.2d8df6ee.js"><link rel="prefetch" href="/assets/js/268.caf4f057.js"><link rel="prefetch" href="/assets/js/269.5cb1755d.js"><link rel="prefetch" href="/assets/js/27.46acb058.js"><link rel="prefetch" href="/assets/js/270.93b039ff.js"><link rel="prefetch" href="/assets/js/271.a83d9432.js"><link rel="prefetch" href="/assets/js/272.f957cb9b.js"><link rel="prefetch" href="/assets/js/273.00fda4c5.js"><link rel="prefetch" href="/assets/js/274.90d11b33.js"><link rel="prefetch" href="/assets/js/275.a5ab6a4b.js"><link rel="prefetch" href="/assets/js/276.e1553171.js"><link rel="prefetch" href="/assets/js/277.fc579c76.js"><link rel="prefetch" href="/assets/js/278.eecaef76.js"><link rel="prefetch" href="/assets/js/279.4ccbe5fd.js"><link rel="prefetch" href="/assets/js/28.d679a88b.js"><link rel="prefetch" href="/assets/js/280.1a2df8d1.js"><link rel="prefetch" href="/assets/js/281.4d879315.js"><link rel="prefetch" href="/assets/js/282.1a638b6e.js"><link rel="prefetch" href="/assets/js/283.35d77274.js"><link rel="prefetch" href="/assets/js/284.236f6c0d.js"><link rel="prefetch" href="/assets/js/285.f911dc9c.js"><link rel="prefetch" href="/assets/js/286.f2032fe0.js"><link rel="prefetch" href="/assets/js/287.47be0dd9.js"><link rel="prefetch" href="/assets/js/288.805d6e1e.js"><link rel="prefetch" href="/assets/js/289.af37d311.js"><link rel="prefetch" href="/assets/js/29.9fb32fde.js"><link rel="prefetch" href="/assets/js/290.cc34cbe3.js"><link rel="prefetch" href="/assets/js/291.887bcdbb.js"><link rel="prefetch" href="/assets/js/292.88848329.js"><link rel="prefetch" href="/assets/js/293.c5e4486a.js"><link rel="prefetch" href="/assets/js/294.4cc2aedf.js"><link rel="prefetch" href="/assets/js/295.1072aab8.js"><link rel="prefetch" href="/assets/js/296.1b0b3008.js"><link rel="prefetch" href="/assets/js/297.0f879887.js"><link rel="prefetch" href="/assets/js/298.516a7d92.js"><link rel="prefetch" href="/assets/js/299.a039e1fa.js"><link rel="prefetch" href="/assets/js/3.8f0b1c2b.js"><link rel="prefetch" href="/assets/js/30.49c708c9.js"><link rel="prefetch" href="/assets/js/300.d7f284d1.js"><link rel="prefetch" href="/assets/js/301.d0b1dd6f.js"><link rel="prefetch" href="/assets/js/302.4b55dd23.js"><link rel="prefetch" href="/assets/js/303.feb01496.js"><link rel="prefetch" href="/assets/js/304.3ab97c4d.js"><link rel="prefetch" href="/assets/js/305.591a1558.js"><link rel="prefetch" href="/assets/js/306.adb43a3c.js"><link rel="prefetch" href="/assets/js/307.b05d288b.js"><link rel="prefetch" href="/assets/js/308.4567d4af.js"><link rel="prefetch" href="/assets/js/309.72c51c16.js"><link rel="prefetch" href="/assets/js/31.11f8cedc.js"><link rel="prefetch" href="/assets/js/310.3962fc11.js"><link rel="prefetch" href="/assets/js/311.75aa7b05.js"><link rel="prefetch" href="/assets/js/312.9ec9fde7.js"><link rel="prefetch" href="/assets/js/313.d6f6baa3.js"><link rel="prefetch" href="/assets/js/314.86cdfa89.js"><link rel="prefetch" href="/assets/js/315.25959c53.js"><link rel="prefetch" href="/assets/js/316.8fa91955.js"><link rel="prefetch" href="/assets/js/317.4248ad4c.js"><link rel="prefetch" href="/assets/js/318.3f9ca0c5.js"><link rel="prefetch" href="/assets/js/319.32be3008.js"><link rel="prefetch" href="/assets/js/32.4e2e98b3.js"><link rel="prefetch" href="/assets/js/320.b8a7b72b.js"><link rel="prefetch" href="/assets/js/321.a3f7c1a6.js"><link rel="prefetch" href="/assets/js/322.d0903e0c.js"><link rel="prefetch" href="/assets/js/323.99520c43.js"><link rel="prefetch" href="/assets/js/324.333a4f10.js"><link rel="prefetch" href="/assets/js/325.e502b8f9.js"><link rel="prefetch" href="/assets/js/326.8e57faf4.js"><link rel="prefetch" href="/assets/js/327.f0473fc3.js"><link rel="prefetch" href="/assets/js/328.eaa4bf5f.js"><link rel="prefetch" href="/assets/js/329.dc0763f7.js"><link rel="prefetch" href="/assets/js/33.90114516.js"><link rel="prefetch" href="/assets/js/330.1f60cb6e.js"><link rel="prefetch" href="/assets/js/331.4af5e363.js"><link rel="prefetch" href="/assets/js/332.2a2023db.js"><link rel="prefetch" href="/assets/js/333.4c5db27a.js"><link rel="prefetch" href="/assets/js/334.f52a66e5.js"><link rel="prefetch" href="/assets/js/335.a6481538.js"><link rel="prefetch" href="/assets/js/336.6bd556c7.js"><link rel="prefetch" href="/assets/js/337.58a4d668.js"><link rel="prefetch" href="/assets/js/338.22095960.js"><link rel="prefetch" href="/assets/js/339.c8da6647.js"><link rel="prefetch" href="/assets/js/34.225b456c.js"><link rel="prefetch" href="/assets/js/340.9f93002f.js"><link rel="prefetch" href="/assets/js/341.721ab41d.js"><link rel="prefetch" href="/assets/js/342.f129aa89.js"><link rel="prefetch" href="/assets/js/343.ea2d2309.js"><link rel="prefetch" href="/assets/js/344.15235001.js"><link rel="prefetch" href="/assets/js/345.eaaae5e5.js"><link rel="prefetch" href="/assets/js/346.73b19ced.js"><link rel="prefetch" href="/assets/js/347.6e11bced.js"><link rel="prefetch" href="/assets/js/348.3b9b7968.js"><link rel="prefetch" href="/assets/js/349.b60a2b56.js"><link rel="prefetch" href="/assets/js/35.e3ec78ba.js"><link rel="prefetch" href="/assets/js/350.e793c7b9.js"><link rel="prefetch" href="/assets/js/351.c86b1ea0.js"><link rel="prefetch" href="/assets/js/352.770038d5.js"><link rel="prefetch" href="/assets/js/353.fe8f38a5.js"><link rel="prefetch" href="/assets/js/354.d3bbf169.js"><link rel="prefetch" href="/assets/js/355.5bb68a7e.js"><link rel="prefetch" href="/assets/js/356.b380aecd.js"><link rel="prefetch" href="/assets/js/357.24fbf1ff.js"><link rel="prefetch" href="/assets/js/358.669b8aba.js"><link rel="prefetch" href="/assets/js/359.04af7f75.js"><link rel="prefetch" href="/assets/js/36.dedb6e42.js"><link rel="prefetch" href="/assets/js/360.73d170d7.js"><link rel="prefetch" href="/assets/js/361.c1f55230.js"><link rel="prefetch" href="/assets/js/362.967bb47e.js"><link rel="prefetch" href="/assets/js/363.7b39c192.js"><link rel="prefetch" href="/assets/js/364.7dbf94dd.js"><link rel="prefetch" href="/assets/js/365.8a1d46d7.js"><link rel="prefetch" href="/assets/js/366.997ec05e.js"><link rel="prefetch" href="/assets/js/367.cda39f93.js"><link rel="prefetch" href="/assets/js/368.1159aebc.js"><link rel="prefetch" href="/assets/js/369.8371cbf0.js"><link rel="prefetch" href="/assets/js/37.129a1339.js"><link rel="prefetch" href="/assets/js/370.b5bda99f.js"><link rel="prefetch" href="/assets/js/371.ca4c4c31.js"><link rel="prefetch" href="/assets/js/372.6ecb7277.js"><link rel="prefetch" href="/assets/js/373.d3d1f018.js"><link rel="prefetch" href="/assets/js/374.4901bb51.js"><link rel="prefetch" href="/assets/js/375.ab11fdff.js"><link rel="prefetch" href="/assets/js/376.f34fed60.js"><link rel="prefetch" href="/assets/js/377.8d8aa0d5.js"><link rel="prefetch" href="/assets/js/378.16a432ff.js"><link rel="prefetch" href="/assets/js/379.68163d64.js"><link rel="prefetch" href="/assets/js/38.e0e2c3b1.js"><link rel="prefetch" href="/assets/js/39.a33bdbc2.js"><link rel="prefetch" href="/assets/js/4.d96ebf17.js"><link rel="prefetch" href="/assets/js/40.d20c1395.js"><link rel="prefetch" href="/assets/js/41.a2d6458f.js"><link rel="prefetch" href="/assets/js/42.48c0ea87.js"><link rel="prefetch" href="/assets/js/43.e2e765f4.js"><link rel="prefetch" href="/assets/js/44.10b67e66.js"><link rel="prefetch" href="/assets/js/45.2cd4b906.js"><link rel="prefetch" href="/assets/js/46.7a02c8ab.js"><link rel="prefetch" href="/assets/js/47.d88632c9.js"><link rel="prefetch" href="/assets/js/48.ade443fe.js"><link rel="prefetch" href="/assets/js/49.4d2ddb3b.js"><link rel="prefetch" href="/assets/js/5.037e08ba.js"><link rel="prefetch" href="/assets/js/50.463230b1.js"><link rel="prefetch" href="/assets/js/51.83c9a564.js"><link rel="prefetch" href="/assets/js/52.56c5a325.js"><link rel="prefetch" href="/assets/js/53.72a3b829.js"><link rel="prefetch" href="/assets/js/54.8f59548e.js"><link rel="prefetch" href="/assets/js/55.0faca6a3.js"><link rel="prefetch" href="/assets/js/56.77474658.js"><link rel="prefetch" href="/assets/js/57.4e4789fa.js"><link rel="prefetch" href="/assets/js/58.9dc82ebc.js"><link rel="prefetch" href="/assets/js/59.2147b861.js"><link rel="prefetch" href="/assets/js/6.8af55c48.js"><link rel="prefetch" href="/assets/js/60.d0ff683a.js"><link rel="prefetch" href="/assets/js/61.331527c3.js"><link rel="prefetch" href="/assets/js/62.a9085bf0.js"><link rel="prefetch" href="/assets/js/63.ecaf766f.js"><link rel="prefetch" href="/assets/js/64.f9a1f00a.js"><link rel="prefetch" href="/assets/js/65.69eef128.js"><link rel="prefetch" href="/assets/js/66.7ce420d5.js"><link rel="prefetch" href="/assets/js/67.059927af.js"><link rel="prefetch" href="/assets/js/68.d1e1fb62.js"><link rel="prefetch" href="/assets/js/69.a98be775.js"><link rel="prefetch" href="/assets/js/7.330a4708.js"><link rel="prefetch" href="/assets/js/70.c773f1fb.js"><link rel="prefetch" href="/assets/js/71.23db970d.js"><link rel="prefetch" href="/assets/js/72.3f45b262.js"><link rel="prefetch" href="/assets/js/73.cc16dadf.js"><link rel="prefetch" href="/assets/js/74.1f05b2b1.js"><link rel="prefetch" href="/assets/js/75.3cd7d993.js"><link rel="prefetch" href="/assets/js/76.1e78e542.js"><link rel="prefetch" href="/assets/js/77.d97d60f9.js"><link rel="prefetch" href="/assets/js/78.6997cb3a.js"><link rel="prefetch" href="/assets/js/79.e8ef607f.js"><link rel="prefetch" href="/assets/js/8.cca0e264.js"><link rel="prefetch" href="/assets/js/80.57d72889.js"><link rel="prefetch" href="/assets/js/81.7aee8496.js"><link rel="prefetch" href="/assets/js/82.0b920de1.js"><link rel="prefetch" href="/assets/js/83.429d7e6f.js"><link rel="prefetch" href="/assets/js/84.c74f1357.js"><link rel="prefetch" href="/assets/js/85.71d21661.js"><link rel="prefetch" href="/assets/js/86.d55ba6f0.js"><link rel="prefetch" href="/assets/js/87.6566a5fc.js"><link rel="prefetch" href="/assets/js/88.6cfa26b6.js"><link rel="prefetch" href="/assets/js/89.0a9ed463.js"><link rel="prefetch" href="/assets/js/9.ef46dc1c.js"><link rel="prefetch" href="/assets/js/90.507b8bb7.js"><link rel="prefetch" href="/assets/js/91.0c374e4a.js"><link rel="prefetch" href="/assets/js/92.1f6e9c9d.js"><link rel="prefetch" href="/assets/js/93.33a64374.js"><link rel="prefetch" href="/assets/js/94.68d20253.js"><link rel="prefetch" href="/assets/js/95.2cf46b84.js"><link rel="prefetch" href="/assets/js/96.9b292e88.js"><link rel="prefetch" href="/assets/js/97.1575dbac.js"><link rel="prefetch" href="/assets/js/98.b8682f4a.js"><link rel="prefetch" href="/assets/js/99.0039b460.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4a9c0c84.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/favicon.ico" alt="悟空非空也" class="logo"> <span class="site-name can-hide">悟空非空也</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/wuKongNotNull/images-hosting/wukong-website/wukong-favicon-nobg.png"> <div class="blogger-info"><h3>悟空非空也</h3> <span>精通各语言拼写的野生程序员</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础教程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>青铜</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>入门</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/49877d/" class="sidebar-link">入门篇</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>数据类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>运算符</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/pages/36f9e8/" class="sidebar-link">语法专题</a></li><li><a href="/pages/3e3990/" class="sidebar-link">标准库</a></li><li><a href="/pages/32c5b1/" class="sidebar-link">面向对象编程</a></li><li><a href="/pages/73df15/" class="sidebar-link">异步操作</a></li><li><a href="/pages/91f216/" aria-current="page" class="active sidebar-link">DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#概述" class="sidebar-link">概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#dom-2" class="sidebar-link">DOM</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#节点" class="sidebar-link">节点</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#节点树" class="sidebar-link">节点树</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#node-接口" class="sidebar-link">Node 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#属性" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#方法" class="sidebar-link">方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#nodelist-接口-htmlcollection接口" class="sidebar-link">NodeList 接口，HTMLCollection接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#nodelist-接口" class="sidebar-link">NodeList 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#htmlcollection-接口" class="sidebar-link">HTMLCollection 接口</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#parentnode-接口-childnode-接口" class="sidebar-link">ParentNode 接口，ChildNode 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#parentnode-接口" class="sidebar-link">ParentNode 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#childnode-接口" class="sidebar-link">ChildNode 接口</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#document-节点" class="sidebar-link">Document 节点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#概述-4" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#属性-2" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#方法-2" class="sidebar-link">方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#element-节点" class="sidebar-link">Element 节点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#实例属性" class="sidebar-link">实例属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#实例方法" class="sidebar-link">实例方法</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#参考链接" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#属性的操作" class="sidebar-link">属性的操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#element-attributes-属性" class="sidebar-link">Element.attributes 属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#元素的标准属性" class="sidebar-link">元素的标准属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#属性操作的标准方法" class="sidebar-link">属性操作的标准方法</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#dataset-属性" class="sidebar-link">dataset 属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#text-节点和-documentfragment-节点" class="sidebar-link">Text 节点和 DocumentFragment 节点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#text-节点的概念" class="sidebar-link">Text 节点的概念</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#text-节点的属性" class="sidebar-link">Text 节点的属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#text-节点的方法" class="sidebar-link">Text 节点的方法</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#documentfragment-节点" class="sidebar-link">DocumentFragment 节点</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#css-操作" class="sidebar-link">CSS 操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#html-元素的-style-属性" class="sidebar-link">HTML 元素的 style 属性</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#cssstyledeclaration-接口" class="sidebar-link">CSSStyleDeclaration 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#css-模块的侦测" class="sidebar-link">CSS 模块的侦测</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#css-对象" class="sidebar-link">CSS 对象</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#window-getcomputedstyle" class="sidebar-link">window.getComputedStyle()</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#css-伪元素" class="sidebar-link">CSS 伪元素</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#stylesheet-接口" class="sidebar-link">StyleSheet 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#实例-添加样式表" class="sidebar-link">实例：添加样式表</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#cssrulelist-接口" class="sidebar-link">CSSRuleList 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#cssrule-接口" class="sidebar-link">CSSRule 接口</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#window-matchmedia" class="sidebar-link">window.matchMedia()</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/91f216/#mutation-observer-api" class="sidebar-link">Mutation Observer API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/91f216/#概述-8" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#mutationobserver-构造函数" class="sidebar-link">MutationObserver 构造函数</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#mutationobserver-的实例方法" class="sidebar-link">MutationObserver 的实例方法</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#mutationrecord-对象" class="sidebar-link">MutationRecord 对象</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#应用示例" class="sidebar-link">应用示例</a></li><li class="sidebar-sub-header"><a href="/pages/91f216/#参考链接-2" class="sidebar-link">参考链接</a></li></ul></li></ul></li><li><a href="/pages/329076/" class="sidebar-link">事件</a></li><li><a href="/pages/229568/" class="sidebar-link">浏览器模型(一)</a></li><li><a href="/pages/ffb0a1/" class="sidebar-link">浏览器模型(二)</a></li><li><a href="/pages/b7cf03/" class="sidebar-link">浏览器模型(三)</a></li><li><a href="/pages/610238/" class="sidebar-link">浏览器模型(四)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《ES6 教程》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Vue》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《React》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《TypeScript 从零实现 axios》</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Git》学习笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript文章</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/fore" title="大前端-目录页" data-v-1cd794fe>大前端</a></li> <li data-v-1cd794fe><a href="/fore/#JavaScript基础教程" title="大前端#JavaScript基础教程" data-v-1cd794fe>JavaScript基础教程</a></li> <li data-v-1cd794fe><a href="/fore/#青铜" title="大前端#青铜" data-v-1cd794fe>青铜</a></li></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/wuKongNotNull" target="_blank" title="作者" class="beLink" data-v-1cd794fe>悟空非空也</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-12-06</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          DOM
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><h1 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h1> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <h3 id="dom-2"><a href="#dom-2" class="header-anchor">#</a> DOM</h3> <p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p> <p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p> <p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p> <h3 id="节点"><a href="#节点" class="header-anchor">#</a> 节点</h3> <p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p> <p>节点的类型有七种。</p> <ul><li><code>Document</code>：整个文档树的顶层节点</li> <li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li> <li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li> <li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li> <li><code>Text</code>：标签之间或标签包含的文本</li> <li><code>Comment</code>：注释</li> <li><code>DocumentFragment</code>：文档的片段</li></ul> <p>浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</p> <h3 id="节点树"><a href="#节点树" class="header-anchor">#</a> 节点树</h3> <p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p> <p>浏览器原生提供<code>document</code>节点，代表整个文档。</p> <div class="language- extra-class"><pre class="language-text"><code>document
// 整个文档树
</code></pre></div><p>文档的第一层有两个节点，第一个是文档类型节点（<code>&lt;!doctype html&gt;</code>），第二个是 HTML 网页的顶层容器标签<code>&lt;html&gt;</code>。后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p> <p>除了根节点，其他节点都有三种层级关系。</p> <ul><li>父节点关系（parentNode）：直接的那个上级节点</li> <li>子节点关系（childNodes）：直接的下级节点</li> <li>同级节点关系（sibling）：拥有同一个父节点的节点</li></ul> <p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p> <h2 id="node-接口"><a href="#node-接口" class="header-anchor">#</a> Node 接口</h2> <p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <h4 id="node-prototype-nodetype"><a href="#node-prototype-nodetype" class="header-anchor">#</a> Node.prototype.nodeType</h4> <p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p> <div class="language- extra-class"><pre class="language-text"><code>document.nodeType // 9
</code></pre></div><p>上面代码中，文档节点的类型值为9。</p> <p>Node 对象定义了几个常量，对应这些类型值。</p> <div class="language- extra-class"><pre class="language-text"><code>document.nodeType === Node.DOCUMENT_NODE // true
</code></pre></div><p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p> <p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p> <ul><li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li> <li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li> <li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li> <li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li> <li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li> <li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li> <li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li></ul> <p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var node = document.documentElement.firstChild;
if (node.nodeType === Node.ELEMENT_NODE) {
  console.log('该节点是元素节点');
}
</code></pre></div><h4 id="node-prototype-nodename"><a href="#node-prototype-nodename" class="header-anchor">#</a> Node.prototype.nodeName</h4> <p><code>nodeName</code>属性返回节点的名称。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById('d1');
div.nodeName // &quot;DIV&quot;
</code></pre></div><p>上面代码中，元素节点<code>&lt;div&gt;</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p> <p>不同节点的<code>nodeName</code>属性值如下。</p> <ul><li>文档节点（document）：<code>#document</code></li> <li>元素节点（element）：大写的标签名</li> <li>属性节点（attr）：属性的名称</li> <li>文本节点（text）：<code>#text</code></li> <li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li> <li>文档类型节点（DocumentType）：文档的类型</li> <li>注释节点（Comment）：<code>#comment</code></li></ul> <h4 id="node-prototype-nodevalue"><a href="#node-prototype-nodevalue" class="header-anchor">#</a> Node.prototype.nodeValue</h4> <p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p> <p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById('d1');
div.nodeValue // null
div.firstChild.nodeValue // &quot;hello world&quot;
</code></pre></div><p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p> <h4 id="node-prototype-textcontent"><a href="#node-prototype-textcontent" class="header-anchor">#</a> Node.prototype.textContent</h4> <p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;

document.getElementById('divA').textContent
// This is some text
</code></pre></div><p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p> <p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p> <div class="language- extra-class"><pre class="language-text"><code>document.getElementById('foo').textContent = '&lt;p&gt;GoodBye!&lt;/p&gt;';
</code></pre></div><p>上面代码在插入文本时，会将<code>&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p> <p>对于文本节点（text）、注释节点（comment）和属性节点（attr），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点（不包括注释节点）的内容连接在一起返回。如果一个节点没有子节点，则返回空字符串。</p> <p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p> <h4 id="node-prototype-baseuri"><a href="#node-prototype-baseuri" class="header-anchor">#</a> Node.prototype.baseURI</h4> <p><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p> <div class="language- extra-class"><pre class="language-text"><code>// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// &quot;http://www.example.com/index.html&quot;
</code></pre></div><p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p> <p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;base href=&quot;http://www.example.com/page.html&quot;&gt;
</code></pre></div><p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p> <h4 id="node-prototype-ownerdocument"><a href="#node-prototype-ownerdocument" class="header-anchor">#</a> Node.prototype.ownerDocument</h4> <p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var d = p.ownerDocument;
d === document // true
</code></pre></div><p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p> <h4 id="node-prototype-nextsibling"><a href="#node-prototype-nextsibling" class="header-anchor">#</a> Node.prototype.nextSibling</h4> <p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');

d1.nextSibling === d2 // true
</code></pre></div><p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p> <p>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p> <p><code>nextSibling</code>属性可以用来遍历所有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.getElementById('div1').firstChild;

while (el !== null) {
  console.log(el.nodeName);
  el = el.nextSibling;
}
</code></pre></div><p>上面代码遍历<code>div1</code>节点的所有子节点。</p> <h4 id="node-prototype-previoussibling"><a href="#node-prototype-previoussibling" class="header-anchor">#</a> Node.prototype.previousSibling</h4> <p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;
var d1 = document.getElementById('d1');
var d2 = document.getElementById('d2');

d2.previousSibling === d1 // true
</code></pre></div><p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p> <p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p> <h4 id="node-prototype-parentnode"><a href="#node-prototype-parentnode" class="header-anchor">#</a> Node.prototype.parentNode</h4> <p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p> <div class="language- extra-class"><pre class="language-text"><code>if (node.parentNode) {
  node.parentNode.removeChild(node);
}
</code></pre></div><p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p> <p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p> <h4 id="node-prototype-parentelement"><a href="#node-prototype-parentelement" class="header-anchor">#</a> Node.prototype.parentElement</h4> <p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if (node.parentElement) {
  node.parentElement.style.color = 'red';
}
</code></pre></div><p>上面代码中，父元素节点的样式设定了红色。</p> <p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p> <h4 id="node-prototype-firstchild-node-prototype-lastchild"><a href="#node-prototype-firstchild-node-prototype-lastchild" class="header-anchor">#</a> Node.prototype.firstChild，Node.prototype.lastChild</h4> <p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;p id=&quot;p1&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;
var p1 = document.getElementById('p1');
p1.firstChild.nodeName // &quot;SPAN&quot;
</code></pre></div><p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p> <p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;p id=&quot;p1&quot;&gt;
//   &lt;span&gt;First span&lt;/span&gt;
//  &lt;/p&gt;
var p1 = document.getElementById('p1');
p1.firstChild.nodeName // &quot;#text&quot;
</code></pre></div><p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p> <p><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p> <h4 id="node-prototype-childnodes"><a href="#node-prototype-childnodes" class="header-anchor">#</a> Node.prototype.childNodes</h4> <p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.querySelector('ul').childNodes;
</code></pre></div><p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p> <p>使用该属性，可以遍历某个节点的所有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.getElementById('div1');
var children = div.childNodes;

for (var i = 0; i &lt; children.length; i++) {
  // ...
}
</code></pre></div><p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.childNodes;
for (var i = 0; i &lt; children.length; i++) {
  console.log(children[i].nodeType);
}
// 10
// 1
</code></pre></div><p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p> <p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p> <h4 id="node-prototype-isconnected"><a href="#node-prototype-isconnected" class="header-anchor">#</a> Node.prototype.isConnected</h4> <p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p> <div class="language- extra-class"><pre class="language-text"><code>var test = document.createElement('p');
test.isConnected // false

document.body.appendChild(test);
test.isConnected // true
</code></pre></div><p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <h4 id="node-prototype-appendchild"><a href="#node-prototype-appendchild" class="header-anchor">#</a> Node.prototype.appendChild()</h4> <p><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.createElement('p');
document.body.appendChild(p);
</code></pre></div><p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p> <p>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到新位置。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.getElementById('myDiv');
document.body.appendChild(div);
</code></pre></div><p>上面代码中，插入的是一个已经存在的节点<code>myDiv</code>，结果就是该节点会从原来的位置，移动到<code>document.body</code>的尾部。</p> <p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p> <h4 id="node-prototype-haschildnodes"><a href="#node-prototype-haschildnodes" class="header-anchor">#</a> Node.prototype.hasChildNodes()</h4> <p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = document.getElementById('foo');

if (foo.hasChildNodes()) {
  foo.removeChild(foo.childNodes[0]);
}
</code></pre></div><p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p> <p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p> <p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p> <ul><li><code>node.hasChildNodes()</code></li> <li><code>node.firstChild !== null</code></li> <li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li></ul> <p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p> <div class="language- extra-class"><pre class="language-text"><code>function DOMComb(parent, callback) {
  if (parent.hasChildNodes()) {
    for (var node = parent.firstChild; node; node = node.nextSibling) {
      DOMComb(node, callback);
    }
  }
  callback(parent);
}

// 用法
DOMComb(document.body, console.log)
</code></pre></div><p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p> <h4 id="node-prototype-clonenode"><a href="#node-prototype-clonenode" class="header-anchor">#</a> Node.prototype.cloneNode()</h4> <p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var cloneUL = document.querySelector('ul').cloneNode(true);
</code></pre></div><p>该方法有一些使用注意点。</p> <p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p> <p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p> <p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p> <h4 id="node-prototype-insertbefore"><a href="#node-prototype-insertbefore" class="header-anchor">#</a> Node.prototype.insertBefore()</h4> <p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p> <div class="language- extra-class"><pre class="language-text"><code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);
</code></pre></div><p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.createElement('p');
document.body.insertBefore(p, document.body.firstChild);
</code></pre></div><p>上面代码中，新建一个<code>&lt;p&gt;</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p> <p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.createElement('p');
document.body.insertBefore(p, null);
</code></pre></div><p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p> <p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p> <p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p> <div class="language- extra-class"><pre class="language-text"><code>parent.insertBefore(s1, s2.nextSibling);
</code></pre></div><p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p> <p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p> <h4 id="node-prototype-removechild"><a href="#node-prototype-removechild" class="header-anchor">#</a> Node.prototype.removeChild()</h4> <p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var divA = document.getElementById('A');
divA.parentNode.removeChild(divA);
</code></pre></div><p>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</p> <p>下面是如何移除当前节点的所有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var element = document.getElementById('top');
while (element.firstChild) {
  element.removeChild(element.firstChild);
}
</code></pre></div><p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p> <p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p> <h4 id="node-prototype-replacechild"><a href="#node-prototype-replacechild" class="header-anchor">#</a> Node.prototype.replaceChild()</h4> <p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var replacedNode = parentNode.replaceChild(newChild, oldChild);
</code></pre></div><p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var divA = document.getElementById('divA');
var newSpan = document.createElement('span');
newSpan.textContent = 'Hello World!';
divA.parentNode.replaceChild(newSpan, divA);
</code></pre></div><p>上面代码是如何将指定节点<code>divA</code>替换走。</p> <h4 id="node-prototype-contains"><a href="#node-prototype-contains" class="header-anchor">#</a> Node.prototype.contains()</h4> <p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p> <ul><li>参数节点为当前节点。</li> <li>参数节点为当前节点的子节点。</li> <li>参数节点为当前节点的后代节点。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>document.body.contains(node)
</code></pre></div><p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p> <p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>nodeA.contains(nodeA) // true
</code></pre></div><h4 id="node-prototype-comparedocumentposition"><a href="#node-prototype-comparedocumentposition" class="header-anchor">#</a> Node.prototype.compareDocumentPosition()</h4> <p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</p> <table><thead><tr><th>二进制值</th> <th>十进制值</th> <th>含义</th></tr></thead> <tbody><tr><td>000000</td> <td>0</td> <td>两个节点相同</td></tr> <tr><td>000001</td> <td>1</td> <td>两个节点不在同一个文档（即有一个节点不在当前文档）</td></tr> <tr><td>000010</td> <td>2</td> <td>参数节点在当前节点的前面</td></tr> <tr><td>000100</td> <td>4</td> <td>参数节点在当前节点的后面</td></tr> <tr><td>001000</td> <td>8</td> <td>参数节点包含当前节点</td></tr> <tr><td>010000</td> <td>16</td> <td>当前节点包含参数节点</td></tr> <tr><td>100000</td> <td>32</td> <td>浏览器内部使用</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;mydiv&quot;&gt;
//   &lt;form&gt;&lt;input id=&quot;test&quot; /&gt;&lt;/form&gt;
// &lt;/div&gt;

var div = document.getElementById('mydiv');
var input = document.getElementById('test');

div.compareDocumentPosition(input) // 20
input.compareDocumentPosition(div) // 10
</code></pre></div><p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p> <p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p> <div class="language- extra-class"><pre class="language-text"><code>var head = document.head;
var body = document.body;
if (head.compareDocumentPosition(body) &amp; 4) {
  console.log('文档结构正确');
} else {
  console.log('&lt;body&gt; 不能在 &lt;head&gt; 前面');
}
</code></pre></div><p>上面代码中，<code>compareDocumentPosition</code>的返回值与<code>4</code>（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>&lt;head&gt;</code>是否在<code>&lt;body&gt;</code>前面。</p> <h4 id="node-prototype-isequalnode-node-prototype-issamenode"><a href="#node-prototype-isequalnode-node-prototype-issamenode" class="header-anchor">#</a> Node.prototype.isEqualNode()，Node.prototype.isSameNode()</h4> <p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p> <div class="language- extra-class"><pre class="language-text"><code>var p1 = document.createElement('p');
var p2 = document.createElement('p');

p1.isEqualNode(p2) // true
</code></pre></div><p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var p1 = document.createElement('p');
var p2 = document.createElement('p');

p1.isSameNode(p2) // false
p1.isSameNode(p1) // true
</code></pre></div><h4 id="node-prototype-normalize"><a href="#node-prototype-normalize" class="header-anchor">#</a> Node.prototype.normalize()</h4> <p><code>normalize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var wrapper = document.createElement('div');

wrapper.appendChild(document.createTextNode('Part 1 '));
wrapper.appendChild(document.createTextNode('Part 2 '));

wrapper.childNodes.length // 2
wrapper.normalize();
wrapper.childNodes.length // 1
</code></pre></div><p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p> <p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p> <h4 id="node-prototype-getrootnode"><a href="#node-prototype-getrootnode" class="header-anchor">#</a> Node.prototype.getRootNode()</h4> <p><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.firstChild.getRootNode() === document
// true
document.body.firstChild.getRootNode() === document.body.firstChild.ownerDocument
// true
</code></pre></div><p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p> <div class="language- extra-class"><pre class="language-text"><code>document.getRootNode() // document
document.ownerDocument // null
</code></pre></div><h2 id="nodelist-接口-htmlcollection接口"><a href="#nodelist-接口-htmlcollection接口" class="header-anchor">#</a> NodeList 接口，HTMLCollection接口</h2> <p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</p> <p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。主要区别是，<code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点。</p> <h3 id="nodelist-接口"><a href="#nodelist-接口" class="header-anchor">#</a> NodeList 接口</h3> <h4 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h4> <p><code>NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到<code>NodeList</code>实例。</p> <ul><li><code>Node.childNodes</code></li> <li><code>document.querySelectorAll()</code>等节点搜索方法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>document.body.childNodes instanceof NodeList // true
</code></pre></div><p><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;

Array.isArray(children) // false

children.length // 34
children.forEach(console.log)
</code></pre></div><p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p> <p>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;
var nodeArr = Array.prototype.slice.call(children);
</code></pre></div><p>除了使用<code>forEach</code>方法遍历 NodeList 实例，还可以使用<code>for</code>循环。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;

for (var i = 0; i &lt; children.length; i++) {
  var item = children[i];
}
</code></pre></div><p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;
children.length // 18
document.body.appendChild(document.createElement('p'));
children.length // 19
</code></pre></div><p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p> <h4 id="nodelist-prototype-length"><a href="#nodelist-prototype-length" class="header-anchor">#</a> NodeList.prototype.length</h4> <p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p> <div class="language- extra-class"><pre class="language-text"><code>document.querySelectorAll('xxx').length
// 0
</code></pre></div><p>上面代码中，<code>document.querySelectorAll</code>返回一个 NodeList 集合。对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</p> <h4 id="nodelist-prototype-foreach"><a href="#nodelist-prototype-foreach" class="header-anchor">#</a> NodeList.prototype.forEach()</h4> <p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;
children.forEach(function f(item, i, list) {
  // ...
}, this);
</code></pre></div><p>上面代码中，回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p> <h4 id="nodelist-prototype-item"><a href="#nodelist-prototype-item" class="header-anchor">#</a> NodeList.prototype.item()</h4> <p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.childNodes.item(0)
</code></pre></div><p>上面代码中，<code>item(0)</code>返回第一个成员。</p> <p>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</p> <p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.childNodes[0]
</code></pre></div><h4 id="nodelist-prototype-keys-nodelist-prototype-values-nodelist-prototype-entries"><a href="#nodelist-prototype-keys-nodelist-prototype-values-nodelist-prototype-entries" class="header-anchor">#</a> NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h4> <p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</p> <div class="language- extra-class"><pre class="language-text"><code>var children = document.body.childNodes;

for (var key of children.keys()) {
  console.log(key);
}
// 0
// 1
// 2
// ...

for (var value of children.values()) {
  console.log(value);
}
// #text
// &lt;script&gt;
// ...

for (var entry of children.entries()) {
  console.log(entry);
}
// Array [ 0, #text ]
// Array [ 1, &lt;script&gt; ]
// ...
</code></pre></div><h3 id="htmlcollection-接口"><a href="#htmlcollection-接口" class="header-anchor">#</a> HTMLCollection 接口</h3> <h4 id="概述-3"><a href="#概述-3" class="header-anchor">#</a> 概述</h4> <p><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</p> <p>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</p> <div class="language- extra-class"><pre class="language-text"><code>document.links instanceof HTMLCollection // true
</code></pre></div><p><code>HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</p> <p>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;

var pic = document.getElementById('pic');
document.images.pic === pic // true
</code></pre></div><p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code>&lt;img&gt;</code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p> <h4 id="htmlcollection-prototype-length"><a href="#htmlcollection-prototype-length" class="header-anchor">#</a> HTMLCollection.prototype.length</h4> <p><code>length</code>属性返回<code>HTMLCollection</code>实例包含的成员数量。</p> <div class="language- extra-class"><pre class="language-text"><code>document.links.length // 18
</code></pre></div><h4 id="htmlcollection-prototype-item"><a href="#htmlcollection-prototype-item" class="header-anchor">#</a> HTMLCollection.prototype.item()</h4> <p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p> <div class="language- extra-class"><pre class="language-text"><code>var c = document.images;
var img0 = c.item(0);
</code></pre></div><p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p> <p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p> <h4 id="htmlcollection-prototype-nameditem"><a href="#htmlcollection-prototype-nameditem" class="header-anchor">#</a> HTMLCollection.prototype.namedItem()</h4> <p><code>namedItem</code>方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回当前集合中对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;

var pic = document.getElementById('pic');
document.images.namedItem('pic') === pic // true
</code></pre></div><p><code>Collection.namedItem('value')</code>等同于<code>Collection['value']</code>。</p> <h2 id="parentnode-接口-childnode-接口"><a href="#parentnode-接口-childnode-接口" class="header-anchor">#</a> ParentNode 接口，ChildNode 接口</h2> <p>节点对象除了继承 Node 接口以外，还拥有其他接口。<code>ParentNode</code>接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code>ChildNode</code>接口表示当前节点是一个子节点，提供一些相关方法。</p> <h3 id="parentnode-接口"><a href="#parentnode-接口" class="header-anchor">#</a> ParentNode 接口</h3> <p>如果当前节点是父节点，就会混入了（mixin）<code>ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会拥有<code>ParentNode</code>接口。</p> <h4 id="parentnode-children"><a href="#parentnode-children" class="header-anchor">#</a> ParentNode.children</h4> <p><code>children</code>属性返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</p> <p>下面是遍历某个节点的所有元素子节点的示例。</p> <div class="language- extra-class"><pre class="language-text"><code>for (var i = 0; i &lt; el.children.length; i++) {
  // ...
}
</code></pre></div><p>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p> <p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p> <h4 id="parentnode-firstelementchild"><a href="#parentnode-firstelementchild" class="header-anchor">#</a> ParentNode.firstElementChild</h4> <p><code>firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.firstElementChild.nodeName
// &quot;HTML&quot;
</code></pre></div><p>上面代码中，<code>document</code>节点的第一个元素子节点是<code>&lt;HTML&gt;</code>。</p> <h4 id="parentnode-lastelementchild"><a href="#parentnode-lastelementchild" class="header-anchor">#</a> ParentNode.lastElementChild</h4> <p><code>lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.lastElementChild.nodeName
// &quot;HTML&quot;
</code></pre></div><p>上面代码中，<code>document</code>节点的最后一个元素子节点是<code>&lt;HTML&gt;</code>（因为<code>document</code>只包含这一个元素子节点）。</p> <h4 id="parentnode-childelementcount"><a href="#parentnode-childelementcount" class="header-anchor">#</a> ParentNode.childElementCount</h4> <p><code>childElementCount</code>属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code>0</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.childElementCount // 13
</code></pre></div><h4 id="parentnode-append-parentnode-prepend"><a href="#parentnode-append-parentnode-prepend" class="header-anchor">#</a> ParentNode.append()，ParentNode.prepend()</h4> <p><strong>（1）ParentNode.append()</strong></p> <p><code>append()</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p> <p>该方法不仅可以添加元素子节点（参数为元素节点），还可以添加文本子节点（参数为字符串）。</p> <div class="language- extra-class"><pre class="language-text"><code>var parent = document.body;

// 添加元素子节点
var p = document.createElement('p');
parent.append(p);

// 添加文本子节点
parent.append('Hello');

// 添加多个元素子节点
var p1 = document.createElement('p');
var p2 = document.createElement('p');
parent.append(p1, p2);

// 添加元素子节点和文本子节点
var p = document.createElement('p');
parent.append('Hello', p);
</code></pre></div><p>该方法没有返回值。</p> <p>注意，该方法与<code>Node.prototype.appendChild()</code>方法有三点不同。</p> <ul><li><code>append()</code>允许字符串作为参数，<code>appendChild()</code>只允许子节点作为参数。</li> <li><code>append()</code>没有返回值，而<code>appendChild()</code>返回添加的子节点。</li> <li><code>append()</code>可以添加多个子节点和字符串（即允许多个参数），<code>appendChild()</code>只能添加一个节点（即只允许一个参数）。</li></ul> <p><strong>（2）ParentNode.prepend()</strong></p> <p><code>prepend()</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code>append()</code>方法完全一致，也是没有返回值。</p> <h3 id="childnode-接口"><a href="#childnode-接口" class="header-anchor">#</a> ChildNode 接口</h3> <p>如果一个节点有父节点，那么该节点就拥有了<code>ChildNode</code>接口。</p> <h4 id="childnode-remove"><a href="#childnode-remove" class="header-anchor">#</a> ChildNode.remove()</h4> <p><code>remove()</code>方法用于从父节点移除当前节点。</p> <div class="language- extra-class"><pre class="language-text"><code>el.remove()
</code></pre></div><p>上面代码在 DOM 里面移除了<code>el</code>节点。</p> <h4 id="childnode-before-childnode-after"><a href="#childnode-before-childnode-after" class="header-anchor">#</a> ChildNode.before()，ChildNode.after()</h4> <p><strong>（1）ChildNode.before()</strong></p> <p><code>before()</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p> <p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.createElement('p');
var p1 = document.createElement('p');

// 插入元素节点
el.before(p);

// 插入文本节点
el.before('Hello');

// 插入多个元素节点
el.before(p, p1);

// 插入元素节点和文本节点
el.before(p, 'Hello');
</code></pre></div><p><strong>（2）ChildNode.after()</strong></p> <p><code>after()</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</p> <h4 id="childnode-replacewith"><a href="#childnode-replacewith" class="header-anchor">#</a> ChildNode.replaceWith()</h4> <p><code>replaceWith()</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var span = document.createElement('span');
el.replaceWith(span);
</code></pre></div><p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p> <h2 id="document-节点"><a href="#document-节点" class="header-anchor">#</a> Document 节点</h2> <h3 id="概述-4"><a href="#概述-4" class="header-anchor">#</a> 概述</h3> <p><code>document</code>节点对象代表整个文档，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p> <p><code>document</code>对象有不同的办法可以获取。</p> <ul><li>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</li> <li><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性。</li> <li>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</li> <li>内部节点的<code>ownerDocument</code>属性。</li></ul> <p><code>document</code>对象继承了<code>EventTarget</code>接口和<code>Node</code>接口，并且混入（mixin）了<code>ParentNode</code>接口。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p> <h3 id="属性-2"><a href="#属性-2" class="header-anchor">#</a> 属性</h3> <h4 id="快捷方式属性"><a href="#快捷方式属性" class="header-anchor">#</a> 快捷方式属性</h4> <p>以下属性是指向文档内部的某个节点的快捷方式。</p> <p><strong>（1）document.defaultView</strong></p> <p><code>document.defaultView</code>属性返回<code>document</code>对象所属的<code>window</code>对象。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.defaultView === window // true
</code></pre></div><p><strong>（2）document.doctype</strong></p> <p>对于 HTML 文档来说，<code>document</code>对象一般有两个子节点。第一个子节点是<code>document.doctype</code>，指向<code>&lt;DOCTYPE&gt;</code>节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成<code>&lt;!DOCTYPE html&gt;</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var doctype = document.doctype;
doctype // &quot;&lt;!DOCTYPE html&gt;&quot;
doctype.name // &quot;html&quot;
</code></pre></div><p><code>document.firstChild</code>通常就返回这个节点。</p> <p><strong>（3）document.documentElement</strong></p> <p><code>document.documentElement</code>属性返回当前文档的根元素节点（root）。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是<code>&lt;html&gt;</code>节点。</p> <p><strong>（4）document.body，document.head</strong></p> <p><code>document.body</code>属性指向<code>&lt;body&gt;</code>节点，<code>document.head</code>属性指向<code>&lt;head&gt;</code>节点。</p> <p>这两个属性总是存在的，如果网页源码里面省略了<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p> <p><strong>（5）document.scrollingElement</strong></p> <p><code>document.scrollingElement</code>属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p> <p>标准模式下，这个属性返回的文档的根元素<code>document.documentElement</code>（即<code>&lt;html&gt;</code>）。兼容（quirk）模式下，返回的是<code>&lt;body&gt;</code>元素，如果该元素不存在，返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// 页面滚动到浏览器顶部
document.scrollingElement.scrollTop = 0;
</code></pre></div><p><strong>（6）document.activeElement</strong></p> <p><code>document.activeElement</code>属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素，如果当前没有焦点元素，返回<code>&lt;body&gt;</code>元素或<code>null</code>。</p> <p><strong>（7）document.fullscreenElement</strong></p> <p><code>document.fullscreenElement</code>属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if (document.fullscreenElement.nodeName == 'VIDEO') {
  console.log('全屏播放视频');
}
</code></pre></div><p>上面代码中，通过<code>document.fullscreenElement</code>可以知道<code>&lt;video&gt;</code>元素有没有处在全屏状态，从而判断用户行为。</p> <h4 id="节点集合属性"><a href="#节点集合属性" class="header-anchor">#</a> 节点集合属性</h4> <p>以下属性返回一个<code>HTMLCollection</code>实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p> <p><strong>（1）document.links</strong></p> <p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>&lt;a&gt;</code>及<code>&lt;area&gt;</code>节点。</p> <div class="language- extra-class"><pre class="language-text"><code>// 打印文档所有的链接
var links = document.links;
for(var i = 0; i &lt; links.length; i++) {
  console.log(links[i]);
}
</code></pre></div><p><strong>（2）document.forms</strong></p> <p><code>document.forms</code>属性返回所有<code>&lt;form&gt;</code>表单节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var selectForm = document.forms[0];
</code></pre></div><p>上面代码获取文档第一个表单。</p> <p>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p> <div class="language- extra-class"><pre class="language-text"><code>/* HTML 代码如下
  &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;
*/
document.forms[0] === document.forms.foo // true
document.forms.bar === document.forms.foo // true
</code></pre></div><p><strong>（3）document.images</strong></p> <p><code>document.images</code>属性返回页面所有<code>&lt;img&gt;</code>图片节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var imglist = document.images;

for(var i = 0; i &lt; imglist.length; i++) {
  if (imglist[i].src === 'banner.gif') {
    // ...
  }
}
</code></pre></div><p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p> <p><strong>（4）document.embeds，document.plugins</strong></p> <p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都返回所有<code>&lt;embed&gt;</code>节点。</p> <p><strong>（5）document.scripts</strong></p> <p><code>document.scripts</code>属性返回所有<code>&lt;script&gt;</code>节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var scripts = document.scripts;
if (scripts.length !== 0 ) {
  console.log('当前网页有脚本');
}
</code></pre></div><p><strong>（6）document.styleSheets</strong></p> <p><code>document.styleSheets</code>属性返回网页内嵌或引入的 CSS 样式表集合，详细介绍请看《CSS 操作》一章。</p> <p><strong>（7）小结</strong></p> <p>除了<code>document.styleSheets</code>属性，以上的其他集合属性返回的都是<code>HTMLCollection</code>实例。<code>document.styleSheets</code>属性返回的是<code>StyleSheetList</code>实例。</p> <div class="language- extra-class"><pre class="language-text"><code>document.links instanceof HTMLCollection // true
document.images instanceof HTMLCollection // true
document.forms instanceof HTMLCollection // true
document.embeds instanceof HTMLCollection // true
document.scripts instanceof HTMLCollection // true
</code></pre></div><p><code>HTMLCollection</code>实例是类似数组的对象，所以上面这些属性都有<code>length</code>属性，都可以使用方括号运算符引用成员。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;form name=&quot;myForm&quot;&gt;
document.myForm === document.forms.myForm // true
</code></pre></div><h4 id="文档静态信息属性"><a href="#文档静态信息属性" class="header-anchor">#</a> 文档静态信息属性</h4> <p>以下属性返回文档信息。</p> <p><strong>（1）document.documentURI，document.URL</strong></p> <p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；<code>URL</code>继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p> <div class="language- extra-class"><pre class="language-text"><code>document.URL
// http://www.example.com/about

document.documentURI === document.URL
// true
</code></pre></div><p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p> <p><strong>（2）document.domain</strong></p> <p><code>document.domain</code>属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p> <p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p> <p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p> <p><strong>（3）document.location</strong></p> <p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p> <p>关于这个对象的详细介绍，请看《浏览器模型》部分的《Location 对象》章节。</p> <p><strong>（4）document.lastModified</strong></p> <p><code>document.lastModified</code>属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p> <div class="language- extra-class"><pre class="language-text"><code>document.lastModified
// &quot;03/07/2018 11:18:27&quot;
</code></pre></div><p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p> <div class="language- extra-class"><pre class="language-text"><code>var lastVisitedDate = Date.parse('01/01/2018');
if (Date.parse(document.lastModified) &gt; lastVisitedDate) {
  console.log('网页已经变更');
}
</code></pre></div><p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p> <p><strong>（5）document.title</strong></p> <p><code>document.title</code>属性返回当前文档的标题。默认情况下，返回<code>&lt;title&gt;</code>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p> <div class="language- extra-class"><pre class="language-text"><code>document.title = '新标题';
document.title // &quot;新标题&quot;
</code></pre></div><p><strong>（6）document.characterSet</strong></p> <p><code>document.characterSet</code>属性返回当前文档的编码，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p> <p><strong>（7）document.referrer</strong></p> <p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问者来自哪里。</p> <div class="language- extra-class"><pre class="language-text"><code>document.referrer
// &quot;https://example.com/path&quot;
</code></pre></div><p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p> <p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p> <p><strong>（8）document.dir</strong></p> <p><code>document.dir</code>返回一个字符串，表示文字方向。它只有两个可能的值：<code>rtl</code>表示文字从右到左，阿拉伯文是这种方式；<code>ltr</code>表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p> <p><strong>（9）document.compatMode</strong></p> <p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p> <p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如<code>&lt;!doctype html&gt;</code>），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p> <h4 id="文档状态属性"><a href="#文档状态属性" class="header-anchor">#</a> 文档状态属性</h4> <p><strong>（1）document.hidden</strong></p> <p><code>document.hidden</code>属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</p> <p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p> <p><strong>（2）document.visibilityState</strong></p> <p><code>document.visibilityState</code>返回文档的可见状态。</p> <p>它的值有四种可能。</p> <blockquote><ul><li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li> <li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li> <li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li> <li><code>unloaded</code>：页面从内存里面卸载了。</li></ul></blockquote> <p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p> <p><strong>（3）document.readyState</strong></p> <p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值。</p> <ul><li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li> <li><code>interactive</code>：加载外部资源阶段</li> <li><code>complete</code>：加载完成</li></ul> <p>这个属性变化的过程如下。</p> <ol><li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li> <li>浏览器遇到 HTML 文档中的<code>&lt;script&gt;</code>元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li> <li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li> <li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li></ol> <p>下面的代码用来检查网页是否加载成功。</p> <div class="language- extra-class"><pre class="language-text"><code>// 基本检查
if (document.readyState === 'complete') {
  // ...
}

// 轮询检查
var interval = setInterval(function() {
  if (document.readyState === 'complete') {
    clearInterval(interval);
    // ...
  }
}, 100);
</code></pre></div><p>另外，每次状态变化都会触发一个<code>readystatechange</code>事件。</p> <h4 id="document-cookie"><a href="#document-cookie" class="header-anchor">#</a> document.cookie</h4> <p><code>document.cookie</code>属性用来操作浏览器 Cookie，详见《浏览器模型》部分的《Cookie》章节。</p> <h4 id="document-designmode"><a href="#document-designmode" class="header-anchor">#</a> document.designMode</h4> <p><code>document.designMode</code>属性控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p> <p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;
var editor = document.getElementById('editor');
editor.contentDocument.designMode = 'on';
</code></pre></div><h4 id="document-currentscript"><a href="#document-currentscript" class="header-anchor">#</a> document.currentScript</h4> <p><code>document.currentScript</code>属性只用在<code>&lt;script&gt;</code>元素的内嵌脚本或加载的外部脚本之中，返回当前脚本所在的那个 DOM 节点，即<code>&lt;script&gt;</code>元素的 DOM 节点。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script id=&quot;foo&quot;&gt;
  console.log(
    document.currentScript === document.getElementById('foo')
  ); // true
&lt;/script&gt;
</code></pre></div><p>上面代码中，<code>document.currentScript</code>就是<code>&lt;script&gt;</code>元素节点。</p> <h4 id="document-implementation"><a href="#document-implementation" class="header-anchor">#</a> document.implementation</h4> <p><code>document.implementation</code>属性返回一个<code>DOMImplementation</code>对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p> <ul><li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li> <li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li> <li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li></ul> <p>下面是创建 HTML 文档的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var doc = document.implementation.createHTMLDocument('Title');
var p = doc.createElement('p');
p.innerHTML = 'hello world';
doc.body.appendChild(p);

document.replaceChild(
  doc.documentElement,
  document.documentElement
);
</code></pre></div><p>上面代码中，第一步生成一个新的 HTML 文档<code>doc</code>，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p> <h3 id="方法-2"><a href="#方法-2" class="header-anchor">#</a> 方法</h3> <h4 id="document-open-document-close"><a href="#document-open-document-close" class="header-anchor">#</a> document.open()，document.close()</h4> <p><code>document.open</code>方法清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容。</p> <p><code>document.close</code>方法用来关闭<code>document.open()</code>打开的文档。</p> <div class="language- extra-class"><pre class="language-text"><code>document.open();
document.write('hello world');
document.close();
</code></pre></div><h4 id="document-write-document-writeln"><a href="#document-write-document-writeln" class="header-anchor">#</a> document.write()，document.writeln()</h4> <p><code>document.write</code>方法用于向当前文档写入内容。</p> <p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p> <div class="language- extra-class"><pre class="language-text"><code>// 页面显示“helloworld”
document.open();
document.write('hello');
document.write('world');
document.close();
</code></pre></div><p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p> <div class="language- extra-class"><pre class="language-text"><code>document.write('&lt;p&gt;hello world&lt;/p&gt;');
</code></pre></div><p>上面代码中，<code>document.write</code>会将<code>&lt;p&gt;</code>当作 HTML 标签解释。</p> <p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('DOMContentLoaded', function (event) {
  document.write('&lt;p&gt;Hello World!&lt;/p&gt;');
});

// 等同于
document.addEventListener('DOMContentLoaded', function (event) {
  document.open();
  document.write('&lt;p&gt;Hello World!&lt;/p&gt;');
  document.close();
});
</code></pre></div><p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
&lt;body&gt;
hello
&lt;script type=&quot;text/javascript&quot;&gt;
  document.write(&quot;world&quot;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p> <p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，除了某些特殊情况，应该尽量避免使用<code>document.write</code>这个方法。</p> <p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p> <div class="language- extra-class"><pre class="language-text"><code>document.write(1);
document.write(2);
// 12

document.writeln(1);
document.writeln(2);
// 1
// 2
//
</code></pre></div><p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code>&lt;br&gt;</code>。</p> <h4 id="document-queryselector-document-queryselectorall"><a href="#document-queryselector-document-queryselectorall" class="header-anchor">#</a> document.querySelector()，document.querySelectorAll()</h4> <p><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var el1 = document.querySelector('.myclass');
var el2 = document.querySelector('#myParent &gt; [ng-click]');
</code></pre></div><p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点。</p> <div class="language- extra-class"><pre class="language-text"><code>elementList = document.querySelectorAll('.myclass');
</code></pre></div><p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p> <div class="language- extra-class"><pre class="language-text"><code>var matches = document.querySelectorAll('div.note, div.alert');
</code></pre></div><p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p> <p>这两个方法都支持复杂的 CSS 选择器。</p> <div class="language- extra-class"><pre class="language-text"><code>// 选中 data-foo-bar 属性等于 someval 的元素
document.querySelectorAll('[data-foo-bar=&quot;someval&quot;]');

// 选中 myForm 表单中所有不通过验证的元素
document.querySelectorAll('#myForm :invalid');

// 选中div元素，那些 class 含 ignore 的除外
document.querySelectorAll('DIV:not(.ignore)');

// 同时选中 div，a，script 三类元素
document.querySelectorAll('DIV, A, SCRIPT');
</code></pre></div><p>但是，它们不支持 CSS 伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p> <p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p> <p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用。</p> <h4 id="document-getelementsbytagname"><a href="#document-getelementsbytagname" class="header-anchor">#</a> document.getElementsByTagName()</h4> <p><code>document.getElementsByTagName()</code>方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code>HTMLCollection</code>实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p> <div class="language- extra-class"><pre class="language-text"><code>var paras = document.getElementsByTagName('p');
paras instanceof HTMLCollection // true
</code></pre></div><p>上面代码返回当前文档的所有<code>p</code>元素节点。</p> <p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName()</code>方法的参数也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p> <p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p> <div class="language- extra-class"><pre class="language-text"><code>var allElements = document.getElementsByTagName('*');
</code></pre></div><p>注意，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p> <div class="language- extra-class"><pre class="language-text"><code>var firstPara = document.getElementsByTagName('p')[0];
var spans = firstPara.getElementsByTagName('span');
</code></pre></div><p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p> <h4 id="document-getelementsbyclassname"><a href="#document-getelementsbyclassname" class="header-anchor">#</a> document.getElementsByClassName()</h4> <p><code>document.getElementsByClassName()</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p> <div class="language- extra-class"><pre class="language-text"><code>var elements = document.getElementsByClassName(names);
</code></pre></div><p>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。</p> <p>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p> <div class="language- extra-class"><pre class="language-text"><code>var elements = document.getElementsByClassName('foo bar');
</code></pre></div><p>上面代码返回同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素，<code>foo</code>和<code>bar</code>的顺序不重要。</p> <p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p> <p>与<code>getElementsByTagName()</code>方法一样，<code>getElementsByClassName()</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p> <div class="language- extra-class"><pre class="language-text"><code>// 非document对象上调用
var elements = rootElement.getElementsByClassName(names);
</code></pre></div><h4 id="document-getelementsbyname"><a href="#document-getelementsbyname" class="header-anchor">#</a> document.getElementsByName()</h4> <p><code>document.getElementsByName()</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（<code>NodeList</code>实例），因为<code>name</code>属性相同的元素可能不止一个。</p> <div class="language- extra-class"><pre class="language-text"><code>// 表单为 &lt;form name=&quot;x&quot;&gt;&lt;/form&gt;
var forms = document.getElementsByName('x');
forms[0].tagName // &quot;FORM&quot;
</code></pre></div><h4 id="document-getelementbyid"><a href="#document-getelementbyid" class="header-anchor">#</a> document.getElementById()</h4> <p><code>document.getElementById()</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var elem = document.getElementById('para1');
</code></pre></div><p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById('Main')</code>将返回<code>null</code>。</p> <p><code>document.getElementById()</code>方法与<code>document.querySelector()</code>方法都能获取元素节点，不同之处是<code>document.querySelector()</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById()</code>方法的参数是元素的<code>id</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>document.getElementById('myElement')
document.querySelector('#myElement')
</code></pre></div><p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p> <p>另外，这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用。</p> <h4 id="document-elementfrompoint-document-elementsfrompoint"><a href="#document-elementfrompoint-document-elementsfrompoint" class="header-anchor">#</a> document.elementFromPoint()，document.elementsFromPoint()</h4> <p><code>document.elementFromPoint()</code>方法返回位于页面指定位置最上层的元素节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var element = document.elementFromPoint(50, 50);
</code></pre></div><p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p> <p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p> <p><code>document.elementsFromPoint()</code>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p> <div class="language- extra-class"><pre class="language-text"><code>var elements = document.elementsFromPoint(x, y);
</code></pre></div><h4 id="document-createelement"><a href="#document-createelement" class="header-anchor">#</a> document.createElement()</h4> <p><code>document.createElement</code>方法用来生成元素节点，并返回该节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var newDiv = document.createElement('div');
</code></pre></div><p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>document.createElement('&lt;div&gt;');
// DOMException: The tag name provided ('&lt;div&gt;') is not a valid name
</code></pre></div><p>注意，<code>document.createElement</code>的参数可以是自定义的标签名。</p> <div class="language- extra-class"><pre class="language-text"><code>document.createElement('foo');
</code></pre></div><h4 id="document-createtextnode"><a href="#document-createtextnode" class="header-anchor">#</a> document.createTextNode()</h4> <p><code>document.createTextNode</code>方法用来生成文本节点（<code>Text</code>实例），并返回该节点。它的参数是文本节点的内容。</p> <div class="language- extra-class"><pre class="language-text"><code>var newDiv = document.createElement('div');
var newContent = document.createTextNode('Hello');
newDiv.appendChild(newContent);
</code></pre></div><p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p> <p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.createElement('div');
div.appendChild(document.createTextNode('&lt;span&gt;Foo &amp; bar&lt;/span&gt;'));
console.log(div.innerHTML)
// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;
</code></pre></div><p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p> <p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>function escapeHtml(str) {
  var div = document.createElement('div');
  div.appendChild(document.createTextNode(str));
  return div.innerHTML;
};

var userWebsite = '&quot; onmouseover=&quot;alert(\'derp\')&quot; &quot;';
var profileLink = '&lt;a href=&quot;' + escapeHtml(userWebsite) + '&quot;&gt;Bob&lt;/a&gt;';
var div = document.getElementById('target');
div.innerHTML = profileLink;
// &lt;a href=&quot;&quot; onmouseover=&quot;alert('derp')&quot; &quot;&quot;&gt;Bob&lt;/a&gt;
</code></pre></div><p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p> <h4 id="document-createattribute"><a href="#document-createattribute" class="header-anchor">#</a> document.createAttribute()</h4> <p><code>document.createAttribute</code>方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p> <div class="language- extra-class"><pre class="language-text"><code>var attribute = document.createAttribute(name);
</code></pre></div><p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p> <div class="language- extra-class"><pre class="language-text"><code>var node = document.getElementById('div1');

var a = document.createAttribute('my_attrib');
a.value = 'newVal';

node.setAttributeNode(a);
// 或者
node.setAttribute('my_attrib', 'newVal');
</code></pre></div><p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p> <h4 id="document-createcomment"><a href="#document-createcomment" class="header-anchor">#</a> document.createComment()</h4> <p><code>document.createComment</code>方法生成一个新的注释节点，并返回该节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var CommentNode = document.createComment(data);
</code></pre></div><p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p> <h4 id="document-createdocumentfragment"><a href="#document-createdocumentfragment" class="header-anchor">#</a> document.createDocumentFragment()</h4> <p><code>document.createDocumentFragment</code>方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p> <div class="language- extra-class"><pre class="language-text"><code>var docFragment = document.createDocumentFragment();
</code></pre></div><p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p> <div class="language- extra-class"><pre class="language-text"><code>var docfrag = document.createDocumentFragment();

[1, 2, 3, 4].forEach(function (e) {
  var li = document.createElement('li');
  li.textContent = e;
  docfrag.appendChild(li);
});

var element  = document.getElementById('ul');
element.appendChild(docfrag);
</code></pre></div><p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p> <h4 id="document-createevent"><a href="#document-createevent" class="header-anchor">#</a> document.createEvent()</h4> <p><code>document.createEvent</code>方法生成一个事件对象（<code>Event</code>实例），该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p> <div class="language- extra-class"><pre class="language-text"><code>var event = document.createEvent(type);
</code></pre></div><p><code>document.createEvent</code>方法的参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var event = document.createEvent('Event');
event.initEvent('build', true, true);
document.addEventListener('build', function (e) {
  console.log(e.type); // &quot;build&quot;
}, false);
document.dispatchEvent(event);
</code></pre></div><p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p> <h4 id="document-addeventlistener-document-removeeventlistener-document-dispatchevent"><a href="#document-addeventlistener-document-removeeventlistener-document-dispatchevent" class="header-anchor">#</a> document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4> <p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口，详细介绍参见《EventTarget 接口》一章。</p> <div class="language- extra-class"><pre class="language-text"><code>// 添加事件监听函数
document.addEventListener('click', listener, false);

// 移除事件监听函数
document.removeEventListener('click', listener, false);

// 触发事件
var event = new Event('click');
document.dispatchEvent(event);
</code></pre></div><h4 id="document-hasfocus"><a href="#document-hasfocus" class="header-anchor">#</a> document.hasFocus()</h4> <p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p> <div class="language- extra-class"><pre class="language-text"><code>var focused = document.hasFocus();
</code></pre></div><p>注意，有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p> <h4 id="document-adoptnode-document-importnode"><a href="#document-adoptnode-document-importnode" class="header-anchor">#</a> document.adoptNode()，document.importNode()</h4> <p><code>document.adoptNode</code>方法将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var node = document.adoptNode(externalNode);
document.appendChild(node);
</code></pre></div><p>注意，<code>document.adoptNode</code>方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p> <p><code>document.importNode</code>方法则是从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var node = document.importNode(externalNode, deep);
</code></pre></div><p><code>document.importNode</code>方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p> <p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p> <div class="language- extra-class"><pre class="language-text"><code>var iframe = document.getElementsByTagName('iframe')[0];
var oldNode = iframe.contentWindow.document.getElementById('myNode');
var newNode = document.importNode(oldNode, true);
document.getElementById(&quot;container&quot;).appendChild(newNode);
</code></pre></div><p>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</p> <h4 id="document-createnodeiterator"><a href="#document-createnodeiterator" class="header-anchor">#</a> document.createNodeIterator()</h4> <p><code>document.createNodeIterator</code>方法返回一个子节点遍历器。</p> <div class="language- extra-class"><pre class="language-text"><code>var nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT
);
</code></pre></div><p>上面代码返回<code>&lt;body&gt;</code>元素子节点的遍历器。</p> <p><code>document.createNodeIterator</code>方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p> <ul><li>所有节点：NodeFilter.SHOW_ALL</li> <li>元素节点：NodeFilter.SHOW_ELEMENT</li> <li>文本节点：NodeFilter.SHOW_TEXT</li> <li>评论节点：NodeFilter.SHOW_COMMENT</li></ul> <p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var nodeIterator = document.createNodeIterator(document.body);
var pars = [];
var currentNode;

while (currentNode = nodeIterator.nextNode()) {
  pars.push(currentNode);
}
</code></pre></div><p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var nodeIterator = document.createNodeIterator(
  document.body,
  NodeFilter.SHOW_ELEMENT
);

var currentNode = nodeIterator.nextNode();
var previousNode = nodeIterator.previousNode();

currentNode === previousNode // true
</code></pre></div><p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p> <p>注意，遍历器返回的第一个节点，总是根节点。</p> <div class="language- extra-class"><pre class="language-text"><code>pars[0] === document.body // true
</code></pre></div><h4 id="document-createtreewalker"><a href="#document-createtreewalker" class="header-anchor">#</a> document.createTreeWalker()</h4> <p><code>document.createTreeWalker</code>方法返回一个 DOM 的子树遍历器。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的第一个节点不是根节点。</p> <p><code>document.createTreeWalker</code>方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p> <div class="language- extra-class"><pre class="language-text"><code>var treeWalker = document.createTreeWalker(
  document.body,
  NodeFilter.SHOW_ELEMENT
);

var nodeList = [];

while(treeWalker.nextNode()) {
  nodeList.push(treeWalker.currentNode);
}
</code></pre></div><p>上面代码遍历<code>&lt;body&gt;</code>节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p> <h4 id="document-execcommand-document-querycommandsupported-document-querycommandenabled"><a href="#document-execcommand-document-querycommandsupported-document-querycommandenabled" class="header-anchor">#</a> document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h4> <p><strong>（1）document.execCommand()</strong></p> <p>如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand('bold')</code>会使得字体加粗。</p> <div class="language- extra-class"><pre class="language-text"><code>document.execCommand(command, showDefaultUI, input)
</code></pre></div><p>该方法接受三个参数。</p> <ul><li><code>command</code>：字符串，表示所要实施的样式。</li> <li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li> <li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var url = window.prompt('请输入网址');

if (url) {
  document.execCommand('createlink', false, url);
}
</code></pre></div><p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是<code>false</code>，表示此时不需要自动弹出提示框。</p> <p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p> <p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p> <p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p> <p><strong>（2）document.queryCommandSupported()</strong></p> <p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示浏览器是否支持<code>document.execCommand()</code>的某个命令。</p> <div class="language- extra-class"><pre class="language-text"><code>if (document.queryCommandSupported('SelectAll')) {
  console.log('浏览器支持选中可编辑区域的所有内容');
}
</code></pre></div><p><strong>（3）document.queryCommandEnabled()</strong></p> <p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示当前是否可用<code>document.execCommand()</code>的某个命令。比如，<code>bold</code>（加粗）命令只有存在文本选中时才可用，如果没有选中文本，就不可用。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;input type=&quot;button&quot; value=&quot;Copy&quot; onclick=&quot;doCopy()&quot;&gt;

function doCopy(){
  // 浏览器是否支持 copy 命令（选中内容复制到剪贴板）
  if (document.queryCommandSupported('copy')) {
    copyText('你好');
  }else{
    console.log('浏览器不支持');
  }
}

function copyText(text) {
  var input = document.createElement('textarea');
  document.body.appendChild(input);
  input.value = text;
  input.focus();
  input.select();

  // 当前是否有选中文字
  if (document.queryCommandEnabled('copy')) {
    var success = document.execCommand('copy');
    input.remove();
    console.log('Copy Ok');
  } else {
    console.log('queryCommandEnabled is false');
  }
}
</code></pre></div><p>上面代码中，先判断浏览器是否支持<code>copy</code>命令（允许可编辑区域的选中内容，复制到剪贴板），如果支持，就新建一个临时文本框，里面写入内容“你好”，并将其选中。然后，判断是否选中成功，如果成功，就将“你好”复制到剪贴板，再删除那个临时文本框。</p> <h4 id="document-getselection"><a href="#document-getselection" class="header-anchor">#</a> document.getSelection()</h4> <p>这个方法指向<code>window.getSelection()</code>，参见<code>window</code>对象一节的介绍。</p> <h2 id="element-节点"><a href="#element-节点" class="header-anchor">#</a> Element 节点</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</p> <p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.querySelector('p');
p.nodeName // &quot;P&quot;
p.nodeType // 1
</code></pre></div><p><code>Element</code>对象继承了<code>Node</code>接口，因此<code>Node</code>的属性和方法在<code>Element</code>对象都存在。</p> <p>此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如<code>&lt;a&gt;</code>元素的构造函数是<code>HTMLAnchorElement()</code>，<code>&lt;button&gt;</code>是<code>HTMLButtonElement()</code>。因此，元素节点不是一种对象，而是许多种对象，这些对象除了继承<code>Element</code>对象的属性和方法，还有各自独有的属性和方法。</p> <h3 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h3> <h4 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="header-anchor">#</a> 元素特性的相关属性</h4> <p><strong>（1）Element.id</strong></p> <p><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为 &lt;p id=&quot;foo&quot;&gt;
var p = document.querySelector('p');
p.id // &quot;foo&quot;
</code></pre></div><p>注意，<code>id</code>属性的值是大小写敏感，即浏览器能正确识别<code>&lt;p id=&quot;foo&quot;&gt;</code>和<code>&lt;p id=&quot;FOO&quot;&gt;</code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p> <p><strong>（2）Element.tagName</strong></p> <p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML代码为
// &lt;span id=&quot;myspan&quot;&gt;Hello&lt;/span&gt;
var span = document.getElementById('myspan');
span.id // &quot;myspan&quot;
span.tagName // &quot;SPAN&quot;
</code></pre></div><p><strong>（3）Element.dir</strong></p> <p><code>Element.dir</code>属性用于读写当前元素的文字方向，可能是从左到右（<code>&quot;ltr&quot;</code>），也可能是从右到左（<code>&quot;rtl&quot;</code>）。</p> <p><strong>（4）Element.accessKey</strong></p> <p><code>Element.accessKey</code>属性用于读写分配给当前元素的快捷键。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;button accesskey=&quot;h&quot; id=&quot;btn&quot;&gt;点击&lt;/button&gt;
var btn = document.getElementById('btn');
btn.accessKey // &quot;h&quot;
</code></pre></div><p>上面代码中，<code>btn</code>元素的快捷键是<code>h</code>，按下<code>Alt + h</code>就能将焦点转移到它上面。</p> <p><strong>（5）Element.draggable</strong></p> <p><code>Element.draggable</code>属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p> <p><strong>（6）Element.lang</strong></p> <p><code>Element.lang</code>属性返回当前元素的语言设置。该属性可读写。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;html lang=&quot;en&quot;&gt;
document.documentElement.lang // &quot;en&quot;
</code></pre></div><p><strong>（7）Element.tabIndex</strong></p> <p><code>Element.tabIndex</code>属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p> <p><code>tabIndex</code>属性值如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p> <p><strong>（8）Element.title</strong></p> <p><code>Element.title</code>属性用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p> <h4 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="header-anchor">#</a> 元素状态的相关属性</h4> <p><strong>（1）Element.hidden</strong></p> <p><code>Element.hidden</code>属性返回一个布尔值，表示当前 HTML 元素的<code>hidden</code>属性的值。该属性可读写，用来控制当前元素是否可见。</p> <div class="language- extra-class"><pre class="language-text"><code>var btn = document.getElementById('btn');
var mydiv = document.getElementById('mydiv');

btn.addEventListener('click', function () {
  mydiv.hidden = !mydiv.hidden;
}, false);
</code></pre></div><p>注意，该属性与 CSS 设置是互相独立的。CSS 对当前元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p> <p>CSS 设置的优先级高于<code>Element.hidden</code>。如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>visibility: visible</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p> <p><strong>（2）Element.contentEditable，Element.isContentEditable</strong></p> <p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div contenteditable&gt;123&lt;/div&gt;
</code></pre></div><p>上面代码中，<code>&lt;div&gt;</code>元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p> <p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p> <ul><li><code>&quot;true&quot;</code>：元素内容可编辑</li> <li><code>&quot;false&quot;</code>：元素内容不可编辑</li> <li><code>&quot;inherit&quot;</code>：元素是否可编辑，继承了父元素的设置</li></ul> <p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p> <h4 id="element-attributes"><a href="#element-attributes" class="header-anchor">#</a> Element.attributes</h4> <p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点，详见《属性的操作》一章。</p> <div class="language- extra-class"><pre class="language-text"><code>var p = document.querySelector('p');
var attrs = p.attributes;

for (var i = attrs.length - 1; i &gt;= 0; i--) {
  console.log(attrs[i].name + '-&gt;' + attrs[i].value);
}
</code></pre></div><p>上面代码遍历<code>p</code>元素的所有属性。</p> <h4 id="element-classname-element-classlist"><a href="#element-classname-element-classlist" class="header-anchor">#</a> Element.className，Element.classList</h4> <p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割。</p> <p><code>classList</code>属性返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;
var div = document.getElementById('myDiv');

div.className
// &quot;one two three&quot;

div.classList
// {
//   0: &quot;one&quot;
//   1: &quot;two&quot;
//   2: &quot;three&quot;
//   length: 3
// }
</code></pre></div><p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。</p> <p><code>classList</code>对象有下列方法。</p> <ul><li><code>add()</code>：增加一个 class。</li> <li><code>remove()</code>：移除一个 class。</li> <li><code>contains()</code>：检查当前元素是否包含某个 class。</li> <li><code>toggle()</code>：将某个 class 移入或移出当前元素。</li> <li><code>item()</code>：返回指定索引位置的 class。</li> <li><code>toString()</code>：将 class 的列表转为字符串。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var div = document.getElementById('myDiv');

div.classList.add('myCssClass');
div.classList.add('foo', 'bar');
div.classList.remove('myCssClass');
div.classList.toggle('myCssClass'); // 如果 myCssClass 不存在就加入，否则移除
div.classList.contains('myCssClass'); // 返回 true 或者 false
div.classList.item(0); // 返回第一个 Class
div.classList.toString();
</code></pre></div><p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = document.getElementById('foo');

// 添加class
foo.className += 'bold';
foo.classList.add('bold');

// 删除class
foo.classList.remove('bold');
foo.className = foo.className.replace(/^bold$/, '');
</code></pre></div><p><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p> <div class="language- extra-class"><pre class="language-text"><code>el.classList.toggle('abc', boolValue);

// 等同于
if (boolValue) {
  el.classList.add('abc');
} else {
  el.classList.remove('abc');
}
</code></pre></div><h4 id="element-dataset"><a href="#element-dataset" class="header-anchor">#</a> Element.dataset</h4> <p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div data-timestamp=&quot;1522907809292&quot;&gt;&lt;/div&gt;
</code></pre></div><p>上面代码中，<code>&lt;div&gt;</code>元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p> <p><code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// &lt;article
//   id=&quot;foo&quot;
//   data-columns=&quot;3&quot;
//   data-index-number=&quot;12314&quot;
//   data-parent=&quot;cars&quot;&gt;
//   ...
// &lt;/article&gt;
var article = document.getElementById('foo');
article.dataset.columns // &quot;3&quot;
article.dataset.indexNumber // &quot;12314&quot;
article.dataset.parent // &quot;cars&quot;
</code></pre></div><p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p> <p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，规则如下。</p> <ul><li>开头的<code>data-</code>会省略。</li> <li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li> <li>其他字符不变。</li></ul> <p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[&quot;abc-1&quot;]</code>。</p> <p>除了使用<code>dataset</code>读写<code>data-</code>属性，也可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var mydiv = document.getElementById('mydiv');

mydiv.dataset.foo = 'bar';
mydiv.getAttribute('data-foo') // &quot;bar&quot;
</code></pre></div><h4 id="element-innerhtml"><a href="#element-innerhtml" class="header-anchor">#</a> Element.innerHTML</h4> <p><code>Element.innerHTML</code>属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>&lt;HTML&gt;</code>和<code>&lt;body&gt;</code>元素。</p> <p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p> <div class="language- extra-class"><pre class="language-text"><code>el.innerHTML = '';
</code></pre></div><p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p> <p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;</code>、<code>&lt;</code>、<code>&gt;</code>。如果想得到原文，建议使用<code>element.textContent</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML代码如下 &lt;p id=&quot;para&quot;&gt; 5 &gt; 3 &lt;/p&gt;
document.getElementById('para').innerHTML
// 5 &amp;gt; 3
</code></pre></div><p>写入的时候，如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有<code>&lt;script&gt;</code>标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p> <div class="language- extra-class"><pre class="language-text"><code>var name = &quot;&lt;script&gt;alert('haha')&lt;/script&gt;&quot;;
el.innerHTML = name;
</code></pre></div><p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p> <div class="language- extra-class"><pre class="language-text"><code>var name = &quot;&lt;img src=x onerror=alert(1)&gt;&quot;;
el.innerHTML = name;
</code></pre></div><p>上面代码中，<code>alert</code>方法是会执行的。因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</p> <h4 id="element-outerhtml"><a href="#element-outerhtml" class="header-anchor">#</a> Element.outerHTML</h4> <p><code>Element.outerHTML</code>属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;
var d = document.getElementById('d');
d.outerHTML
// '&lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;'
</code></pre></div><p><code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;container&quot;&gt;&lt;div id=&quot;d&quot;&gt;Hello&lt;/div&gt;&lt;/div&gt;
var container = document.getElementById('container');
var d = document.getElementById('d');
container.firstChild.nodeName // &quot;DIV&quot;
d.nodeName // &quot;DIV&quot;

d.outerHTML = '&lt;p&gt;Hello&lt;/p&gt;';
container.firstChild.nodeName // &quot;P&quot;
d.nodeName // &quot;DIV&quot;
</code></pre></div><p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，变量<code>d</code>依然指向原来的<code>div</code>元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</p> <p>注意，如果一个节点没有父节点，设置<code>outerHTML</code>属性会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.createElement('div');
div.outerHTML = '&lt;p&gt;test&lt;/p&gt;';
// DOMException: This element has no parent node.
</code></pre></div><p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p> <h4 id="element-clientheight-element-clientwidth"><a href="#element-clientheight-element-clientwidth" class="header-anchor">#</a> Element.clientHeight，Element.clientWidth</h4> <p><code>Element.clientHeight</code>属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回<code>0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p> <p>除了元素本身的高度，它还包括<code>padding</code>部分，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p> <p><code>Element.clientWidth</code>属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p> <p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// 视口高度
document.documentElement.clientHeight

// 网页总高度
document.body.clientHeight
</code></pre></div><h4 id="element-clientleft-element-clienttop"><a href="#element-clientleft-element-clienttop" class="header-anchor">#</a> Element.clientLeft，Element.clientTop</h4> <p><code>Element.clientLeft</code>属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p> <p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度（单位像素），其他特点都与<code>clientLeft</code>相同。</p> <h4 id="element-scrollheight-element-scrollwidth"><a href="#element-scrollheight-element-scrollwidth" class="header-anchor">#</a> Element.scrollHeight，Element.scrollWidth</h4> <p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p> <p><code>Element.scrollWidth</code>属性表示当前元素的总宽度（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p> <p>整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p> <div class="language- extra-class"><pre class="language-text"><code>// 返回网页的总高度
document.documentElement.scrollHeight
document.body.scrollHeight
</code></pre></div><p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;myDiv&quot; style=&quot;height: 200px; overflow: hidden;&quot;&gt;...&lt;div&gt;
document.getElementById('myDiv').scrollHeight // 356
</code></pre></div><p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有200像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p> <h4 id="element-scrollleft-element-scrolltop"><a href="#element-scrollleft-element-scrolltop" class="header-anchor">#</a> Element.scrollLeft，Element.scrollTop</h4> <p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code>属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p> <p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p> <div class="language- extra-class"><pre class="language-text"><code>document.documentElement.scrollLeft
document.documentElement.scrollTop
</code></pre></div><p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p> <h4 id="element-offsetparent"><a href="#element-offsetparent" class="header-anchor">#</a> Element.offsetParent</h4> <p><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style=&quot;position: absolute;&quot;&gt;
  &lt;p&gt;
    &lt;span&gt;Hello&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre></div><p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p> <p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p> <p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style=&quot;position: absolute;&quot;&gt;
  &lt;p&gt;
    &lt;span style=&quot;display: none;&quot;&gt;Hello&lt;/span&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre></div><p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p> <p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向<code>&lt;body&gt;</code>元素。</p> <h4 id="element-offsetheight-element-offsetwidth"><a href="#element-offsetheight-element-offsetwidth" class="header-anchor">#</a> Element.offsetHeight，Element.offsetWidth</h4> <p><code>Element.offsetHeight</code>属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</p> <p><code>Element.offsetWidth</code>属性表示元素的 CSS 水平宽度（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p> <p>这两个属性都是只读属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p> <h4 id="element-offsetleft-element-offsettop"><a href="#element-offsetleft-element-offsettop" class="header-anchor">#</a> Element.offsetLeft，Element.offsetTop</h4> <p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移，<code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p> <p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p> <div class="language- extra-class"><pre class="language-text"><code>function getElementPosition(e) {
  var x = 0;
  var y = 0;
  while (e !== null)  {
    x += e.offsetLeft;
    y += e.offsetTop;
    e = e.offsetParent;
  }
  return {x: x, y: y};
}
</code></pre></div><h4 id="element-style"><a href="#element-style" class="header-anchor">#</a> Element.style</h4> <p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息，具体介绍参见《CSS 操作》一章。</p> <h4 id="element-children-element-childelementcount"><a href="#element-children-element-childelementcount" class="header-anchor">#</a> Element.children，Element.childElementCount</h4> <p><code>Element.children</code>属性返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p> <div class="language- extra-class"><pre class="language-text"><code>if (para.children.length) {
  var children = para.children;
    for (var i = 0; i &lt; children.length; i++) {
      // ...
    }
}
</code></pre></div><p>上面代码遍历了<code>para</code>元素的所有子元素。</p> <p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p> <p><code>Element.childElementCount</code>属性返回当前元素节点包含的子元素节点的个数，与<code>Element.children.length</code>的值相同。</p> <h4 id="element-firstelementchild-element-lastelementchild"><a href="#element-firstelementchild-element-lastelementchild" class="header-anchor">#</a> Element.firstElementChild，Element.lastElementChild</h4> <p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p> <p>如果没有元素子节点，这两个属性返回<code>null</code>。</p> <h4 id="element-nextelementsibling-element-previouselementsibling"><a href="#element-nextelementsibling-element-previouselementsibling" class="header-anchor">#</a> Element.nextElementSibling，Element.previousElementSibling</h4> <p><code>Element.nextElementSibling</code>属性返回当前元素节点的后一个同级元素节点，如果没有则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;div-01&quot;&gt;Here is div-01&lt;/div&gt;
// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;
var el = document.getElementById('div-01');
el.nextElementSibling
// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;
</code></pre></div><p><code>Element.previousElementSibling</code>属性返回当前元素节点的前一个同级元素节点，如果没有则返回<code>null</code>。</p> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <h4 id="属性相关方法"><a href="#属性相关方法" class="header-anchor">#</a> 属性相关方法</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul><li><code>getAttribute()</code>：读取某个属性的值</li> <li><code>getAttributeNames()</code>：返回当前元素的所有属性名</li> <li><code>setAttribute()</code>：写入属性值</li> <li><code>hasAttribute()</code>：某个属性是否存在</li> <li><code>hasAttributes()</code>：当前元素是否有属性</li> <li><code>removeAttribute()</code>：删除属性</li></ul> <p>这些方法的介绍请看《属性的操作》一章。</p> <h4 id="element-queryselector"><a href="#element-queryselector" class="header-anchor">#</a> Element.querySelector()</h4> <p><code>Element.querySelector</code>方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var content = document.getElementById('content');
var el = content.querySelector('p');
</code></pre></div><p>上面代码返回<code>content</code>节点的第一个<code>p</code>元素。</p> <p><code>Element.querySelector</code>方法可以接受任何复杂的 CSS 选择器。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.querySelector(&quot;style[type='text/css'], style:not([type])&quot;);
</code></pre></div><p>注意，这个方法无法选中伪元素。</p> <p>它可以接受多个选择器，它们之间使用逗号分隔。</p> <div class="language- extra-class"><pre class="language-text"><code>element.querySelector('div, p')
</code></pre></div><p>上面代码返回<code>element</code>的第一个<code>div</code>或<code>p</code>子元素。</p> <p>需要注意的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
&lt;blockquote id=&quot;outer&quot;&gt;
  &lt;p&gt;Hello&lt;/p&gt;
  &lt;div id=&quot;inner&quot;&gt;
    &lt;p&gt;World&lt;/p&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</code></pre></div><p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p> <div class="language- extra-class"><pre class="language-text"><code>var outer = document.getElementById('outer');
outer.querySelector('div p')
// &lt;p&gt;Hello&lt;/p&gt;
</code></pre></div><h4 id="element-queryselectorall"><a href="#element-queryselectorall" class="header-anchor">#</a> Element.querySelectorAll()</h4> <p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，返回一个<code>NodeList</code>实例，包含所有匹配的子元素。</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.querySelector('#test');
var matches = el.querySelectorAll('div.highlighted &gt; p');
</code></pre></div><p>该方法的执行机制与<code>querySelector</code>方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p> <p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p> <h4 id="element-getelementsbyclassname"><a href="#element-getelementsbyclassname" class="header-anchor">#</a> Element.getElementsByClassName()</h4> <p><code>Element.getElementsByClassName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p> <div class="language- extra-class"><pre class="language-text"><code>element.getElementsByClassName('red test');
</code></pre></div><p>注意，该方法的参数大小写敏感。</p> <p>由于<code>HTMLCollection</code>实例是一个活的集合，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;example&quot;&gt;
//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;
//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;
// &lt;/div&gt;
var element = document.getElementById('example');
var matches = element.getElementsByClassName('foo');

for (var i = 0; i&lt; matches.length; i++) {
  matches[i].classList.remove('foo');
  matches.item(i).classList.add('bar');
}
// 执行后，HTML 代码如下
// &lt;div id=&quot;example&quot;&gt;
//   &lt;p&gt;&lt;/p&gt;
//   &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;
// &lt;/div&gt;
</code></pre></div><p>上面代码中，<code>matches</code>集合的第一个成员，一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失，导致出现上面的结果。</p> <h4 id="element-getelementsbytagname"><a href="#element-getelementsbytagname" class="header-anchor">#</a> Element.getElementsByTagName()</h4> <p><code>Element.getElementsByTagName()</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与<code>document.getElementsByClassName()</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var table = document.getElementById('forecast-table');
var cells = table.getElementsByTagName('td');
</code></pre></div><p>注意，该方法的参数是大小写不敏感的，因为 HTML 标签名也是大小写不敏感。</p> <h4 id="element-closest"><a href="#element-closest" class="header-anchor">#</a> Element.closest()</h4> <p><code>Element.closest</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;article&gt;
//   &lt;div id=&quot;div-01&quot;&gt;Here is div-01
//     &lt;div id=&quot;div-02&quot;&gt;Here is div-02
//       &lt;div id=&quot;div-03&quot;&gt;Here is div-03&lt;/div&gt;
//     &lt;/div&gt;
//   &lt;/div&gt;
// &lt;/article&gt;

var div03 = document.getElementById('div-03');

// div-03 最近的祖先节点
div03.closest(&quot;#div-02&quot;) // div-02
div03.closest(&quot;div div&quot;) // div-03
div03.closest(&quot;article &gt; div&quot;) //div-01
div03.closest(&quot;:not(div)&quot;) // article
</code></pre></div><p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p> <h4 id="element-matches"><a href="#element-matches" class="header-anchor">#</a> Element.matches()</h4> <p><code>Element.matches</code>方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p> <div class="language- extra-class"><pre class="language-text"><code>if (el.matches('.someClass')) {
  console.log('Match!');
}
</code></pre></div><h4 id="事件相关方法"><a href="#事件相关方法" class="header-anchor">#</a> 事件相关方法</h4> <p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口，详见相关章节。</p> <ul><li><code>Element.addEventListener()</code>：添加事件的回调函数</li> <li><code>Element.removeEventListener()</code>：移除事件监听函数</li> <li><code>Element.dispatchEvent()</code>：触发事件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>element.addEventListener('click', listener, false);
element.removeEventListener('click', listener, false);

var event = new Event('click');
element.dispatchEvent(event);
</code></pre></div><h4 id="element-scrollintoview"><a href="#element-scrollintoview" class="header-anchor">#</a> Element.scrollIntoView()</h4> <p><code>Element.scrollIntoView</code>方法滚动当前元素，进入浏览器的可见区域，类似于设置<code>window.location.hash</code>的效果。</p> <div class="language- extra-class"><pre class="language-text"><code>el.scrollIntoView(); // 等同于el.scrollIntoView(true)
el.scrollIntoView(false);
</code></pre></div><p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p> <h4 id="element-getboundingclientrect"><a href="#element-getboundingclientrect" class="header-anchor">#</a> Element.getBoundingClientRect()</h4> <p><code>Element.getBoundingClientRect</code>方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p> <div class="language- extra-class"><pre class="language-text"><code>var rect = obj.getBoundingClientRect();
</code></pre></div><p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为只读）。</p> <ul><li><code>x</code>：元素左上角相对于视口的横坐标</li> <li><code>y</code>：元素左上角相对于视口的纵坐标</li> <li><code>height</code>：元素高度</li> <li><code>width</code>：元素宽度</li> <li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li> <li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li> <li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li> <li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li></ul> <p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX</code>，<code>top</code>属性加上<code>window.scrollY</code>。</p> <p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code>width</code>和<code>height</code>包括了元素本身 + <code>padding</code> + <code>border</code>。</p> <p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p> <div class="language- extra-class"><pre class="language-text"><code>var rect = document.body.getBoundingClientRect();
Object.keys(rect) // []
</code></pre></div><p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p> <h4 id="element-getclientrects"><a href="#element-getclientrects" class="header-anchor">#</a> Element.getClientRects()</h4> <p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的<code>Rect</code>用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p> <p>对于盒状元素（比如<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span id=&quot;inline&quot;&gt;Hello World Hello World Hello World&lt;/span&gt;
</code></pre></div><p>上面代码是一个行内元素<code>&lt;span&gt;</code>，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.getElementById('inline');
el.getClientRects().length // 3
el.getClientRects()[0].left // 8
el.getClientRects()[0].right // 113.908203125
el.getClientRects()[0].bottom // 31.200000762939453
el.getClientRects()[0].height // 23.200000762939453
el.getClientRects()[0].width // 105.908203125
</code></pre></div><p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p> <p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;span id=&quot;inline&quot;&gt;
  Hello World
  Hello World
  Hello World
&lt;/span&gt;
</code></pre></div><p>上面代码中，<code>&lt;span&gt;</code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，<code>getClientRects()</code>方法依然会返回三个成员。如果行宽设置得特别窄，上面的<code>&lt;span&gt;</code>元素显示为6行，那么就会返回六个成员。</p> <h4 id="element-insertadjacentelement"><a href="#element-insertadjacentelement" class="header-anchor">#</a> Element.insertAdjacentElement()</h4> <p><code>Element.insertAdjacentElement</code>方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>element.insertAdjacentElement(position, element);
</code></pre></div><p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p> <ul><li><code>beforebegin</code>：当前元素之前</li> <li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li> <li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li> <li><code>afterend</code>：当前元素之后</li></ul> <p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p> <div class="language- extra-class"><pre class="language-text"><code>var p1 = document.createElement('p')
var p2 = document.createElement('p')
p1.insertAdjacentElement('afterend', p2) // null
</code></pre></div><p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p> <p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p> <h4 id="element-insertadjacenthtml-element-insertadjacenttext"><a href="#element-insertadjacenthtml-element-insertadjacenttext" class="header-anchor">#</a> Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4> <p><code>Element.insertAdjacentHTML</code>方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p> <div class="language- extra-class"><pre class="language-text"><code>element.insertAdjacentHTML(position, text);
</code></pre></div><p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p> <ul><li><code>beforebegin</code>：当前元素之前</li> <li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li> <li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li> <li><code>afterend</code>：当前元素之后</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;
var d1 = document.getElementById('one');
d1.insertAdjacentHTML('afterend', '&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;');
// 执行后的 HTML 代码：
// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;
</code></pre></div><p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</p> <p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p> <p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;
var d1 = document.getElementById('one');
d1.insertAdjacentText('afterend', 'two');
// 执行后的 HTML 代码：
// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;two
</code></pre></div><h4 id="element-remove"><a href="#element-remove" class="header-anchor">#</a> Element.remove()</h4> <p><code>Element.remove</code>方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.getElementById('mydiv');
el.remove();
</code></pre></div><p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p> <h4 id="element-focus-element-blur"><a href="#element-focus-element-blur" class="header-anchor">#</a> Element.focus()，Element.blur()</h4> <p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上。</p> <div class="language- extra-class"><pre class="language-text"><code>document.getElementById('my-span').focus();
</code></pre></div><p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p> <div class="language- extra-class"><pre class="language-text"><code>function getFocus() {
  document.getElementById('btn').focus({preventScroll:false});
}
</code></pre></div><p>上面代码会让<code>btn</code>元素获得焦点，并滚动到可见区域。</p> <p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p> <p><code>Element.blur</code>方法用于将焦点从当前元素移除。</p> <h4 id="element-click"><a href="#element-click" class="header-anchor">#</a> Element.click()</h4> <p><code>Element.click</code>方法用于在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</p> <h3 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h3> <ul><li>Craig Buckler，<a href="https://www.sitepoint.com/how-to-translate-from-dom-to-svg-coordinates-and-back-again/" target="_blank" rel="noopener noreferrer">How to Translate from DOM to SVG Coordinates and Back Again<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="属性的操作"><a href="#属性的操作" class="header-anchor">#</a> 属性的操作</h2> <p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;a id=&quot;test&quot; href=&quot;http://www.example.com&quot;&gt;
  链接
&lt;/a&gt;
</code></pre></div><p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p> <p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。本章介绍如何操作这些属性。</p> <h3 id="element-attributes-属性"><a href="#element-attributes-属性" class="header-anchor">#</a> Element.attributes 属性</h3> <p>元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p> <p>单个属性可以通过序号引用，也可以通过属性名引用。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;body bgcolor=&quot;yellow&quot; onload=&quot;&quot;&gt;
document.body.attributes[0]
document.body.attributes.bgcolor
document.body.attributes['ONLOAD']
</code></pre></div><p>注意，上面代码的三种方法，返回的都是属性节点对象，而不是属性值。</p> <p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML代码为
// &lt;div id=&quot;mydiv&quot;&gt;
var n = document.getElementById('mydiv');

n.attributes[0].name // &quot;id&quot;
n.attributes[0].nodeName // &quot;id&quot;

n.attributes[0].value // &quot;mydiv&quot;
n.attributes[0].nodeValue // &quot;mydiv&quot;
</code></pre></div><p>下面代码可以遍历一个元素节点的所有属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var para = document.getElementsByTagName('p')[0];
var result = document.getElementById('result');

if (para.hasAttributes()) {
  var attrs = para.attributes;
  var output = '';
  for(var i = attrs.length - 1; i &gt;= 0; i--) {
    output += attrs[i].name + '-&gt;' + attrs[i].value;
  }
  result.textContent = output;
} else {
  result.textContent = 'No attributes to show';
}
</code></pre></div><h3 id="元素的标准属性"><a href="#元素的标准属性" class="header-anchor">#</a> 元素的标准属性</h3> <p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var a = document.getElementById('test');
a.id // &quot;test&quot;
a.href // &quot;http://www.example.com/&quot;
</code></pre></div><p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p> <p>这些属性都是可写的。</p> <div class="language- extra-class"><pre class="language-text"><code>var img = document.getElementById('myImage');
img.src = 'http://www.example.com/image.jpg';
</code></pre></div><p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p> <p>这种修改属性的方法，常常用于添加表单的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var f = document.forms[0];
f.action = 'submit.php';
f.method = 'POST';
</code></pre></div><p>上面代码为表单添加提交网址和提交方法。</p> <p>注意，这种用法虽然可以读写属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效。</p> <p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p> <p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p> <ul><li><code>for</code>属性改为<code>htmlFor</code></li> <li><code>class</code>属性改为<code>className</code></li></ul> <p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p> <h3 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="header-anchor">#</a> 属性操作的标准方法</h3> <h4 id="概述-5"><a href="#概述-5" class="header-anchor">#</a> 概述</h4> <p>元素节点提供六个方法，用来操作属性。</p> <ul><li><code>getAttribute()</code></li> <li><code>getAttributeNames()</code></li> <li><code>setAttribute()</code></li> <li><code>hasAttribute()</code></li> <li><code>hasAttributes()</code></li> <li><code>removeAttribute()</code></li></ul> <p>这有几点注意。</p> <p>（1）适用性</p> <p>这六个方法对所有属性（包括用户自定义的属性）都适用。</p> <p>（2）返回值</p> <p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。</p> <p>（3）属性名</p> <p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p> <div class="language- extra-class"><pre class="language-text"><code>var image = document.images[0];
image.setAttribute('class', 'myImage');
</code></pre></div><p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p> <h4 id="element-getattribute"><a href="#element-getattribute" class="header-anchor">#</a> Element.getAttribute()</h4> <p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;div1&quot; align=&quot;left&quot;&gt;
var div = document.getElementById('div1');
div.getAttribute('align') // &quot;left&quot;
</code></pre></div><h4 id="element-getattributenames"><a href="#element-getattributenames" class="header-anchor">#</a> Element.getAttributeNames()</h4> <p><code>Element.getAttributeNames()</code>返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var mydiv = document.getElementById('mydiv');

mydiv.getAttributeNames().forEach(function (key) {
  var value = mydiv.getAttribute(key);
  console.log(key, value);
})
</code></pre></div><p>上面代码用于遍历某个节点的所有属性。</p> <h4 id="element-setattribute"><a href="#element-setattribute" class="header-anchor">#</a> Element.setAttribute()</h4> <p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;button&gt;Hello World&lt;/button&gt;
var b = document.querySelector('button');
b.setAttribute('name', 'myButton');
b.setAttribute('disabled', true);
</code></pre></div><p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p> <p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p> <h4 id="element-hasattribute"><a href="#element-hasattribute" class="header-anchor">#</a> Element.hasAttribute()</h4> <p><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var d = document.getElementById('div1');

if (d.hasAttribute('align')) {
  d.setAttribute('align', 'center');
}
</code></pre></div><p>上面代码检查<code>div</code>节点是否含有<code>align</code>属性。如果有，则设置为居中对齐。</p> <h4 id="element-hasattributes"><a href="#element-hasattributes" class="header-anchor">#</a> Element.hasAttributes()</h4> <p><code>Element.hasAttributes</code>方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = document.getElementById('foo');
foo.hasAttributes() // true
</code></pre></div><h4 id="element-removeattribute"><a href="#element-removeattribute" class="header-anchor">#</a> Element.removeAttribute()</h4> <p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;
document.getElementById('div1').removeAttribute('align');
// 现在的HTML代码为
// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt;
</code></pre></div><h3 id="dataset-属性"><a href="#dataset-属性" class="header-anchor">#</a> dataset 属性</h3> <p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;mydiv&quot; foo=&quot;bar&quot;&gt;
</code></pre></div><p>上面代码为<code>div</code>元素自定义了<code>foo</code>属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var n = document.getElementById('mydiv');
n.getAttribute('foo') // bar
n.setAttribute('foo', 'baz')
</code></pre></div><p>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</p> <p>更好的解决方法是，使用标准提供的<code>data-*</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;mydiv&quot; data-foo=&quot;bar&quot;&gt;
</code></pre></div><p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var n = document.getElementById('mydiv');
n.dataset.foo // bar
n.dataset.foo = 'baz'
</code></pre></div><p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p> <p>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</p> <div class="language- extra-class"><pre class="language-text"><code>delete document.getElementById('myDiv').dataset.foo;
</code></pre></div><p>除了<code>dataset</code>属性，也可以用<code>getAttribute('data-foo')</code>、<code>removeAttribute('data-foo')</code>、<code>setAttribute('data-foo')</code>、<code>hasAttribute('data-foo')</code>等方法操作<code>data-*</code>属性。</p> <p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p> <p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p> <h2 id="text-节点和-documentfragment-节点"><a href="#text-节点和-documentfragment-节点" class="header-anchor">#</a> Text 节点和 DocumentFragment 节点</h2> <h3 id="text-节点的概念"><a href="#text-节点的概念" class="header-anchor">#</a> Text 节点的概念</h3> <p>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p> <p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p> <div class="language- extra-class"><pre class="language-text"><code>// 获取文本节点
var textNode = document.querySelector('p').firstChild;

// 创造文本节点
var textNode = document.createTextNode('Hi');
document.querySelector('div').appendChild(textNode);
</code></pre></div><p>浏览器原生提供一个<code>Text</code>构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</p> <div class="language- extra-class"><pre class="language-text"><code>// 空字符串
var text1 = new Text();

// 非空字符串
var text2 = new Text('This is a text node');
</code></pre></div><p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code>&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p> <p>文本节点除了继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口。<code>Node</code>接口的属性和方法请参考《Node 接口》一章，这里不再重复介绍了，以下的属性和方法大部分来自<code>CharacterData</code>接口。</p> <h3 id="text-节点的属性"><a href="#text-节点的属性" class="header-anchor">#</a> Text 节点的属性</h3> <h4 id="data"><a href="#data" class="header-anchor">#</a> data</h4> <p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取文本节点的内容。</p> <div class="language- extra-class"><pre class="language-text"><code>// 读取文本内容
document.querySelector('p').firstChild.data
// 等同于
document.querySelector('p').firstChild.nodeValue

// 设置文本内容
document.querySelector('p').firstChild.data = 'Hello World';
</code></pre></div><h4 id="wholetext"><a href="#wholetext" class="header-anchor">#</a> wholeText</h4> <p><code>wholeText</code>属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p> <p>举例来说，HTML 代码如下。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;p id=&quot;para&quot;&gt;A &lt;em&gt;B&lt;/em&gt; C&lt;/p&gt;
</code></pre></div><p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p> <div class="language- extra-class"><pre class="language-text"><code>var el = document.getElementById('para');
el.firstChild.wholeText // &quot;A &quot;
el.firstChild.data // &quot;A &quot;
</code></pre></div><p>但是，一旦移除<code>&lt;em&gt;</code>节点，<code>wholeText</code>属性与<code>data</code>属性就会有差异，因为这时其实<code>&lt;p&gt;</code>节点下面包含了两个毗邻的文本节点。</p> <div class="language- extra-class"><pre class="language-text"><code>el.removeChild(para.childNodes[1]);
el.firstChild.wholeText // &quot;A C&quot;
el.firstChild.data // &quot;A &quot;
</code></pre></div><h4 id="length"><a href="#length" class="header-anchor">#</a> length</h4> <p><code>length</code>属性返回当前文本节点的文本长度。</p> <div class="language- extra-class"><pre class="language-text"><code>(new Text('Hello')).length // 5
</code></pre></div><h4 id="nextelementsibling-previouselementsibling"><a href="#nextelementsibling-previouselementsibling" class="header-anchor">#</a> nextElementSibling，previousElementSibling</h4> <p><code>nextElementSibling</code>属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 为
// &lt;div&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/div&gt;
var tn = document.querySelector('div').firstChild;
tn.nextElementSibling
// &lt;em&gt;World&lt;/em&gt;
</code></pre></div><p><code>previousElementSibling</code>属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回<code>null：</code>。</p> <h3 id="text-节点的方法"><a href="#text-节点的方法" class="header-anchor">#</a> Text 节点的方法</h3> <h4 id="appenddata-deletedata-insertdata-replacedata-substringdata"><a href="#appenddata-deletedata-insertdata-replacedata-substringdata" class="header-anchor">#</a> appendData()，deleteData()，insertData()，replaceData()，subStringData()</h4> <p>以下5个方法都是编辑<code>Text</code>节点文本内容的方法。</p> <ul><li><code>appendData()</code>：在<code>Text</code>节点尾部追加字符串。</li> <li><code>deleteData()</code>：删除<code>Text</code>节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li> <li><code>insertData()</code>：在<code>Text</code>节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li> <li><code>replaceData()</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li> <li><code>subStringData()</code>：用于获取子字符串，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;p&gt;Hello World&lt;/p&gt;
var pElementText = document.querySelector('p').firstChild;

pElementText.appendData('!');
// 页面显示 Hello World!
pElementText.deleteData(7, 5);
// 页面显示 Hello W
pElementText.insertData(7, 'Hello ');
// 页面显示 Hello WHello
pElementText.replaceData(7, 5, 'World');
// 页面显示 Hello WWorld
pElementText.substringData(7, 10);
// 页面显示不变，返回&quot;World &quot;
</code></pre></div><h4 id="remove"><a href="#remove" class="header-anchor">#</a> remove()</h4> <p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;p&gt;Hello World&lt;/p&gt;
document.querySelector('p').firstChild.remove()
// 现在 HTML 代码为
// &lt;p&gt;&lt;/p&gt;
</code></pre></div><h4 id="splittext"><a href="#splittext" class="header-anchor">#</a> splitText()</h4> <p><code>splitText</code>方法将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p> <p>分割后，该方法返回分割位置后方的字符串，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>// html 代码为 &lt;p id=&quot;p&quot;&gt;foobar&lt;/p&gt;
var p = document.getElementById('p');
var textnode = p.firstChild;

var newText = textnode.splitText(3);
newText // &quot;bar&quot;
textnode // &quot;foo&quot;
</code></pre></div><p>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</p> <p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p> <div class="language- extra-class"><pre class="language-text"><code>p.childNodes.length // 2

// 将毗邻的两个 Text 节点合并
p.normalize();
p.childNodes.length // 1
</code></pre></div><h3 id="documentfragment-节点"><a href="#documentfragment-节点" class="header-anchor">#</a> DocumentFragment 节点</h3> <p><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</p> <p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。然后再使用其他 DOM 方法，向其添加子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var docFrag = document.createDocumentFragment();
// 等同于
var docFrag = new DocumentFragment();

var li = document.createElement('li');
li.textContent = 'Hello World';
docFrag.appendChild(li);

document.querySelector('ul').appendChild(docFrag);
</code></pre></div><p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p> <p>注意，<code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>document
  .querySelector('ul')
  .appendChild(docFrag.cloneNode(true));
</code></pre></div><p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p> <p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p> <div class="language- extra-class"><pre class="language-text"><code>function reverse(n) {
  var f = document.createDocumentFragment();
  while(n.lastChild) f.appendChild(n.lastChild);
  n.appendChild(f);
}
</code></pre></div><p><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</p> <ul><li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</li> <li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</li> <li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</li> <li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</li></ul> <h2 id="css-操作"><a href="#css-操作" class="header-anchor">#</a> CSS 操作</h2> <p>CSS 与 JavaScript 是两个有着明确分工的领域，前者负责页面的视觉效果，后者负责与用户的行为互动。但是，它们毕竟同属网页开发的前端，因此不可避免有着交叉和互相配合。本章介绍如何通过 JavaScript 操作 CSS。</p> <h3 id="html-元素的-style-属性"><a href="#html-元素的-style-属性" class="header-anchor">#</a> HTML 元素的 style 属性</h3> <p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute()</code>方法、<code>setAttribute()</code>方法和<code>removeAttribute()</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>div.setAttribute(
  'style',
  'background-color:red;' + 'border:1px solid black;'
);
</code></pre></div><p>上面的代码相当于下面的 HTML 代码。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style=&quot;background-color:red; border:1px solid black;&quot; /&gt;
</code></pre></div><p><code>style</code>不仅可以使用字符串读写，它本身还是一个对象，部署了 CSSStyleDeclaration 接口（详见下面的介绍），可以直接读写个别属性。</p> <div class="language- extra-class"><pre class="language-text"><code>e.style.fontSize = '18px';
e.style.color = 'black';
</code></pre></div><h3 id="cssstyledeclaration-接口"><a href="#cssstyledeclaration-接口" class="header-anchor">#</a> CSSStyleDeclaration 接口</h3> <h4 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> 简介</h4> <p>CSSStyleDeclaration 接口用来操作元素的样式。三个地方部署了这个接口。</p> <ul><li>元素节点的<code>style</code>属性（<code>Element.style</code>）</li> <li><code>CSSStyle</code>实例的<code>style</code>属性</li> <li><code>window.getComputedStyle()</code>的返回值</li></ul> <p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性，不过，连词号需要变成骆驼拼写法。</p> <div class="language- extra-class"><pre class="language-text"><code>var divStyle = document.querySelector('div').style;

divStyle.backgroundColor = 'red';
divStyle.border = '1px solid black';
divStyle.width = '100px';
divStyle.height = '100px';
divStyle.fontSize = '10em';

divStyle.backgroundColor // red
divStyle.border // 1px solid black
divStyle.height // 100px
divStyle.width // 100px
</code></pre></div><p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。这个对象所包含的属性与 CSS 规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code>。</p> <p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p> <p>另外，<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过<code>window.getComputedStyle()</code>得到。</p> <h4 id="cssstyledeclaration-实例属性"><a href="#cssstyledeclaration-实例属性" class="header-anchor">#</a> CSSStyleDeclaration 实例属性</h4> <p><strong>（1）CSSStyleDeclaration.cssText</strong></p> <p><code>CSSStyleDeclaration.cssText</code>属性用来读写当前规则的所有样式声明文本。</p> <div class="language- extra-class"><pre class="language-text"><code>var divStyle = document.querySelector('div').style;

divStyle.cssText = 'background-color: red;'
  + 'border: 1px solid black;'
  + 'height: 100px;'
  + 'width: 100px;';
</code></pre></div><p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p> <p>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>divStyle.cssText = '';
</code></pre></div><p><strong>（2）CSSStyleDeclaration.length</strong></p> <p><code>CSSStyleDeclaration.length</code>属性返回一个整数值，表示当前规则包含多少条样式声明。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;myDiv&quot;
//   style=&quot;height: 1px;width: 100%;background-color: #CA1;&quot;
// &gt;&lt;/div&gt;
var myDiv = document.getElementById('myDiv');
var divStyle = myDiv.style;
divStyle.length // 3
</code></pre></div><p>上面代码中，<code>myDiv</code>元素的行内样式共包含3条样式规则。</p> <p><strong>（3）CSSStyleDeclaration.parentRule</strong></p> <p><code>CSSStyleDeclaration.parentRule</code>属性返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。</p> <p>该属性只读，且只在使用 CSSRule 接口时有意义。</p> <div class="language- extra-class"><pre class="language-text"><code>var declaration = document.styleSheets[0].rules[0].style;
declaration.parentRule === document.styleSheets[0].rules[0]
// true
</code></pre></div><h4 id="cssstyledeclaration-实例方法"><a href="#cssstyledeclaration-实例方法" class="header-anchor">#</a> CSSStyleDeclaration 实例方法</h4> <p><strong>（1）CSSStyleDeclaration.getPropertyPriority()</strong></p> <p><code>CSSStyleDeclaration.getPropertyPriority</code>方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;
var style = document.getElementById('myDiv').style;
style.margin // &quot;10px&quot;
style.getPropertyPriority('margin') // &quot;important&quot;
style.getPropertyPriority('color') // &quot;&quot;
</code></pre></div><p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p> <p><strong>（2）CSSStyleDeclaration.getPropertyValue()</strong></p> <p><code>CSSStyleDeclaration.getPropertyValue</code>方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;
var style = document.getElementById('myDiv').style;
style.margin // &quot;10px&quot;
style.getPropertyValue(&quot;margin&quot;) // &quot;10px&quot;
</code></pre></div><p><strong>（3）CSSStyleDeclaration.item()</strong></p> <p><code>CSSStyleDeclaration.item</code>方法接受一个整数值作为参数，返回该位置的 CSS 属性名。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;/&gt;
var style = document.getElementById('myDiv').style;
style.item(0) // &quot;color&quot;
style.item(1) // &quot;background-color&quot;
</code></pre></div><p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p> <p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p> <p><strong>（4）CSSStyleDeclaration.removeProperty()</strong></p> <p><code>CSSStyleDeclaration.removeProperty</code>方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;
//   111
// &lt;/div&gt;
var style = document.getElementById('myDiv').style;
style.removeProperty('color') // 'red'
// HTML 代码变为
// &lt;div id=&quot;myDiv&quot; style=&quot;background-color: white;&quot;&gt;
</code></pre></div><p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p> <p><strong>（5）CSSStyleDeclaration.setProperty()</strong></p> <p><code>CSSStyleDeclaration.setProperty</code>方法用来设置新的 CSS 属性。该方法没有返回值。</p> <p>该方法可以接受三个参数。</p> <ul><li>第一个参数：属性名，该参数是必需的。</li> <li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li> <li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;
//   111
// &lt;/div&gt;
var style = document.getElementById('myDiv').style;
style.setProperty('border', '1px solid blue');
</code></pre></div><p>上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</p> <h3 id="css-模块的侦测"><a href="#css-模块的侦测" class="header-anchor">#</a> CSS 模块的侦测</h3> <p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</p> <p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof element.style.animationName === 'string';
typeof element.style.transform === 'string';
</code></pre></div><p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.style['maxWidth'] // &quot;&quot;
document.body.style['maximumWidth'] // undefined
</code></pre></div><p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p> <p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p> <div class="language- extra-class"><pre class="language-text"><code>document.body.style['backgroundColor'] // &quot;&quot;
document.body.style['background-color'] // &quot;&quot;
</code></pre></div><p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p> <div class="language- extra-class"><pre class="language-text"><code>var content = document.getElementById('content');
typeof content.style['webkitAnimation'] === 'string'
</code></pre></div><p>这种侦测方法可以写成一个函数。</p> <div class="language- extra-class"><pre class="language-text"><code>function isPropertySupported(property) {
  if (property in document.body.style) return true;
  var prefixes = ['Moz', 'Webkit', 'O', 'ms', 'Khtml'];
  var prefProperty = property.charAt(0).toUpperCase() + property.substr(1);

  for(var i = 0; i &lt; prefixes.length; i++){
    if((prefixes[i] + prefProperty) in document.body.style) return true;
  }

  return false;
}

isPropertySupported('background-clip')
// true
</code></pre></div><h3 id="css-对象"><a href="#css-对象" class="header-anchor">#</a> CSS 对象</h3> <p>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。</p> <p>这个对象目前有两个静态方法。</p> <h4 id="css-escape"><a href="#css-escape" class="header-anchor">#</a> CSS.escape()</h4> <p><code>CSS.escape</code>方法用于转义 CSS 选择器里面的特殊字符。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;foo#bar&quot;&gt;
</code></pre></div><p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector('#foo#bar')</code>，只能写成<code>document.querySelector('#foo\\#bar')</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p> <p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p> <div class="language- extra-class"><pre class="language-text"><code>document.querySelector('#' + CSS.escape('foo#bar'))
</code></pre></div><h4 id="css-supports"><a href="#css-supports" class="header-anchor">#</a> CSS.supports()</h4> <p><code>CSS.supports</code>方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。</p> <p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p> <div class="language- extra-class"><pre class="language-text"><code>// 第一种写法
CSS.supports('transform-origin', '5px') // true

// 第二种写法
CSS.supports('display: table-cell') // true
</code></pre></div><p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p> <div class="language- extra-class"><pre class="language-text"><code>CSS.supports('display: table-cell;') // false
</code></pre></div><h3 id="window-getcomputedstyle"><a href="#window-getcomputedstyle" class="header-anchor">#</a> window.getComputedStyle()</h3> <p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p> <p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.querySelector('div');
var styleObj = window.getComputedStyle(div);
styleObj.backgroundColor
</code></pre></div><p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p> <p>注意，CSSStyleDeclaration 实例是一个活的对象，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是只读的。</p> <p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p> <div class="language- extra-class"><pre class="language-text"><code>var result = window.getComputedStyle(div, ':before');
</code></pre></div><p>下面的例子是如何获取元素的高度。</p> <div class="language- extra-class"><pre class="language-text"><code>var elem = document.getElementById('elem-container');
var styleObj = window.getComputedStyle(elem, null)
var height = styleObj.height;
// 等同于
var height = styleObj['height'];
var height = styleObj.getPropertyValue('height');
</code></pre></div><p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p> <p>有几点需要注意。</p> <ul><li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括<code>px</code>后缀），颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式。</li> <li>CSS 规则的简写形式无效。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li> <li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj['z-index']</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li> <li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li></ul> <h3 id="css-伪元素"><a href="#css-伪元素" class="header-anchor">#</a> CSS 伪元素</h3> <p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p> <p>下面是一段 HTML 代码。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;Test content&lt;/div&gt;
</code></pre></div><p>CSS 添加伪元素<code>:before</code>的写法如下。</p> <div class="language- extra-class"><pre class="language-text"><code>#test:before {
  content: 'Before ';
  color: #FF0;
}
</code></pre></div><p>节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>。JavaScript 获取伪元素，可以使用下面的方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var test = document.querySelector('#test');

var result = window.getComputedStyle(test, ':before').content;
var color = window.getComputedStyle(test, ':before').color;
</code></pre></div><p>此外，也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法，获取伪元素的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var result = window.getComputedStyle(test, ':before')
  .getPropertyValue('content');
var color = window.getComputedStyle(test, ':before')
  .getPropertyValue('color');
</code></pre></div><h3 id="stylesheet-接口"><a href="#stylesheet-接口" class="header-anchor">#</a> StyleSheet 接口</h3> <h4 id="概述-6"><a href="#概述-6" class="header-anchor">#</a> 概述</h4> <p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code>&lt;style&gt;</code>元素内嵌的样式表。</p> <p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>实例（即所有样式表）。它是一个类似数组的对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var sheets = document.styleSheets;
var sheet = document.styleSheets[0];
sheet instanceof StyleSheet // true
</code></pre></div><p>如果是<code>&lt;style&gt;</code>元素嵌入的样式表，还有另一种获取<code>StyleSheet</code>实例的方法，就是这个节点元素的<code>sheet</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为 &lt;style id=&quot;myStyle&quot;&gt;&lt;/style&gt;
var myStyleSheet = document.getElementById('myStyle').sheet;
myStyleSheet instanceof StyleSheet // true
</code></pre></div><p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类<code>CSSStyleSheet</code>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个子接口继承了<code>StyleSheet</code>的所有属性和方法，并且定义了几个自己的属性，下面把这两个接口放在一起介绍。</p> <h4 id="实例属性-2"><a href="#实例属性-2" class="header-anchor">#</a> 实例属性</h4> <p><code>StyleSheet</code>实例有以下属性。</p> <p><strong>（1）StyleSheet.disabled</strong></p> <p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在<code>&lt;link&gt;</code>元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p> <p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p> <p><strong>（2）Stylesheet.href</strong></p> <p><code>Stylesheet.href</code>返回样式表的网址。对于内嵌样式表，该属性返回<code>null</code>。该属性只读。</p> <div class="language- extra-class"><pre class="language-text"><code>document.styleSheets[0].href
</code></pre></div><p><strong>（3）StyleSheet.media</strong></p> <p><code>StyleSheet.media</code>属性返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。表示当前样式表是用于屏幕（screen），还是用于打印（print）或手持设备（handheld），或各种媒介都适用（all）。该属性只读，默认值是<code>screen</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.styleSheets[0].media.mediaText
// &quot;all&quot;
</code></pre></div><p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p> <div class="language- extra-class"><pre class="language-text"><code>document.styleSheets[0].media.appendMedium('handheld');
document.styleSheets[0].media.deleteMedium('print');
</code></pre></div><p><strong>（4）StyleSheet.title</strong></p> <p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p> <p><strong>（5）StyleSheet.type</strong></p> <p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>document.styleSheets[0].type  // &quot;text/css&quot;
</code></pre></div><p><strong>（6）StyleSheet.parentStyleSheet</strong></p> <p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if (stylesheet.parentStyleSheet) {
  sheet = stylesheet.parentStyleSheet;
} else {
  sheet = stylesheet;
}
</code></pre></div><p><strong>（7）StyleSheet.ownerNode</strong></p> <p><code>StyleSheet.ownerNode</code>属性返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML代码为
// &lt;link rel=&quot;StyleSheet&quot; href=&quot;example.css&quot; type=&quot;text/css&quot; /&gt;
document.styleSheets[0].ownerNode // [object HTMLLinkElement]
</code></pre></div><p><strong>（8）CSSStyleSheet.cssRules</strong></p> <p><code>CSSStyleSheet.cssRules</code>属性指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var sheet = document.querySelector('#styleElement').sheet;

sheet.cssRules[0].cssText
// &quot;body { background-color: red; margin: 20px; }&quot;

sheet.cssRules[1].cssText
// &quot;p { line-height: 1.4em; color: blue; }&quot;
</code></pre></div><p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来读写具体的 CSS 命令。</p> <div class="language- extra-class"><pre class="language-text"><code>cssStyleSheet.cssRules[0].style.color = 'red';
cssStyleSheet.cssRules[1].style.color = 'purple';
</code></pre></div><p><strong>（9）CSSStyleSheet.ownerRule</strong></p> <p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p> <h4 id="实例方法-2"><a href="#实例方法-2" class="header-anchor">#</a> 实例方法</h4> <p><strong>（1）CSSStyleSheet.insertRule()</strong></p> <p><code>CSSStyleSheet.insertRule</code>方法用于在当前样式表的插入一个新的 CSS 规则。</p> <div class="language- extra-class"><pre class="language-text"><code>var sheet = document.querySelector('#styleElement').sheet;
sheet.insertRule('#block { color: white }', 0);
sheet.insertRule('p { color: red }', 1);
</code></pre></div><p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p> <p>该方法的返回值是新插入规则的位置序号。</p> <p>注意，浏览器对脚本在样式表里面插入规则有很多<a href="https://drafts.csswg.org/cssom/#insert-a-css-rule" target="_blank" rel="noopener noreferrer">限制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。所以，这个方法最好放在<code>try...catch</code>里使用。</p> <p><strong>（2）CSSStyleSheet.deleteRule()</strong></p> <p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>document.styleSheets[0].deleteRule(1);
</code></pre></div><h3 id="实例-添加样式表"><a href="#实例-添加样式表" class="header-anchor">#</a> 实例：添加样式表</h3> <p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code>&lt;style&gt;</code>节点。</p> <div class="language- extra-class"><pre class="language-text"><code>// 写法一
var style = document.createElement('style');
style.setAttribute('media', 'screen');
style.innerHTML = 'body{color:red}';
document.head.appendChild(style);

// 写法二
var style = (function () {
  var style = document.createElement('style');
  document.head.appendChild(style);
  return style;
})();
style.sheet.insertRule('.foo{color:red;}', 0);
</code></pre></div><p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的 URL。</p> <div class="language- extra-class"><pre class="language-text"><code>var linkElm = document.createElement('link');
linkElm.setAttribute('rel', 'stylesheet');
linkElm.setAttribute('type', 'text/css');
linkElm.setAttribute('href', 'reset-min.css');

document.head.appendChild(linkElm);
</code></pre></div><h3 id="cssrulelist-接口"><a href="#cssrulelist-接口" class="header-anchor">#</a> CSSRuleList 接口</h3> <p>CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。</p> <p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;style id=&quot;myStyle&quot;&gt;
//   h1 { color: red; }
//   p { color: blue; }
// &lt;/style&gt;
var myStyleSheet = document.getElementById('myStyle').sheet;
var crl = myStyleSheet.cssRules;
crl instanceof CSSRuleList // true
</code></pre></div><p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>crl[0] instanceof CSSRule // true
crl.length // 2
</code></pre></div><p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p> <h3 id="cssrule-接口"><a href="#cssrule-接口" class="header-anchor">#</a> CSSRule 接口</h3> <h4 id="概述-7"><a href="#概述-7" class="header-anchor">#</a> 概述</h4> <p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p> <div class="language- extra-class"><pre class="language-text"><code>.myClass {
  color: red;
  background-color: yellow;
}
</code></pre></div><p>JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;style id=&quot;myStyle&quot;&gt;
//   .myClass {
//     color: red;
//     background-color: yellow;
//   }
// &lt;/style&gt;
var myStyleSheet = document.getElementById('myStyle').sheet;
var ruleList = myStyleSheet.cssRules;
var rule = ruleList[0];
rule instanceof CSSRule // true
</code></pre></div><h4 id="cssrule-实例的属性"><a href="#cssrule-实例的属性" class="header-anchor">#</a> CSSRule 实例的属性</h4> <p><strong>（1）CSSRule.cssText</strong></p> <p><code>CSSRule.cssText</code>属性返回当前规则的文本，还是使用上面的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>rule.cssText
// &quot;.myClass { color: red; background-color: yellow; }&quot;
</code></pre></div><p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import 'url'</code>。</p> <p><strong>（2）CSSRule.parentStyleSheet</strong></p> <p><code>CSSRule.parentStyleSheet</code>属性返回当前规则所在的样式表对象（StyleSheet 实例），还是使用上面的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>rule.parentStyleSheet === myStyleSheet // true
</code></pre></div><p><strong>（3）CSSRule.parentRule</strong></p> <p><code>CSSRule.parentRule</code>属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</p> <p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;style id=&quot;myStyle&quot;&gt;
//   @supports (display: flex) {
//     @media screen and (min-width: 900px) {
//       article {
//         display: flex;
//       }
//     }
//  }
// &lt;/style&gt;
var myStyleSheet = document.getElementById('myStyle').sheet;
var ruleList = myStyleSheet.cssRules;

var rule0 = ruleList[0];
rule0.cssText
// &quot;@supports (display: flex) {
//    @media screen and (min-width: 900px) {
//      article { display: flex; }
//    }
// }&quot;

// 由于这条规则内嵌其他规则，
// 所以它有 cssRules 属性，且该属性是 CSSRuleList 实例
rule0.cssRules instanceof CSSRuleList // true

var rule1 = rule0.cssRules[0];
rule1.cssText
// &quot;@media screen and (min-width: 900px) {
//   article { display: flex; }
// }&quot;

var rule2 = rule1.cssRules[0];
rule2.cssText
// &quot;article { display: flex; }&quot;

rule1.parentRule === rule0 // true
rule2.parentRule === rule1 // true
</code></pre></div><p><strong>（4）CSSRule.type</strong></p> <p><code>CSSRule.type</code>属性返回一个整数值，表示当前规则的类型。</p> <p>最常见的类型有以下几种。</p> <ul><li>1：普通样式规则（CSSStyleRule 实例）</li> <li>3：<code>@import</code>规则</li> <li>4：<code>@media</code>规则（CSSMediaRule 实例）</li> <li>5：<code>@font-face</code>规则</li></ul> <h4 id="cssstylerule-接口"><a href="#cssstylerule-接口" class="header-anchor">#</a> CSSStyleRule 接口</h4> <p>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</p> <p>CSSStyleRule 接口有以下两个属性。</p> <p><strong>（1）CSSStyleRule.selectorText</strong></p> <p><code>CSSStyleRule.selectorText</code>属性返回当前规则的选择器。</p> <div class="language- extra-class"><pre class="language-text"><code>var stylesheet = document.styleSheets[0];
stylesheet.cssRules[0].selectorText // &quot;.myClass&quot;
</code></pre></div><p>注意，这个属性是可写的。</p> <p><strong>（2）CSSStyleRule.style</strong></p> <p><code>CSSStyleRule.style</code>属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码为
// &lt;style id=&quot;myStyle&quot;&gt;
//   p { color: red; }
// &lt;/style&gt;
var styleSheet = document.getElementById('myStyle').sheet;
styleSheet.cssRules[0].style instanceof CSSStyleDeclaration
// true
</code></pre></div><p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>styleSheet.cssRules[0].style.cssText
// &quot;color: red;&quot;
styleSheet.cssRules[0].selectorText
// &quot;p&quot;
</code></pre></div><h4 id="cssmediarule-接口"><a href="#cssmediarule-接口" class="header-anchor">#</a> CSSMediaRule 接口</h4> <p>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</p> <p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;style id=&quot;myStyle&quot;&gt;
//   @media screen and (min-width: 900px) {
//     article { display: flex; }
//   }
// &lt;/style&gt;
var styleSheet = document.getElementById('myStyle').sheet;
styleSheet.cssRules[0] instanceof CSSMediaRule
// true

styleSheet.cssRules[0].media
//  {
//    0: &quot;screen and (min-width: 900px)&quot;,
//    appendMedium: function,
//    deleteMedium: function,
//    item: function,
//    length: 1,
//    mediaText: &quot;screen and (min-width: 900px)&quot;
// }

styleSheet.cssRules[0].conditionText
// &quot;screen and (min-width: 900px)&quot;
</code></pre></div><h3 id="window-matchmedia"><a href="#window-matchmedia" class="header-anchor">#</a> window.matchMedia()</h3> <h4 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h4> <p><code>window.matchMedia()</code>方法用来将 CSS 的<a href="https://developer.mozilla.org/en-US/docs/DOM/Using_media_queries_from_code" target="_blank" rel="noopener noreferrer"><code>Media Query</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>条件语句，转换成一个 MediaQueryList 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var mdl = window.matchMedia('(min-width: 400px)');
mdl instanceof MediaQueryList // true
</code></pre></div><p>上面代码中，变量<code>mdl</code>就是 mediaQueryList 的实例。</p> <p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>window.matchMedia('bad string') instanceof MediaQueryList // true
</code></pre></div><h4 id="mediaquerylist-接口的实例属性"><a href="#mediaquerylist-接口的实例属性" class="header-anchor">#</a> MediaQueryList 接口的实例属性</h4> <p>MediaQueryList 实例有三个属性。</p> <p><strong>（1）MediaQueryList.media</strong></p> <p><code>MediaQueryList.media</code>属性返回一个字符串，表示对应的 MediaQuery 条件语句。</p> <div class="language- extra-class"><pre class="language-text"><code>var mql = window.matchMedia('(min-width: 400px)');
mql.media // &quot;(min-width: 400px)&quot;
</code></pre></div><p><strong>（2）MediaQueryList.matches</strong></p> <p><code>MediaQueryList.matches</code>属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。</p> <div class="language- extra-class"><pre class="language-text"><code>if (window.matchMedia('(min-width: 400px)').matches) {
  /* 当前视口不小于 400 像素 */
} else {
  /* 当前视口小于 400 像素 */
}
</code></pre></div><p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表。</p> <div class="language- extra-class"><pre class="language-text"><code>var result = window.matchMedia(&quot;(max-width: 700px)&quot;);

if (result.matches){
  var linkElm = document.createElement('link');
  linkElm.setAttribute('rel', 'stylesheet');
  linkElm.setAttribute('type', 'text/css');
  linkElm.setAttribute('href', 'small.css');

  document.head.appendChild(linkElm);
}
</code></pre></div><p><strong>（3）MediaQueryList.onchange</strong></p> <p>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var mql = window.matchMedia('(max-width: 600px)');

mql.onchange = function(e) {
  if (e.matches) {
    /* 视口不超过 600 像素 */
  } else {
    /* 视口超过 600 像素 */
  }
}
</code></pre></div><p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从600像素以上变为以下，另一种是从600像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p> <h4 id="mediaquerylist-接口的实例方法"><a href="#mediaquerylist-接口的实例方法" class="header-anchor">#</a> MediaQueryList 接口的实例方法</h4> <p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，用来为<code>change</code>事件添加或撤销监听函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var mql = window.matchMedia('(max-width: 600px)');

// 指定监听函数
mql.addListener(mqCallback);

// 撤销监听函数
mql.removeListener(mqCallback);

function mqCallback(e) {
  if (e.matches) {
    /* 视口不超过 600 像素 */
  } else {
    /* 视口超过 600 像素 */
  }
}
</code></pre></div><p>注意，<code>MediaQueryList.removeListener()</code>方法不能撤销<code>MediaQueryList.onchange</code>属性指定的监听函数。</p> <h2 id="mutation-observer-api"><a href="#mutation-observer-api" class="header-anchor">#</a> Mutation Observer API</h2> <h3 id="概述-8"><a href="#概述-8" class="header-anchor">#</a> 概述</h3> <p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p> <p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p> <p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个<code>&lt;p&gt;</code>元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p> <p>Mutation Observer 有以下特点。</p> <ul><li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li> <li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li> <li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li></ul> <h3 id="mutationobserver-构造函数"><a href="#mutationobserver-构造函数" class="header-anchor">#</a> MutationObserver 构造函数</h3> <p>使用时，首先使用<code>MutationObserver</code>构造函数，新建一个观察器实例，同时指定这个实例的回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var observer = new MutationObserver(callback);
</code></pre></div><p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var observer = new MutationObserver(function (mutations, observer) {
  mutations.forEach(function(mutation) {
    console.log(mutation);
  });
});
</code></pre></div><h3 id="mutationobserver-的实例方法"><a href="#mutationobserver-的实例方法" class="header-anchor">#</a> MutationObserver 的实例方法</h3> <h4 id="observe"><a href="#observe" class="header-anchor">#</a> observe()</h4> <p><code>observe()</code>方法用来启动监听，它接受两个参数。</p> <ul><li>第一个参数：所要观察的 DOM 节点</li> <li>第二个参数：一个配置对象，指定所要观察的特定变动</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var article = document.querySelector('article');

var  options = {
  'childList': true,
  'attributes':true
} ;

observer.observe(article, options);
</code></pre></div><p>上面代码中，<code>observe()</code>方法接受两个参数，第一个是所要观察的DOM元素是<code>article</code>，第二个是所要观察的变动类型（子节点变动和属性变动）。</p> <p>观察器所能观察的 DOM 变动类型（即上面代码的<code>options</code>对象），有以下几种。</p> <ul><li><strong>childList</strong>：子节点的变动（指新增，删除或者更改）。</li> <li><strong>attributes</strong>：属性的变动。</li> <li><strong>characterData</strong>：节点内容或节点文本的变动。</li></ul> <p>想要观察哪一种变动类型，就在<code>option</code>对象中指定它的值为<code>true</code>。需要注意的是，至少必须同时指定这三种观察的一种，若均未指定将报错。</p> <p>除了变动类型，<code>options</code>对象还可以设定以下属性：</p> <ul><li><code>subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li> <li><code>attributeOldValue</code>：布尔值，表示观察<code>attributes</code>变动时，是否需要记录变动前的属性值。</li> <li><code>characterDataOldValue</code>：布尔值，表示观察<code>characterData</code>变动时，是否需要记录变动前的值。</li> <li><code>attributeFilter</code>：数组，表示需要观察的特定属性（比如<code>['class','src']</code>）。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 开始监听文档根节点（即&lt;html&gt;标签）的变动
mutationObserver.observe(document.documentElement, {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true,
  attributeOldValue: true,
  characterDataOldValue: true
});
</code></pre></div><p>对一个节点添加观察器，就像使用<code>addEventListener()</code>方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。如果指定不同的<code>options</code>对象，以后面添加的那个为准，类似覆盖。</p> <p>下面的例子是观察新增的子节点。</p> <div class="language- extra-class"><pre class="language-text"><code>var insertedNodes = [];
var observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    for (var i = 0; i &lt; mutation.addedNodes.length; i++) {
      insertedNodes.push(mutation.addedNodes[i]);
    }
  });
  console.log(insertedNodes);
});
observer.observe(document, { childList: true, subtree: true });
</code></pre></div><h4 id="disconnect-takerecords"><a href="#disconnect-takerecords" class="header-anchor">#</a> disconnect()，takeRecords()</h4> <p><code>disconnect()</code>方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</p> <div class="language- extra-class"><pre class="language-text"><code>observer.disconnect();
</code></pre></div><p><code>takeRecords()</code>方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>observer.takeRecords();
</code></pre></div><p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>// 保存所有没有被观察器处理的变动
var changes = mutationObserver.takeRecords();

// 停止观察
mutationObserver.disconnect();
</code></pre></div><h3 id="mutationrecord-对象"><a href="#mutationrecord-对象" class="header-anchor">#</a> MutationRecord 对象</h3> <p>DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个<code>MutationRecord</code>实例所组成的数组。</p> <p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p> <ul><li><code>type</code>：观察的变动类型（<code>attributes</code>、<code>characterData</code>或者<code>childList</code>）。</li> <li><code>target</code>：发生变动的DOM节点。</li> <li><code>addedNodes</code>：新增的DOM节点。</li> <li><code>removedNodes</code>：删除的DOM节点。</li> <li><code>previousSibling</code>：前一个同级节点，如果没有则返回<code>null</code>。</li> <li><code>nextSibling</code>：下一个同级节点，如果没有则返回<code>null</code>。</li> <li><code>attributeName</code>：发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性。</li> <li><code>oldValue</code>：变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code>。</li></ul> <h3 id="应用示例"><a href="#应用示例" class="header-anchor">#</a> 应用示例</h3> <h4 id="子元素的变动"><a href="#子元素的变动" class="header-anchor">#</a> 子元素的变动</h4> <p>下面的例子说明如何读取变动记录。</p> <div class="language- extra-class"><pre class="language-text"><code>var callback = function (records){
  records.map(function(record){
    console.log('Mutation type: ' + record.type);
    console.log('Mutation target: ' + record.target);
  });
};

var mo = new MutationObserver(callback);

var option = {
  'childList': true,
  'subtree': true
};

mo.observe(document.body, option);
</code></pre></div><p>上面代码的观察器，观察<code>&lt;body&gt;</code>的所有下级节点（<code>childList</code>表示观察子节点，<code>subtree</code>表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p> <h4 id="属性的变动"><a href="#属性的变动" class="header-anchor">#</a> 属性的变动</h4> <p>下面的例子说明如何追踪属性的变动。</p> <div class="language- extra-class"><pre class="language-text"><code>var callback = function (records) {
  records.map(function (record) {
    console.log('Previous attribute value: ' + record.oldValue);
  });
};

var mo = new MutationObserver(callback);

var element = document.getElementById('#my_element');

var options = {
  'attributes': true,
  'attributeOldValue': true
}

mo.observe(element, options);
</code></pre></div><p>上面代码先设定追踪属性变动（<code>'attributes': true</code>），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p> <h4 id="取代-domcontentloaded-事件"><a href="#取代-domcontentloaded-事件" class="header-anchor">#</a> 取代 DOMContentLoaded 事件</h4> <p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用<code>DOMContentLoaded</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>var observer = new MutationObserver(callback);
observer.observe(document.documentElement, {
  childList: true,
  subtree: true
});
</code></pre></div><p>上面代码中，监听<code>document.documentElement</code>（即网页的<code>&lt;html&gt;</code>HTML 节点）的子节点的变动，<code>subtree</code>属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p> <p>下面的代码，使用<code>MutationObserver</code>对象封装一个监听 DOM 生成的函数。</p> <div class="language- extra-class"><pre class="language-text"><code>(function(win){
  'use strict';

  var listeners = [];
  var doc = win.document;
  var MutationObserver = win.MutationObserver || win.WebKitMutationObserver;
  var observer;

  function ready(selector, fn){
    // 储存选择器和回调函数
    listeners.push({
      selector: selector,
      fn: fn
    });
    if(!observer){
      // 监听document变化
      observer = new MutationObserver(check);
      observer.observe(doc.documentElement, {
        childList: true,
        subtree: true
      });
    }
    // 检查该节点是否已经在DOM中
    check();
  }

  function check(){
  // 检查是否匹配已储存的节点
    for(var i = 0; i &lt; listeners.length; i++){
      var listener = listeners[i];
      // 检查指定节点是否有匹配
      var elements = doc.querySelectorAll(listener.selector);
      for(var j = 0; j &lt; elements.length; j++){
        var element = elements[j];
        // 确保回调函数只会对该元素调用一次
        if(!element.ready){
          element.ready = true;
          // 对该节点调用回调函数
          listener.fn.call(element, element);
        }
      }
    }
  }

  // 对外暴露ready
  win.ready = ready;

})(this);

// 使用方法
ready('.foo', function(element){
  // ...
});
</code></pre></div><h3 id="参考链接-2"><a href="#参考链接-2" class="header-anchor">#</a> 参考链接</h3> <ul><li>Paul Kinlan, <a href="https://developers.google.com/web/updates/2012/02/Detect-DOM-changes-with-Mutation-Observers" target="_blank" rel="noopener noreferrer">Detect DOM changes with Mutation Observers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Tiffany Brown, <a href="https://dev.opera.com/articles/view/mutation-observers-tutorial/" target="_blank" rel="noopener noreferrer">Getting to know mutation observers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Michal Budzynski, <a href="https://michalbe.blogspot.com/2013/04/javascript-less-known-parts-dom.html" target="_blank" rel="noopener noreferrer">JavaScript: The less known parts. DOM Mutations<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Jeff Griffiths, <a href="https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/" target="_blank" rel="noopener noreferrer">DOM MutationObserver – reacting to DOM changes without killing browser performance<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Addy Osmani, <a href="http://addyosmani.com/blog/mutation-observers/" target="_blank" rel="noopener noreferrer">Detect, Undo And Redo DOM Changes With Mutation Observers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Ryan Morr, <a href="http://ryanmorr.com/using-mutation-observers-to-watch-for-element-availability/" target="_blank" rel="noopener noreferrer">Using Mutation Observers to Watch for Element Availability<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/01/15, 11:11:38</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/73df15/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">异步操作</div></a> <a href="/pages/329076/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">事件</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/73df15/" class="prev">异步操作</a></span> <span class="next"><a href="/pages/329076/">事件</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/610238/"><div>浏览器模型(四)</div></a> <span>12-12</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/229568/"><div>浏览器模型(一)</div></a> <span>12-11</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/ffb0a1/"><div>浏览器模型(二)</div></a> <span>12-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1390128154@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wuKongNotNull" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2022
    <span>悟空非空也 | <a href="https://github.com/WuKongNotNull/wukong-post/blob/main/LICENSE" target="_blank">Apache License 2.0</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0772105c.js" defer></script><script src="/assets/js/2.6497fd29.js" defer></script><script src="/assets/js/216.4045669d.js" defer></script>
  </body>
</html>