<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器模型(三) | 悟空非空也</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="keywords" content="集成计算机编程技术博客、知识库、学习笔记文档、技术网站导航、资源收藏、技术电子书、论坛于一体。涵盖JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github，Java,C,C++,Php,大数据，人工智能，云计算，机器深度学习和算法等技术文章和资源。">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.4a9c0c84.css" as="style"><link rel="preload" href="/assets/js/app.0772105c.js" as="script"><link rel="preload" href="/assets/js/2.6497fd29.js" as="script"><link rel="preload" href="/assets/js/220.5c5efc16.js" as="script"><link rel="prefetch" href="/assets/js/10.0a7a5c2a.js"><link rel="prefetch" href="/assets/js/100.6dd9a587.js"><link rel="prefetch" href="/assets/js/101.b1cb7166.js"><link rel="prefetch" href="/assets/js/102.6a888436.js"><link rel="prefetch" href="/assets/js/103.075294d1.js"><link rel="prefetch" href="/assets/js/104.7f9d5a4c.js"><link rel="prefetch" href="/assets/js/105.bcc3dd3e.js"><link rel="prefetch" href="/assets/js/106.9cadb287.js"><link rel="prefetch" href="/assets/js/107.1d6b3af1.js"><link rel="prefetch" href="/assets/js/108.7377cb7f.js"><link rel="prefetch" href="/assets/js/109.ca3ceab0.js"><link rel="prefetch" href="/assets/js/11.961408a3.js"><link rel="prefetch" href="/assets/js/110.79c5c987.js"><link rel="prefetch" href="/assets/js/111.63b3d196.js"><link rel="prefetch" href="/assets/js/112.ced4f0e9.js"><link rel="prefetch" href="/assets/js/113.657daa4e.js"><link rel="prefetch" href="/assets/js/114.e5d0a86b.js"><link rel="prefetch" href="/assets/js/115.a89005f0.js"><link rel="prefetch" href="/assets/js/116.bcbccecc.js"><link rel="prefetch" href="/assets/js/117.7acf9f16.js"><link rel="prefetch" href="/assets/js/118.75e4e713.js"><link rel="prefetch" href="/assets/js/119.0395ec5d.js"><link rel="prefetch" href="/assets/js/12.aab67183.js"><link rel="prefetch" href="/assets/js/120.93179733.js"><link rel="prefetch" href="/assets/js/121.e80fc142.js"><link rel="prefetch" href="/assets/js/122.41a175f0.js"><link rel="prefetch" href="/assets/js/123.028fd9cd.js"><link rel="prefetch" href="/assets/js/124.100b1fb0.js"><link rel="prefetch" href="/assets/js/125.13d51556.js"><link rel="prefetch" href="/assets/js/126.02c987a2.js"><link rel="prefetch" href="/assets/js/127.f7e115fe.js"><link rel="prefetch" href="/assets/js/128.eb930737.js"><link rel="prefetch" href="/assets/js/129.29fef1d1.js"><link rel="prefetch" href="/assets/js/13.7dd23d29.js"><link rel="prefetch" href="/assets/js/130.7e4c3bbc.js"><link rel="prefetch" href="/assets/js/131.16f04a03.js"><link rel="prefetch" href="/assets/js/132.c811b5cf.js"><link rel="prefetch" href="/assets/js/133.4a0d2ee8.js"><link rel="prefetch" href="/assets/js/134.aa288243.js"><link rel="prefetch" href="/assets/js/135.7d74b67e.js"><link rel="prefetch" href="/assets/js/136.f6a4d7dc.js"><link rel="prefetch" href="/assets/js/137.4a8c94fa.js"><link rel="prefetch" href="/assets/js/138.30103e18.js"><link rel="prefetch" href="/assets/js/139.cb62e822.js"><link rel="prefetch" href="/assets/js/14.7a045a57.js"><link rel="prefetch" href="/assets/js/140.4849d011.js"><link rel="prefetch" href="/assets/js/141.b53f0217.js"><link rel="prefetch" href="/assets/js/142.d2e12f6f.js"><link rel="prefetch" href="/assets/js/143.41effcfd.js"><link rel="prefetch" href="/assets/js/144.5ed3025f.js"><link rel="prefetch" href="/assets/js/145.ec71ac40.js"><link rel="prefetch" href="/assets/js/146.dc482dc8.js"><link rel="prefetch" href="/assets/js/147.f43c3786.js"><link rel="prefetch" href="/assets/js/148.e60884a5.js"><link rel="prefetch" href="/assets/js/149.fd305860.js"><link rel="prefetch" href="/assets/js/15.b07b6e42.js"><link rel="prefetch" href="/assets/js/150.e294561d.js"><link rel="prefetch" href="/assets/js/151.5cda3c43.js"><link rel="prefetch" href="/assets/js/152.ec1bec3f.js"><link rel="prefetch" href="/assets/js/153.411bc769.js"><link rel="prefetch" href="/assets/js/154.d0b70cd8.js"><link rel="prefetch" href="/assets/js/155.8013985e.js"><link rel="prefetch" href="/assets/js/156.9e9c91f4.js"><link rel="prefetch" href="/assets/js/157.0273d672.js"><link rel="prefetch" href="/assets/js/158.2612db04.js"><link rel="prefetch" href="/assets/js/159.9942bd3a.js"><link rel="prefetch" href="/assets/js/16.511be8ae.js"><link rel="prefetch" href="/assets/js/160.69e027a9.js"><link rel="prefetch" href="/assets/js/161.3d0255ab.js"><link rel="prefetch" href="/assets/js/162.4f223488.js"><link rel="prefetch" href="/assets/js/163.aca282a2.js"><link rel="prefetch" href="/assets/js/164.68c99b46.js"><link rel="prefetch" href="/assets/js/165.f455fb7b.js"><link rel="prefetch" href="/assets/js/166.a4d94e8d.js"><link rel="prefetch" href="/assets/js/167.dad8c77e.js"><link rel="prefetch" href="/assets/js/168.cb0717be.js"><link rel="prefetch" href="/assets/js/169.61a9bd6a.js"><link rel="prefetch" href="/assets/js/17.bbcfeede.js"><link rel="prefetch" href="/assets/js/170.f3785783.js"><link rel="prefetch" href="/assets/js/171.238d90d3.js"><link rel="prefetch" href="/assets/js/172.63852414.js"><link rel="prefetch" href="/assets/js/173.613fce9e.js"><link rel="prefetch" href="/assets/js/174.761ee99c.js"><link rel="prefetch" href="/assets/js/175.f2953a9b.js"><link rel="prefetch" href="/assets/js/176.415405fd.js"><link rel="prefetch" href="/assets/js/177.5c3782be.js"><link rel="prefetch" href="/assets/js/178.7c081109.js"><link rel="prefetch" href="/assets/js/179.038faa2b.js"><link rel="prefetch" href="/assets/js/18.c6108eaa.js"><link rel="prefetch" href="/assets/js/180.f498ca2e.js"><link rel="prefetch" href="/assets/js/181.ec14688f.js"><link rel="prefetch" href="/assets/js/182.1279a689.js"><link rel="prefetch" href="/assets/js/183.ced575fe.js"><link rel="prefetch" href="/assets/js/184.34f3c06c.js"><link rel="prefetch" href="/assets/js/185.b3d1acb8.js"><link rel="prefetch" href="/assets/js/186.b6efd99e.js"><link rel="prefetch" href="/assets/js/187.9b3f72f6.js"><link rel="prefetch" href="/assets/js/188.2e66f79c.js"><link rel="prefetch" href="/assets/js/189.4d12400d.js"><link rel="prefetch" href="/assets/js/19.192ec262.js"><link rel="prefetch" href="/assets/js/190.e353d2e5.js"><link rel="prefetch" href="/assets/js/191.7d655069.js"><link rel="prefetch" href="/assets/js/192.c33b286e.js"><link rel="prefetch" href="/assets/js/193.c9f461d3.js"><link rel="prefetch" href="/assets/js/194.32fdc071.js"><link rel="prefetch" href="/assets/js/195.03c708fc.js"><link rel="prefetch" href="/assets/js/196.54c890cf.js"><link rel="prefetch" href="/assets/js/197.68d0761d.js"><link rel="prefetch" href="/assets/js/198.efdf4f70.js"><link rel="prefetch" href="/assets/js/199.abaad0a6.js"><link rel="prefetch" href="/assets/js/20.d04c28bc.js"><link rel="prefetch" href="/assets/js/200.bd80bb59.js"><link rel="prefetch" href="/assets/js/201.4316ce7c.js"><link rel="prefetch" href="/assets/js/202.182fb8ad.js"><link rel="prefetch" href="/assets/js/203.7c514243.js"><link rel="prefetch" href="/assets/js/204.622bbe90.js"><link rel="prefetch" href="/assets/js/205.28f69f06.js"><link rel="prefetch" href="/assets/js/206.0c4c24eb.js"><link rel="prefetch" href="/assets/js/207.ea976c79.js"><link rel="prefetch" href="/assets/js/208.c4f49e55.js"><link rel="prefetch" href="/assets/js/209.4e2dacde.js"><link rel="prefetch" href="/assets/js/21.d8b6c127.js"><link rel="prefetch" href="/assets/js/210.c5ddee43.js"><link rel="prefetch" href="/assets/js/211.2db8e6bf.js"><link rel="prefetch" href="/assets/js/212.9e5c2afe.js"><link rel="prefetch" href="/assets/js/213.9fc56fcc.js"><link rel="prefetch" href="/assets/js/214.b22b8fd0.js"><link rel="prefetch" href="/assets/js/215.b714511d.js"><link rel="prefetch" href="/assets/js/216.4045669d.js"><link rel="prefetch" href="/assets/js/217.b8bfc481.js"><link rel="prefetch" href="/assets/js/218.4cc6231a.js"><link rel="prefetch" href="/assets/js/219.b04f0864.js"><link rel="prefetch" href="/assets/js/22.a21d9c67.js"><link rel="prefetch" href="/assets/js/221.b3cc4226.js"><link rel="prefetch" href="/assets/js/222.14568620.js"><link rel="prefetch" href="/assets/js/223.5ad9c326.js"><link rel="prefetch" href="/assets/js/224.bef27670.js"><link rel="prefetch" href="/assets/js/225.7e76ba96.js"><link rel="prefetch" href="/assets/js/226.c892c0a5.js"><link rel="prefetch" href="/assets/js/227.1a5c5dfe.js"><link rel="prefetch" href="/assets/js/228.a83d26e3.js"><link rel="prefetch" href="/assets/js/229.f69558a4.js"><link rel="prefetch" href="/assets/js/23.e6bed599.js"><link rel="prefetch" href="/assets/js/230.975e6807.js"><link rel="prefetch" href="/assets/js/231.3323c121.js"><link rel="prefetch" href="/assets/js/232.69b5135e.js"><link rel="prefetch" href="/assets/js/233.f27782e6.js"><link rel="prefetch" href="/assets/js/234.c1e937f3.js"><link rel="prefetch" href="/assets/js/235.500694bc.js"><link rel="prefetch" href="/assets/js/236.6b6f2f84.js"><link rel="prefetch" href="/assets/js/237.a529e2ba.js"><link rel="prefetch" href="/assets/js/238.d5bca3eb.js"><link rel="prefetch" href="/assets/js/239.0b79bd7b.js"><link rel="prefetch" href="/assets/js/24.1be4b8e9.js"><link rel="prefetch" href="/assets/js/240.baec5139.js"><link rel="prefetch" href="/assets/js/241.eef96f93.js"><link rel="prefetch" href="/assets/js/242.8208455c.js"><link rel="prefetch" href="/assets/js/243.4c8fdc98.js"><link rel="prefetch" href="/assets/js/244.e11ee13c.js"><link rel="prefetch" href="/assets/js/245.b1e7beba.js"><link rel="prefetch" href="/assets/js/246.4c24ee87.js"><link rel="prefetch" href="/assets/js/247.f3958ef5.js"><link rel="prefetch" href="/assets/js/248.3f533151.js"><link rel="prefetch" href="/assets/js/249.6d80f1cd.js"><link rel="prefetch" href="/assets/js/25.7420391b.js"><link rel="prefetch" href="/assets/js/250.2faf865a.js"><link rel="prefetch" href="/assets/js/251.88d81ef7.js"><link rel="prefetch" href="/assets/js/252.04a6a69c.js"><link rel="prefetch" href="/assets/js/253.32528c6e.js"><link rel="prefetch" href="/assets/js/254.312c70ad.js"><link rel="prefetch" href="/assets/js/255.ff88a488.js"><link rel="prefetch" href="/assets/js/256.8b782088.js"><link rel="prefetch" href="/assets/js/257.1e04db72.js"><link rel="prefetch" href="/assets/js/258.6b8e65a8.js"><link rel="prefetch" href="/assets/js/259.c1a78951.js"><link rel="prefetch" href="/assets/js/26.b979a08f.js"><link rel="prefetch" href="/assets/js/260.2910b3b5.js"><link rel="prefetch" href="/assets/js/261.b3c9ff4f.js"><link rel="prefetch" href="/assets/js/262.a4846d38.js"><link rel="prefetch" href="/assets/js/263.2fe51a99.js"><link rel="prefetch" href="/assets/js/264.790ac186.js"><link rel="prefetch" href="/assets/js/265.2da80512.js"><link rel="prefetch" href="/assets/js/266.86531545.js"><link rel="prefetch" href="/assets/js/267.2d8df6ee.js"><link rel="prefetch" href="/assets/js/268.caf4f057.js"><link rel="prefetch" href="/assets/js/269.5cb1755d.js"><link rel="prefetch" href="/assets/js/27.46acb058.js"><link rel="prefetch" href="/assets/js/270.93b039ff.js"><link rel="prefetch" href="/assets/js/271.a83d9432.js"><link rel="prefetch" href="/assets/js/272.f957cb9b.js"><link rel="prefetch" href="/assets/js/273.00fda4c5.js"><link rel="prefetch" href="/assets/js/274.90d11b33.js"><link rel="prefetch" href="/assets/js/275.a5ab6a4b.js"><link rel="prefetch" href="/assets/js/276.e1553171.js"><link rel="prefetch" href="/assets/js/277.fc579c76.js"><link rel="prefetch" href="/assets/js/278.eecaef76.js"><link rel="prefetch" href="/assets/js/279.4ccbe5fd.js"><link rel="prefetch" href="/assets/js/28.d679a88b.js"><link rel="prefetch" href="/assets/js/280.1a2df8d1.js"><link rel="prefetch" href="/assets/js/281.4d879315.js"><link rel="prefetch" href="/assets/js/282.1a638b6e.js"><link rel="prefetch" href="/assets/js/283.35d77274.js"><link rel="prefetch" href="/assets/js/284.236f6c0d.js"><link rel="prefetch" href="/assets/js/285.f911dc9c.js"><link rel="prefetch" href="/assets/js/286.f2032fe0.js"><link rel="prefetch" href="/assets/js/287.47be0dd9.js"><link rel="prefetch" href="/assets/js/288.805d6e1e.js"><link rel="prefetch" href="/assets/js/289.af37d311.js"><link rel="prefetch" href="/assets/js/29.9fb32fde.js"><link rel="prefetch" href="/assets/js/290.cc34cbe3.js"><link rel="prefetch" href="/assets/js/291.887bcdbb.js"><link rel="prefetch" href="/assets/js/292.88848329.js"><link rel="prefetch" href="/assets/js/293.c5e4486a.js"><link rel="prefetch" href="/assets/js/294.4cc2aedf.js"><link rel="prefetch" href="/assets/js/295.1072aab8.js"><link rel="prefetch" href="/assets/js/296.1b0b3008.js"><link rel="prefetch" href="/assets/js/297.0f879887.js"><link rel="prefetch" href="/assets/js/298.516a7d92.js"><link rel="prefetch" href="/assets/js/299.a039e1fa.js"><link rel="prefetch" href="/assets/js/3.8f0b1c2b.js"><link rel="prefetch" href="/assets/js/30.49c708c9.js"><link rel="prefetch" href="/assets/js/300.d7f284d1.js"><link rel="prefetch" href="/assets/js/301.d0b1dd6f.js"><link rel="prefetch" href="/assets/js/302.4b55dd23.js"><link rel="prefetch" href="/assets/js/303.feb01496.js"><link rel="prefetch" href="/assets/js/304.3ab97c4d.js"><link rel="prefetch" href="/assets/js/305.591a1558.js"><link rel="prefetch" href="/assets/js/306.adb43a3c.js"><link rel="prefetch" href="/assets/js/307.b05d288b.js"><link rel="prefetch" href="/assets/js/308.4567d4af.js"><link rel="prefetch" href="/assets/js/309.72c51c16.js"><link rel="prefetch" href="/assets/js/31.11f8cedc.js"><link rel="prefetch" href="/assets/js/310.3962fc11.js"><link rel="prefetch" href="/assets/js/311.75aa7b05.js"><link rel="prefetch" href="/assets/js/312.9ec9fde7.js"><link rel="prefetch" href="/assets/js/313.d6f6baa3.js"><link rel="prefetch" href="/assets/js/314.86cdfa89.js"><link rel="prefetch" href="/assets/js/315.25959c53.js"><link rel="prefetch" href="/assets/js/316.8fa91955.js"><link rel="prefetch" href="/assets/js/317.4248ad4c.js"><link rel="prefetch" href="/assets/js/318.3f9ca0c5.js"><link rel="prefetch" href="/assets/js/319.32be3008.js"><link rel="prefetch" href="/assets/js/32.4e2e98b3.js"><link rel="prefetch" href="/assets/js/320.b8a7b72b.js"><link rel="prefetch" href="/assets/js/321.a3f7c1a6.js"><link rel="prefetch" href="/assets/js/322.d0903e0c.js"><link rel="prefetch" href="/assets/js/323.99520c43.js"><link rel="prefetch" href="/assets/js/324.333a4f10.js"><link rel="prefetch" href="/assets/js/325.e502b8f9.js"><link rel="prefetch" href="/assets/js/326.8e57faf4.js"><link rel="prefetch" href="/assets/js/327.f0473fc3.js"><link rel="prefetch" href="/assets/js/328.eaa4bf5f.js"><link rel="prefetch" href="/assets/js/329.dc0763f7.js"><link rel="prefetch" href="/assets/js/33.90114516.js"><link rel="prefetch" href="/assets/js/330.1f60cb6e.js"><link rel="prefetch" href="/assets/js/331.4af5e363.js"><link rel="prefetch" href="/assets/js/332.2a2023db.js"><link rel="prefetch" href="/assets/js/333.4c5db27a.js"><link rel="prefetch" href="/assets/js/334.f52a66e5.js"><link rel="prefetch" href="/assets/js/335.a6481538.js"><link rel="prefetch" href="/assets/js/336.6bd556c7.js"><link rel="prefetch" href="/assets/js/337.58a4d668.js"><link rel="prefetch" href="/assets/js/338.22095960.js"><link rel="prefetch" href="/assets/js/339.c8da6647.js"><link rel="prefetch" href="/assets/js/34.225b456c.js"><link rel="prefetch" href="/assets/js/340.9f93002f.js"><link rel="prefetch" href="/assets/js/341.721ab41d.js"><link rel="prefetch" href="/assets/js/342.f129aa89.js"><link rel="prefetch" href="/assets/js/343.ea2d2309.js"><link rel="prefetch" href="/assets/js/344.15235001.js"><link rel="prefetch" href="/assets/js/345.eaaae5e5.js"><link rel="prefetch" href="/assets/js/346.73b19ced.js"><link rel="prefetch" href="/assets/js/347.6e11bced.js"><link rel="prefetch" href="/assets/js/348.3b9b7968.js"><link rel="prefetch" href="/assets/js/349.b60a2b56.js"><link rel="prefetch" href="/assets/js/35.e3ec78ba.js"><link rel="prefetch" href="/assets/js/350.e793c7b9.js"><link rel="prefetch" href="/assets/js/351.c86b1ea0.js"><link rel="prefetch" href="/assets/js/352.770038d5.js"><link rel="prefetch" href="/assets/js/353.fe8f38a5.js"><link rel="prefetch" href="/assets/js/354.d3bbf169.js"><link rel="prefetch" href="/assets/js/355.5bb68a7e.js"><link rel="prefetch" href="/assets/js/356.b380aecd.js"><link rel="prefetch" href="/assets/js/357.24fbf1ff.js"><link rel="prefetch" href="/assets/js/358.669b8aba.js"><link rel="prefetch" href="/assets/js/359.04af7f75.js"><link rel="prefetch" href="/assets/js/36.dedb6e42.js"><link rel="prefetch" href="/assets/js/360.73d170d7.js"><link rel="prefetch" href="/assets/js/361.c1f55230.js"><link rel="prefetch" href="/assets/js/362.967bb47e.js"><link rel="prefetch" href="/assets/js/363.7b39c192.js"><link rel="prefetch" href="/assets/js/364.7dbf94dd.js"><link rel="prefetch" href="/assets/js/365.8a1d46d7.js"><link rel="prefetch" href="/assets/js/366.997ec05e.js"><link rel="prefetch" href="/assets/js/367.cda39f93.js"><link rel="prefetch" href="/assets/js/368.1159aebc.js"><link rel="prefetch" href="/assets/js/369.8371cbf0.js"><link rel="prefetch" href="/assets/js/37.129a1339.js"><link rel="prefetch" href="/assets/js/370.b5bda99f.js"><link rel="prefetch" href="/assets/js/371.ca4c4c31.js"><link rel="prefetch" href="/assets/js/372.6ecb7277.js"><link rel="prefetch" href="/assets/js/373.d3d1f018.js"><link rel="prefetch" href="/assets/js/374.4901bb51.js"><link rel="prefetch" href="/assets/js/375.ab11fdff.js"><link rel="prefetch" href="/assets/js/376.f34fed60.js"><link rel="prefetch" href="/assets/js/377.8d8aa0d5.js"><link rel="prefetch" href="/assets/js/378.16a432ff.js"><link rel="prefetch" href="/assets/js/379.68163d64.js"><link rel="prefetch" href="/assets/js/38.e0e2c3b1.js"><link rel="prefetch" href="/assets/js/39.a33bdbc2.js"><link rel="prefetch" href="/assets/js/4.d96ebf17.js"><link rel="prefetch" href="/assets/js/40.d20c1395.js"><link rel="prefetch" href="/assets/js/41.a2d6458f.js"><link rel="prefetch" href="/assets/js/42.48c0ea87.js"><link rel="prefetch" href="/assets/js/43.e2e765f4.js"><link rel="prefetch" href="/assets/js/44.10b67e66.js"><link rel="prefetch" href="/assets/js/45.2cd4b906.js"><link rel="prefetch" href="/assets/js/46.7a02c8ab.js"><link rel="prefetch" href="/assets/js/47.d88632c9.js"><link rel="prefetch" href="/assets/js/48.ade443fe.js"><link rel="prefetch" href="/assets/js/49.4d2ddb3b.js"><link rel="prefetch" href="/assets/js/5.037e08ba.js"><link rel="prefetch" href="/assets/js/50.463230b1.js"><link rel="prefetch" href="/assets/js/51.83c9a564.js"><link rel="prefetch" href="/assets/js/52.56c5a325.js"><link rel="prefetch" href="/assets/js/53.72a3b829.js"><link rel="prefetch" href="/assets/js/54.8f59548e.js"><link rel="prefetch" href="/assets/js/55.0faca6a3.js"><link rel="prefetch" href="/assets/js/56.77474658.js"><link rel="prefetch" href="/assets/js/57.4e4789fa.js"><link rel="prefetch" href="/assets/js/58.9dc82ebc.js"><link rel="prefetch" href="/assets/js/59.2147b861.js"><link rel="prefetch" href="/assets/js/6.8af55c48.js"><link rel="prefetch" href="/assets/js/60.d0ff683a.js"><link rel="prefetch" href="/assets/js/61.331527c3.js"><link rel="prefetch" href="/assets/js/62.a9085bf0.js"><link rel="prefetch" href="/assets/js/63.ecaf766f.js"><link rel="prefetch" href="/assets/js/64.f9a1f00a.js"><link rel="prefetch" href="/assets/js/65.69eef128.js"><link rel="prefetch" href="/assets/js/66.7ce420d5.js"><link rel="prefetch" href="/assets/js/67.059927af.js"><link rel="prefetch" href="/assets/js/68.d1e1fb62.js"><link rel="prefetch" href="/assets/js/69.a98be775.js"><link rel="prefetch" href="/assets/js/7.330a4708.js"><link rel="prefetch" href="/assets/js/70.c773f1fb.js"><link rel="prefetch" href="/assets/js/71.23db970d.js"><link rel="prefetch" href="/assets/js/72.3f45b262.js"><link rel="prefetch" href="/assets/js/73.cc16dadf.js"><link rel="prefetch" href="/assets/js/74.1f05b2b1.js"><link rel="prefetch" href="/assets/js/75.3cd7d993.js"><link rel="prefetch" href="/assets/js/76.1e78e542.js"><link rel="prefetch" href="/assets/js/77.d97d60f9.js"><link rel="prefetch" href="/assets/js/78.6997cb3a.js"><link rel="prefetch" href="/assets/js/79.e8ef607f.js"><link rel="prefetch" href="/assets/js/8.cca0e264.js"><link rel="prefetch" href="/assets/js/80.57d72889.js"><link rel="prefetch" href="/assets/js/81.7aee8496.js"><link rel="prefetch" href="/assets/js/82.0b920de1.js"><link rel="prefetch" href="/assets/js/83.429d7e6f.js"><link rel="prefetch" href="/assets/js/84.c74f1357.js"><link rel="prefetch" href="/assets/js/85.71d21661.js"><link rel="prefetch" href="/assets/js/86.d55ba6f0.js"><link rel="prefetch" href="/assets/js/87.6566a5fc.js"><link rel="prefetch" href="/assets/js/88.6cfa26b6.js"><link rel="prefetch" href="/assets/js/89.0a9ed463.js"><link rel="prefetch" href="/assets/js/9.ef46dc1c.js"><link rel="prefetch" href="/assets/js/90.507b8bb7.js"><link rel="prefetch" href="/assets/js/91.0c374e4a.js"><link rel="prefetch" href="/assets/js/92.1f6e9c9d.js"><link rel="prefetch" href="/assets/js/93.33a64374.js"><link rel="prefetch" href="/assets/js/94.68d20253.js"><link rel="prefetch" href="/assets/js/95.2cf46b84.js"><link rel="prefetch" href="/assets/js/96.9b292e88.js"><link rel="prefetch" href="/assets/js/97.1575dbac.js"><link rel="prefetch" href="/assets/js/98.b8682f4a.js"><link rel="prefetch" href="/assets/js/99.0039b460.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4a9c0c84.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/favicon.ico" alt="悟空非空也" class="logo"> <span class="site-name can-hide">悟空非空也</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/wuKongNotNull/images-hosting/wukong-website/wukong-favicon-nobg.png"> <div class="blogger-info"><h3>悟空非空也</h3> <span>精通各语言拼写的野生程序员</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><a href="/blogs/" class="link-title">博客</a> <span class="title" style="display:none;">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/WuKongNotNull/awesome-free-vpn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  科学上网
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E5%A5%BD%E7%89%A9%E6%8E%A8%E8%8D%90%E5%AE%98&amp;.html" class="nav-link">好物推荐官</a></li><li class="dropdown-item"><!----> <a href="/categories/?category=%E9%9A%8F%E7%AC%94&amp;.html" class="nav-link">随笔感悟</a></li></ul></div></div><div class="nav-item"><a href="/pages/3ad3de/" class="nav-link">编程导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/javase/" class="nav-link">JavaSE</a></li><li class="dropdown-item"><!----> <a href="/java/javaee/" class="nav-link">JavaEE</a></li><li class="dropdown-item"><!----> <a href="/java/spring/" class="nav-link">Spring</a></li><li class="dropdown-item"><!----> <a href="/java/mybatis/" class="nav-link">MyBatis</a></li><li class="dropdown-item"><!----> <a href="/java/springboot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/java/springcloud/" class="nav-link">SpringCloud</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Python" class="dropdown-title"><a href="/python/" class="link-title">Python</a> <span class="title" style="display:none;">Python</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/python/tutorial/" class="nav-link">Python教程</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大前端" class="dropdown-title"><a href="/fore/" class="link-title">大前端</a> <span class="title" style="display:none;">大前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fore/javascript/" class="nav-link">JavaScript基础教程</a></li><li class="dropdown-item"><!----> <a href="/fore/js/" class="nav-link">JavaScript高级程序设计</a></li><li class="dropdown-item"><!----> <a href="/fore/es6/" class="nav-link">ES6 教程</a></li><li class="dropdown-item"><!----> <a href="/fore/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/fore/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/fore/typescript-axios/" class="nav-link">TypeScript 从零实现 axios</a></li><li class="dropdown-item"><!----> <a href="/fore/git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试" class="dropdown-title"><a href="/interview/" class="link-title">面试</a> <span class="title" style="display:none;">面试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/c/" class="nav-link">C开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/java/" class="nav-link">Java开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/python/" class="nav-link">Python开发岗</a></li><li class="dropdown-item"><!----> <a href="/interview/hr/" class="nav-link">人事爱问</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f4931c/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/norm/alisongshan/" class="nav-link">阿里Java开发手册</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript基础教程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>青铜</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>入门</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/49877d/" class="sidebar-link">入门篇</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>数据类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>运算符</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/pages/36f9e8/" class="sidebar-link">语法专题</a></li><li><a href="/pages/3e3990/" class="sidebar-link">标准库</a></li><li><a href="/pages/32c5b1/" class="sidebar-link">面向对象编程</a></li><li><a href="/pages/73df15/" class="sidebar-link">异步操作</a></li><li><a href="/pages/91f216/" class="sidebar-link">DOM</a></li><li><a href="/pages/329076/" class="sidebar-link">事件</a></li><li><a href="/pages/229568/" class="sidebar-link">浏览器模型(一)</a></li><li><a href="/pages/ffb0a1/" class="sidebar-link">浏览器模型(二)</a></li><li><a href="/pages/b7cf03/" aria-current="page" class="active sidebar-link">浏览器模型(三)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#cors-通信" class="sidebar-link">CORS 通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#两种请求" class="sidebar-link">两种请求</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#简单请求" class="sidebar-link">简单请求</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#非简单请求" class="sidebar-link">非简单请求</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#浏览器的正常请求和回应" class="sidebar-link">浏览器的正常请求和回应</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#与-jsonp-的比较" class="sidebar-link">与 JSONP 的比较</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#参考链接" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#storage-接口" class="sidebar-link">Storage 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#属性和方法" class="sidebar-link">属性和方法</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#storage-事件" class="sidebar-link">storage 事件</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#参考链接-2" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#history-对象" class="sidebar-link">History 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#概述-2" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#属性" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#popstate-事件" class="sidebar-link">popstate 事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#location-对象-url-对象-urlsearchparams对象" class="sidebar-link">Location 对象，URL 对象，URLSearchParams对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#location-对象" class="sidebar-link">Location 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#url-的编码和解码" class="sidebar-link">URL 的编码和解码</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#url-接口" class="sidebar-link">URL 接口</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#urlsearchparams-对象" class="sidebar-link">URLSearchParams 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#参考链接-3" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#arraybuffer对象-blob对象" class="sidebar-link">ArrayBuffer对象，Blob对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#arraybuffer-对象" class="sidebar-link">ArrayBuffer 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#blob-对象" class="sidebar-link">Blob 对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#file-对象-filelist对象-filereader对象" class="sidebar-link">File 对象，FileList对象，FileReader对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#file-对象" class="sidebar-link">File 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#filelist-对象" class="sidebar-link">FileList 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#filereader-对象" class="sidebar-link">FileReader 对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#表单-formdata对象" class="sidebar-link">表单，FormData对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#表单概述" class="sidebar-link">表单概述</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#formdata-对象" class="sidebar-link">FormData 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#表单的内置验证" class="sidebar-link">表单的内置验证</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#enctype-属性" class="sidebar-link">enctype 属性</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#文件上传" class="sidebar-link">文件上传</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#参考链接-4" class="sidebar-link">参考链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#indexdb-api" class="sidebar-link">IndexDB API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#概述-5" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#操作流程" class="sidebar-link">操作流程</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#indexeddb-对象" class="sidebar-link">indexedDB 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#indexeddb-deletedatabase" class="sidebar-link">indexedDB.deleteDatabase()</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#indexeddb-cmp" class="sidebar-link">indexedDB.cmp()</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbrequest-对象" class="sidebar-link">IDBRequest 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbdatabase-对象" class="sidebar-link">IDBDatabase 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#属性-3" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#方法-3" class="sidebar-link">方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbobjectstore-对象" class="sidebar-link">IDBObjectStore 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#属性-4" class="sidebar-link">属性</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#方法-4" class="sidebar-link">方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbtransaction-对象" class="sidebar-link">IDBTransaction 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbindex-对象" class="sidebar-link">IDBIndex 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbcursor-对象" class="sidebar-link">IDBCursor 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#idbkeyrange-对象" class="sidebar-link">IDBKeyRange 对象</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#参考链接-5" class="sidebar-link">参考链接</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#web-worker" class="sidebar-link">Web Worker</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#概述-6" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#基本用法" class="sidebar-link">基本用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#主线程" class="sidebar-link">主线程</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#worker-线程" class="sidebar-link">Worker 线程</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#worker-加载脚本" class="sidebar-link">Worker 加载脚本</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#错误处理" class="sidebar-link">错误处理</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#关闭-worker" class="sidebar-link">关闭 Worker</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#数据通信" class="sidebar-link">数据通信</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#同页面的-web-worker" class="sidebar-link">同页面的 Web Worker</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#实例-worker-线程完成轮询" class="sidebar-link">实例：Worker 线程完成轮询</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#实例-worker-新建-worker" class="sidebar-link">实例： Worker 新建 Worker</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#api" class="sidebar-link">API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/b7cf03/#主线程-2" class="sidebar-link">主线程</a></li><li class="sidebar-sub-header"><a href="/pages/b7cf03/#worker-线程-2" class="sidebar-link">Worker 线程</a></li></ul></li></ul></li><li><a href="/pages/610238/" class="sidebar-link">浏览器模型(四)</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《ES6 教程》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Vue》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《React》笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《TypeScript 从零实现 axios》</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>《Git》学习笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript文章</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/fore" title="大前端-目录页" data-v-1cd794fe>大前端</a></li> <li data-v-1cd794fe><a href="/fore/#JavaScript基础教程" title="大前端#JavaScript基础教程" data-v-1cd794fe>JavaScript基础教程</a></li> <li data-v-1cd794fe><a href="/fore/#青铜" title="大前端#青铜" data-v-1cd794fe>青铜</a></li></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/wuKongNotNull" target="_blank" title="作者" class="beLink" data-v-1cd794fe>悟空非空也</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-12-07</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          浏览器模型(三)
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><h1 id="浏览器模型-三"><a href="#浏览器模型-三" class="header-anchor">#</a> 浏览器模型（三）</h1> <h2 id="cors-通信"><a href="#cors-通信" class="header-anchor">#</a> CORS 通信</h2> <p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而克服了 AJAX 只能同源使用的限制。</p> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p> <p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p> <h3 id="两种请求"><a href="#两种请求" class="header-anchor">#</a> 两种请求</h3> <p>CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p> <p>只要同时满足以下两大条件，就属于简单请求。</p> <p>（1）请求方法是以下三种方法之一。</p> <blockquote><ul><li>HEAD</li> <li>GET</li> <li>POST</li></ul></blockquote> <p>（2）HTTP 的头信息不超出以下几种字段。</p> <blockquote><ul><li>Accept</li> <li>Accept-Language</li> <li>Content-Language</li> <li>Last-Event-ID</li> <li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote> <p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p> <p>这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p> <h3 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求</h3> <h4 id="基本流程"><a href="#基本流程" class="header-anchor">#</a> 基本流程</h4> <p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p> <p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p> <div class="language- extra-class"><pre class="language-text"><code>GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre></div><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p> <p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p> <p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre></div><p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p> <p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p> <p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p> <p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p> <p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p> <p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p> <p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p> <h4 id="withcredentials-属性"><a href="#withcredentials-属性" class="header-anchor">#</a> withCredentials 属性</h4> <p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定<code>Access-Control-Allow-Credentials</code>字段，告诉浏览器可以发送 Cookie。</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Credentials: true
</code></pre></div><p>同时，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre></div><p>否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p> <p>但是，有的浏览器默认将<code>withCredentials</code>属性设为<code>true</code>。这导致如果省略<code>withCredentials</code>设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>xhr.withCredentials = false;
</code></pre></div><p>需要注意的是，如果服务器要求浏览器发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p> <h3 id="非简单请求"><a href="#非简单请求" class="header-anchor">#</a> 非简单请求</h3> <h4 id="预检请求"><a href="#预检请求" class="header-anchor">#</a> 预检请求</h4> <p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p> <p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p> <p>下面是一段浏览器的 JavaScript 脚本。</p> <div class="language- extra-class"><pre class="language-text"><code>var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
</code></pre></div><p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p> <p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p> <div class="language- extra-class"><pre class="language-text"><code>OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre></div><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p> <p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p> <p><strong>（1）<code>Access-Control-Request-Method</code></strong></p> <p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p> <p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p> <p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p> <h4 id="预检请求的回应"><a href="#预检请求的回应" class="header-anchor">#</a> 预检请求的回应</h4> <p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre></div><p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Origin: *
</code></pre></div><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p> <div class="language- extra-class"><pre class="language-text"><code>OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
</code></pre></div><p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p> <p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p> <div class="language- extra-class"><pre class="language-text"><code>XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre></div><p>服务器回应的其他 CORS 相关字段如下。</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre></div><p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p> <p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p> <p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p> <p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p> <p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p> <p>该字段与简单请求时的含义相同。</p> <p><strong>（4）<code>Access-Control-Max-Age</code></strong></p> <p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p> <h3 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="header-anchor">#</a> 浏览器的正常请求和回应</h3> <p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p> <p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p> <div class="language- extra-class"><pre class="language-text"><code>PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre></div><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p> <p>下面是服务器正常的回应。</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</code></pre></div><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p> <h3 id="与-jsonp-的比较"><a href="#与-jsonp-的比较" class="header-anchor">#</a> 与 JSONP 的比较</h3> <p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p> <h3 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h3> <ul><li><a href="https://www.html5rocks.com/en/tutorials/cors/" target="_blank" rel="noopener noreferrer">Using CORS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, Monsur Hossain</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener noreferrer">HTTP access control (CORS)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, MDN</li> <li><a href="https://frontendian.co/cors" target="_blank" rel="noopener noreferrer">CORS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, Ryan Miller</li> <li><a href="http://performantcode.com/web/do-you-really-know-cors" target="_blank" rel="noopener noreferrer">Do You Really Know CORS?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, Grzegorz Mirek</li></ul> <h2 id="storage-接口"><a href="#storage-接口" class="header-anchor">#</a> Storage 接口</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <p>Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：<code>window.sessionStorage</code>和<code>window.localStorage</code>。</p> <p><code>sessionStorage</code>保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；<code>localStorage</code>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的其他方面都一致。</p> <p>保存的数据都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。</p> <p>这个接口很像 Cookie 的强化版，能够使用大得多的存储空间。目前，每个域名的存储上限视浏览器而定，Chrome 是 2.5MB，Firefox 和 Opera 是 5MB，IE 是 10MB。其中，Firefox 的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，Firefox 中，<code>a.example.com</code>和<code>b.example.com</code>共享 5MB 的存储空间。另外，与 Cookie 一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取，如果跨域操作会报错。</p> <h3 id="属性和方法"><a href="#属性和方法" class="header-anchor">#</a> 属性和方法</h3> <p>Storage 接口只有一个属性。</p> <ul><li><code>Storage.length</code>：返回保存的数据项个数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>window.localStorage.setItem('foo', 'a');
window.localStorage.setItem('bar', 'b');
window.localStorage.setItem('baz', 'c');

window.localStorage.length // 3
</code></pre></div><p>该接口提供5个方法。</p> <h4 id="storage-setitem"><a href="#storage-setitem" class="header-anchor">#</a> Storage.setItem()</h4> <p><code>Storage.setItem()</code>方法用于存入数据。它接受两个参数，第一个是键名，第二个是保存的数据。如果键名已经存在，该方法会更新已有的键值。该方法没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>window.sessionStorage.setItem('key', 'value');
window.localStorage.setItem('key', 'value');
</code></pre></div><p>注意，<code>Storage.setItem()</code>两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。</p> <div class="language- extra-class"><pre class="language-text"><code>window.sessionStorage.setItem(3, { foo: 1 });
window.sessionStorage.getItem('3') // &quot;[object Object]&quot;
</code></pre></div><p>上面代码中，<code>setItem</code>方法的两个参数都不是字符串，但是存入的值都是字符串。</p> <p>如果储存空间已满，该方法会抛错。</p> <p>写入不一定要用这个方法，直接赋值也是可以的。</p> <div class="language- extra-class"><pre class="language-text"><code>// 下面三种写法等价
window.localStorage.foo = '123';
window.localStorage['foo'] = '123';
window.localStorage.setItem('foo', '123');
</code></pre></div><h4 id="storage-getitem"><a href="#storage-getitem" class="header-anchor">#</a> Storage.getItem()</h4> <p><code>Storage.getItem()</code>方法用于读取数据。它只有一个参数，就是键名。如果键名不存在，该方法返回<code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>window.sessionStorage.getItem('key')
window.localStorage.getItem('key')
</code></pre></div><p>键名应该是一个字符串，否则会被自动转为字符串。</p> <h4 id="storage-removeitem"><a href="#storage-removeitem" class="header-anchor">#</a> Storage.removeItem()</h4> <p><code>Storage.removeItem()</code>方法用于清除某个键名对应的键值。它接受键名作为参数，如果键名不存在，该方法不会做任何事情。</p> <div class="language- extra-class"><pre class="language-text"><code>sessionStorage.removeItem('key');
localStorage.removeItem('key');
</code></pre></div><h4 id="storage-clear"><a href="#storage-clear" class="header-anchor">#</a> Storage.clear()</h4> <p><code>Storage.clear()</code>方法用于清除所有保存的数据。该方法的返回值是<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>window.sessionStorage.clear()
window.localStorage.clear()
</code></pre></div><h4 id="storage-key"><a href="#storage-key" class="header-anchor">#</a> Storage.key()</h4> <p><code>Storage.key()</code>方法接受一个整数作为参数（从零开始），返回该位置对应的键名。</p> <div class="language- extra-class"><pre class="language-text"><code>window.sessionStorage.setItem('key', 'value');
window.sessionStorage.key(0) // &quot;key&quot;
</code></pre></div><p>结合使用<code>Storage.length</code>属性和<code>Storage.key()</code>方法，可以遍历所有的键。</p> <div class="language- extra-class"><pre class="language-text"><code>for (var i = 0; i &lt; window.localStorage.length; i++) {
  console.log(localStorage.key(i));
}
</code></pre></div><h3 id="storage-事件"><a href="#storage-事件" class="header-anchor">#</a> storage 事件</h3> <p>Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。</p> <div class="language- extra-class"><pre class="language-text"><code>window.addEventListener('storage', onStorageChange);
</code></pre></div><p>监听函数接受一个<code>event</code>实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。</p> <ul><li><code>StorageEvent.key</code>：字符串，表示发生变动的键名。如果 storage 事件是由<code>clear()</code>方法引起，该属性返回<code>null</code>。</li> <li><code>StorageEvent.newValue</code>：字符串，表示新的键值。如果 storage 事件是由<code>clear()</code>方法或删除该键值对引发的，该属性返回<code>null</code>。</li> <li><code>StorageEvent.oldValue</code>：字符串，表示旧的键值。如果该键值对是新增的，该属性返回<code>null</code>。</li> <li><code>StorageEvent.storageArea</code>：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</li> <li><code>StorageEvent.url</code>：字符串，表示原始触发 storage 事件的那个网页的网址。</li></ul> <p>下面是<code>StorageEvent.key</code>属性的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>function onStorageChange(e) {
  console.log(e.key);
}

window.addEventListener('storage', onStorageChange);
</code></pre></div><p>注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。</p> <h3 id="参考链接-2"><a href="#参考链接-2" class="header-anchor">#</a> 参考链接</h3> <ul><li>Ryan Stewart，<a href="https://www.adobe.com/devnet/html5/articles/html5-storage-apis.html" target="_blank" rel="noopener noreferrer">Introducing the HTML5 storage APIs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://codular.com/localstorage" target="_blank" rel="noopener noreferrer">Getting Started with LocalStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Feross Aboukhadijeh, <a href="https://feross.org/fill-disk/" target="_blank" rel="noopener noreferrer">Introducing the HTML5 Hard Disk Filler™ API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Ben Summers, <a href="http://bens.me.uk/2013/localstorage-inter-window-messaging" target="_blank" rel="noopener noreferrer">Inter-window messaging using localStorage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Stack Overflow, <a href="https://stackoverflow.com/questions/18265556/why-does-internet-explorer-fire-the-window-storage-event-on-the-window-that-st" target="_blank" rel="noopener noreferrer">Why does Internet Explorer fire the window “storage” event on the window that stored the data?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Stack Overflow, <a href="https://stackoverflow.com/questions/5370784/localstorage-eventlistener-is-not-called" target="_blank" rel="noopener noreferrer">localStorage eventListener is not called<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="history-对象"><a href="#history-对象" class="header-anchor">#</a> History 对象</h2> <h3 id="概述-2"><a href="#概述-2" class="header-anchor">#</a> 概述</h3> <p><code>window.history</code>属性指向 History 对象，它表示当前窗口的浏览历史。</p> <p>History 对象保存了当前窗口访问过的所有页面网址。下面代码表示当前窗口一共访问过3个网址。</p> <div class="language- extra-class"><pre class="language-text"><code>window.history.length // 3
</code></pre></div><p>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</p> <div class="language- extra-class"><pre class="language-text"><code>// 后退到前一个网址
history.back()

// 等同于
history.go(-1)
</code></pre></div><p>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <p>History 对象主要有两个属性。</p> <ul><li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li> <li><code>History.state</code>：History 堆栈最上层的状态值（详见下文）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 当前窗口访问过多少个网页
window.history.length // 1

// History 对象的当前状态
// 通常是 undefined，即未设置
window.history.state // undefined
</code></pre></div><h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <h4 id="history-back-、history-forward-、history-go"><a href="#history-back-、history-forward-、history-go" class="header-anchor">#</a> History.back()、History.forward()、History.go()</h4> <p>这三个方法用于在历史之中移动。</p> <ul><li><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li> <li><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li> <li><code>History.go()</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如<code>go(1)</code>相当于<code>forward()</code>，<code>go(-1)</code>相当于<code>back()</code>。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为<code>0</code>，相当于刷新当前页面。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>history.back();
history.forward();
history.go(-2);
</code></pre></div><p><code>history.go(0)</code>相当于刷新当前页面。</p> <div class="language- extra-class"><pre class="language-text"><code>history.go(0); // 刷新当前页面
</code></pre></div><p>注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p> <h4 id="history-pushstate"><a href="#history-pushstate" class="header-anchor">#</a> History.pushState()</h4> <p><code>History.pushState()</code>方法用于在历史中添加一条记录。</p> <div class="language- extra-class"><pre class="language-text"><code>window.history.pushState(state, title, url)
</code></pre></div><p>该方法接受三个参数，依次为：</p> <ul><li><code>state</code>：一个与添加的记录相关联的状态对象，主要用于<code>popstate</code>事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填<code>null</code>。</li> <li><code>title</code>：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li> <li><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li></ul> <p>假定当前网址是<code>example.com/1.html</code>，使用<code>pushState()</code>方法在浏览记录（History 对象）中添加一个新记录。</p> <div class="language- extra-class"><pre class="language-text"><code>var stateObj = { foo: 'bar' };
history.pushState(stateObj, 'page 2', '2.html');
</code></pre></div><p>添加新记录后，浏览器地址栏立刻显示<code>example.com/2.html</code>，但并不会跳转到<code>2.html</code>，甚至也不会检查<code>2.html</code>是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问<code>google.com</code>)，然后点击了倒退按钮，页面的 URL 将显示<code>2.html</code>；你再点击一次倒退按钮，URL 将显示<code>1.html</code>。</p> <p>总之，<code>pushState()</code>方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。</p> <p>使用该方法之后，就可以用<code>History.state</code>属性读出状态对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var stateObj = { foo: 'bar' };
history.pushState(stateObj, 'page 2', '2.html');
history.state // {foo: &quot;bar&quot;}
</code></pre></div><p>如果<code>pushState</code>的 URL 参数设置了一个新的锚点值（即<code>hash</code>），并不会触发<code>hashchange</code>事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p> <p>如果<code>pushState()</code>方法设置了一个跨域网址，则会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 报错
// 当前网址为 http://example.com
history.pushState(null, '', 'https://twitter.com/hello');
</code></pre></div><p>上面代码中，<code>pushState</code>想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p> <h4 id="history-replacestate"><a href="#history-replacestate" class="header-anchor">#</a> History.replaceState()</h4> <p><code>History.replaceState()</code>方法用来修改 History 对象的当前记录，其他都与<code>pushState()</code>方法一模一样。</p> <p>假定当前网页是<code>example.com/example.html</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>history.pushState({page: 1}, 'title 1', '?page=1')
// URL 显示为 http://example.com/example.html?page=1

history.pushState({page: 2}, 'title 2', '?page=2');
// URL 显示为 http://example.com/example.html?page=2

history.replaceState({page: 3}, 'title 3', '?page=3');
// URL 显示为 http://example.com/example.html?page=3

history.back()
// URL 显示为 http://example.com/example.html?page=1

history.back()
// URL 显示为 http://example.com/example.html

history.go(2)
// URL 显示为 http://example.com/example.html?page=3
</code></pre></div><h3 id="popstate-事件"><a href="#popstate-事件" class="header-anchor">#</a> popstate 事件</h3> <p>每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p> <p>注意，仅仅调用<code>pushState()</code>方法或<code>replaceState()</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用<code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p> <p>使用的时候，可以为<code>popstate</code>事件指定回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code>window.onpopstate = function (event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
};

// 或者
window.addEventListener('popstate', function(event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
});
</code></pre></div><p>回调函数的参数是一个<code>event</code>事件对象，它的<code>state</code>属性指向<code>pushState</code>和<code>replaceState</code>方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的<code>event.state</code>，就是通过<code>pushState</code>和<code>replaceState</code>方法，为当前 URL 绑定的<code>state</code>对象。</p> <p>这个<code>state</code>对象也可以直接通过<code>history</code>对象读取。</p> <div class="language- extra-class"><pre class="language-text"><code>var currentState = history.state;
</code></pre></div><p>注意，页面第一次加载的时候，浏览器不会触发<code>popstate</code>事件。</p> <h2 id="location-对象-url-对象-urlsearchparams对象"><a href="#location-对象-url-对象-urlsearchparams对象" class="header-anchor">#</a> Location 对象，URL 对象，URLSearchParams对象</h2> <p>URL 是互联网的基础设施之一。浏览器提供了一些原生对象，用来管理 URL。</p> <h5 id=""><a href="#" class="header-anchor">#</a></h5> <h3 id="location-对象"><a href="#location-对象" class="header-anchor">#</a> Location 对象</h3> <p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p> <h4 id="属性-2"><a href="#属性-2" class="header-anchor">#</a> 属性</h4> <p><code>Location</code>对象提供以下属性。</p> <ul><li><code>Location.href</code>：整个 URL。</li> <li><code>Location.protocol</code>：当前 URL 的协议，包括冒号（<code>:</code>）。</li> <li><code>Location.host</code>：主机。如果端口不是协议默认的<code>80</code>和<code>433</code>，则还会包括冒号（<code>:</code>）和端口。</li> <li><code>Location.hostname</code>：主机名，不包括端口。</li> <li><code>Location.port</code>：端口号。</li> <li><code>Location.pathname</code>：URL 的路径部分，从根路径<code>/</code>开始。</li> <li><code>Location.search</code>：查询字符串部分，从问号<code>?</code>开始。</li> <li><code>Location.hash</code>：片段字符串部分，从<code>#</code>开始。</li> <li><code>Location.username</code>：域名前面的用户名。</li> <li><code>Location.password</code>：域名前面的密码。</li> <li><code>Location.origin</code>：URL 的协议、主机名和端口。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 当前网址为
// http://user:passwd@www.example.com:4097/path/a.html?x=111#part1
document.location.href
// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;
document.location.protocol
// &quot;http:&quot;
document.location.host
// &quot;www.example.com:4097&quot;
document.location.hostname
// &quot;www.example.com&quot;
document.location.port
// &quot;4097&quot;
document.location.pathname
// &quot;/path/a.html&quot;
document.location.search
// &quot;?x=111&quot;
document.location.hash
// &quot;#part1&quot;
document.location.username
// &quot;user&quot;
document.location.password
// &quot;passwd&quot;
document.location.origin
// &quot;http://user:passwd@www.example.com:4097&quot;
</code></pre></div><p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写。</p> <p>注意，如果对<code>Location.href</code>写入新的 URL 地址，浏览器会立刻跳转到这个新地址。</p> <div class="language- extra-class"><pre class="language-text"><code>// 跳转到新网址
document.location.href = 'http://www.example.com';
</code></pre></div><p>这个特性常常用于让网页自动滚动到新的锚点。</p> <div class="language- extra-class"><pre class="language-text"><code>document.location.href = '#top';
// 等同于
document.location.hash = '#top';
</code></pre></div><p>直接改写<code>location</code>，相当于写入<code>href</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>document.location = 'http://www.example.com';
// 等同于
document.location.href = 'http://www.example.com';
</code></pre></div><p>另外，<code>Location.href</code>属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的<code>Location.href</code>属性，导致后者的网址跳转。<code>Location</code>的其他属性都不允许跨域写入。</p> <h4 id="方法-2"><a href="#方法-2" class="header-anchor">#</a> 方法</h4> <p><strong>（1）Location.assign()</strong></p> <p><code>assign</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>// 跳转到新的网址
document.location.assign('http://www.example.com')
</code></pre></div><p><strong>（2）Location.replace()</strong></p> <p><code>replace</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p> <p>它与<code>assign</code>方法的差异在于，<code>replace</code>会在浏览器的浏览历史<code>History</code>里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。</p> <div class="language- extra-class"><pre class="language-text"><code>// 跳转到新的网址
document.location.replace('http://www.example.com')
</code></pre></div><p><strong>（3）Location.reload()</strong></p> <p><code>reload</code>方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。</p> <p>它接受一个布尔值作为参数。如果参数为<code>true</code>，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即<code>scrollTop === 0</code>）。如果参数是<code>false</code>或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。</p> <div class="language- extra-class"><pre class="language-text"><code>// 向服务器重新请求当前网址
window.location.reload(true);
</code></pre></div><p><strong>（4）Location.toString()</strong></p> <p><code>toString</code>方法返回整个 URL 字符串，相当于读取<code>Location.href</code>属性。</p> <h3 id="url-的编码和解码"><a href="#url-的编码和解码" class="header-anchor">#</a> URL 的编码和解码</h3> <p>网页的 URL 只能包含合法的字符。合法字符分成两类。</p> <ul><li>URL 元字符：分号（<code>;</code>），逗号（<code>,</code>），斜杠（<code>/</code>），问号（<code>?</code>），冒号（<code>:</code>），at（<code>@</code>），<code>&amp;</code>，等号（<code>=</code>），加号（<code>+</code>），美元符号（<code>$</code>），井号（<code>#</code>）</li> <li>语义字符：<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，连词号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>），感叹号（<code>!</code>），波浪线（<code>~</code>），星号（<code>*</code>），单引号（<code>'</code>），圆括号（<code>()</code>）</li></ul> <p>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（<code>%</code>）加上两个大写的十六进制字母。</p> <p>比如，UTF-8 的操作系统上，<code>http://www.example.com/q=春节</code>这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成<code>http://www.example.com/q=%E6%98%A5%E8%8A%82</code>。其中，“春”转成了<code>%E6%98%A5</code>，“节”转成了<code>%E8%8A%82</code>。这是因为“春”和“节”的 UTF-8 编码分别是<code>E6 98 A5</code>和<code>E8 8A 82</code>，将每个字节前面加上百分号，就构成了 URL 编码。</p> <p>JavaScript 提供四个 URL 的编码/解码方法。</p> <ul><li><code>encodeURI()</code></li> <li><code>encodeURIComponent()</code></li> <li><code>decodeURI()</code></li> <li><code>decodeURIComponent()</code></li></ul> <h4 id="encodeuri"><a href="#encodeuri" class="header-anchor">#</a> encodeURI()</h4> <p><code>encodeURI()</code>方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。</p> <div class="language- extra-class"><pre class="language-text"><code>encodeURI('http://www.example.com/q=春节')
// &quot;http://www.example.com/q=%E6%98%A5%E8%8A%82&quot;
</code></pre></div><h4 id="encodeuricomponent"><a href="#encodeuricomponent" class="header-anchor">#</a> encodeURIComponent()</h4> <p><code>encodeURIComponent()</code>方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。</p> <div class="language- extra-class"><pre class="language-text"><code>encodeURIComponent('春节')
// &quot;%E6%98%A5%E8%8A%82&quot;
encodeURIComponent('http://www.example.com/q=春节')
// &quot;http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82&quot;
</code></pre></div><p>上面代码中，<code>encodeURIComponent()</code>会连 URL 元字符一起转义，所以如果转码整个 URL 就会出错。</p> <h4 id="decodeuri"><a href="#decodeuri" class="header-anchor">#</a> decodeURI()</h4> <p><code>decodeURI()</code>方法用于整个 URL 的解码。它是<code>encodeURI()</code>方法的逆运算。它接受一个参数，就是转码后的 URL。</p> <div class="language- extra-class"><pre class="language-text"><code>decodeURI('http://www.example.com/q=%E6%98%A5%E8%8A%82')
// &quot;http://www.example.com/q=春节&quot;
</code></pre></div><h4 id="decodeuricomponent"><a href="#decodeuricomponent" class="header-anchor">#</a> decodeURIComponent()</h4> <p><code>decodeURIComponent()</code>用于URL 片段的解码。它是<code>encodeURIComponent()</code>方法的逆运算。它接受一个参数，就是转码后的 URL 片段。</p> <div class="language- extra-class"><pre class="language-text"><code>decodeURIComponent('%E6%98%A5%E8%8A%82')
// &quot;春节&quot;
</code></pre></div><h3 id="url-接口"><a href="#url-接口" class="header-anchor">#</a> URL 接口</h3> <p>浏览器原生提供<code>URL()</code>接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p> <h4 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h4> <p><code>URL()</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>var url = new URL('http://www.example.com/index.html');
url.href
// &quot;http://www.example.com/index.html&quot;
</code></pre></div><p>上面示例生成了一个 URL 实例，用来代表指定的网址。</p> <p>除了字符串，<code>URL()</code>的参数也可以是另一个 URL 实例。这时，<code>URL()</code>会自动读取该实例的<code>href</code>属性，作为实际参数。</p> <p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p> <div class="language- extra-class"><pre class="language-text"><code>var url1 = new URL('index.html', 'http://example.com');
url1.href
// &quot;http://example.com/index.html&quot;

var url2 = new URL('page2.html', 'http://example.com/page1.html');
url2.href
// &quot;http://example.com/page2.html&quot;

var url3 = new URL('..', 'http://example.com/a/b.html')
url3.href
// &quot;http://example.com/&quot;
</code></pre></div><p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是<code>..</code>，表示上层路径。</p> <h4 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h4> <p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p> <ul><li>URL.href：返回整个 URL</li> <li>URL.protocol：返回协议，以冒号<code>:</code>结尾</li> <li>URL.hostname：返回域名</li> <li>URL.host：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略</li> <li>URL.port：返回端口</li> <li>URL.origin：返回协议、域名和端口</li> <li>URL.pathname：返回路径，以斜杠<code>/</code>开头</li> <li>URL.search：返回查询字符串，以问号<code>?</code>开头</li> <li>URL.searchParams：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的</li> <li>URL.hash：返回片段识别符，以井号<code>#</code>开头</li> <li>URL.password：返回域名前面的密码</li> <li>URL.username：返回域名前面的用户名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var url = new URL('http://user:passwd@www.example.com:4097/path/a.html?x=111#part1');

url.href
// &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;
url.protocol
// &quot;http:&quot;
url.hostname
// &quot;www.example.com&quot;
url.host
// &quot;www.example.com:4097&quot;
url.port
// &quot;4097&quot;
url.origin
// &quot;http://www.example.com:4097&quot;
url.pathname
// &quot;/path/a.html&quot;
url.search
// &quot;?x=111&quot;
url.searchParams
// URLSearchParams {}
url.hash
// &quot;#part1&quot;
url.password
// &quot;passwd&quot;
url.username
// &quot;user&quot;
</code></pre></div><p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写，并且会立即生效。</p> <div class="language- extra-class"><pre class="language-text"><code>var url = new URL('http://example.com/index.html#part1');

url.pathname = 'index2.html';
url.href // &quot;http://example.com/index2.html#part1&quot;

url.hash = '#part2';
url.href // &quot;http://example.com/index2.html#part2&quot;
</code></pre></div><p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p> <h4 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h4> <p><strong>（1）URL.createObjectURL()</strong></p> <p><code>URL.createObjectURL()</code>方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了<code>File</code>对象或<code>Blob</code>对象的 URL。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;div id=&quot;display&quot;/&gt;
// &lt;input
//   type=&quot;file&quot;
//   id=&quot;fileElem&quot;
//   multiple
//   accept=&quot;image/*&quot;
//   onchange=&quot;handleFiles(this.files)&quot;
//  &gt;
var div = document.getElementById('display');

function handleFiles(files) {
  for (var i = 0; i &lt; files.length; i++) {
    var img = document.createElement('img');
    img.src = window.URL.createObjectURL(files[i]);
    div.appendChild(img);
  }
}
</code></pre></div><p>上面代码中，<code>URL.createObjectURL()</code>方法用来为上传的文件生成一个 URL 字符串，作为<code>&lt;img&gt;</code>元素的图片来源。</p> <p>该方法生成的 URL 就像下面的样子。</p> <div class="language- extra-class"><pre class="language-text"><code>blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1
</code></pre></div><p>注意，每次使用<code>URL.createObjectURL()</code>方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用<code>URL.revokeObjectURL()</code>方法释放这个实例。</p> <p><strong>（2）URL.revokeObjectURL()</strong></p> <p><code>URL.revokeObjectURL()</code>方法用来释放<code>URL.createObjectURL()</code>方法生成的 URL 实例。它的参数就是<code>URL.createObjectURL()</code>方法返回的 URL 字符串。</p> <p>下面为上一段的示例加上<code>URL.revokeObjectURL()</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.getElementById('display');

function handleFiles(files) {
  for (var i = 0; i &lt; files.length; i++) {
    var img = document.createElement('img');
    img.src = window.URL.createObjectURL(files[i]);
    div.appendChild(img);
    img.onload = function() {
      window.URL.revokeObjectURL(this.src);
    }
  }
}
</code></pre></div><p>上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在<code>img.onload</code>回调函数里面，通过<code>URL.revokeObjectURL()</code>方法卸载这个 URL 实例。</p> <h3 id="urlsearchparams-对象"><a href="#urlsearchparams-对象" class="header-anchor">#</a> URLSearchParams 对象</h3> <h4 id="概述-3"><a href="#概述-3" class="header-anchor">#</a> 概述</h4> <p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p> <p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p> <div class="language- extra-class"><pre class="language-text"><code>// 方法一：传入字符串
var params = new URLSearchParams('?foo=1&amp;bar=2');
// 等同于
var params = new URLSearchParams(document.location.search);

// 方法二：传入数组
var params = new URLSearchParams([['foo', 1], ['bar', 2]]);

// 方法三：传入对象
var params = new URLSearchParams({'foo' : 1 , 'bar' : 2});
</code></pre></div><p><code>URLSearchParams</code>会对查询字符串自动编码。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': '你好'});
params.toString() // &quot;foo=%E4%BD%A0%E5%A5%BD&quot;
</code></pre></div><p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p> <p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p> <div class="language- extra-class"><pre class="language-text"><code>const params = new URLSearchParams({foo: 1, bar: 2});
fetch('https://example.com/api', {
  method: 'POST',
  body: params
}).then(...)
</code></pre></div><p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p> <p><code>URLSearchParams</code>可以与<code>URL()</code>接口结合使用。</p> <div class="language- extra-class"><pre class="language-text"><code>var url = new URL(window.location);
var foo = url.searchParams.get('foo') || 'somedefault';
</code></pre></div><p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p> <p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历（详见《ES6 标准入门》的《Iterator》一章）。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': 1 , 'bar': 2});

for (var p of params) {
  console.log(p[0] + ': ' + p[1]);
}
// foo: 1
// bar: 2
</code></pre></div><p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p> <h4 id="urlsearchparams-tostring"><a href="#urlsearchparams-tostring" class="header-anchor">#</a> URLSearchParams.toString()</h4> <p><code>toString</code>方法返回实例的字符串形式。</p> <div class="language- extra-class"><pre class="language-text"><code>var url = new URL('https://example.com?foo=1&amp;bar=2');
var params = new URLSearchParams(url.search);

params.toString() // &quot;foo=1&amp;bar=2'
</code></pre></div><p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({version: 2.0});
window.location.href = location.pathname + '?' + params;
</code></pre></div><p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p> <h4 id="urlsearchparams-append"><a href="#urlsearchparams-append" class="header-anchor">#</a> URLSearchParams.append()</h4> <p><code>append()</code>方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': 1 , 'bar': 2});
params.append('baz', 3);
params.toString() // &quot;foo=1&amp;bar=2&amp;baz=3&quot;
</code></pre></div><p><code>append()</code>方法不会识别是否键名已经存在。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': 1 , 'bar': 2});
params.append('foo', 3);
params.toString() // &quot;foo=1&amp;bar=2&amp;foo=3&quot;
</code></pre></div><p>上面代码中，查询字符串里面<code>foo</code>已经存在了，但是<code>append</code>依然会追加一个同名键。</p> <h4 id="urlsearchparams-delete"><a href="#urlsearchparams-delete" class="header-anchor">#</a> URLSearchParams.delete()</h4> <p><code>delete()</code>方法用来删除指定的查询参数。它接受键名作为参数。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': 1 , 'bar': 2});
params.delete('bar');
params.toString() // &quot;foo=1&quot;
</code></pre></div><h4 id="urlsearchparams-has"><a href="#urlsearchparams-has" class="header-anchor">#</a> URLSearchParams.has()</h4> <p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams({'foo': 1 , 'bar': 2});
params.has('bar') // true
params.has('baz') // false
</code></pre></div><h4 id="urlsearchparams-set"><a href="#urlsearchparams-set" class="header-anchor">#</a> URLSearchParams.set()</h4> <p><code>set()</code>方法用来设置查询字符串的键值。</p> <p>它接受两个参数，第一个是键名，第二个是键值。如果是已经存在的键，键值会被改写，否则会被追加。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('?foo=1');
params.set('foo', 2);
params.toString() // &quot;foo=2&quot;
params.set('bar', 3);
params.toString() // &quot;foo=2&amp;bar=3&quot;
</code></pre></div><p>上面代码中，<code>foo</code>是已经存在的键，<code>bar</code>是还不存在的键。</p> <p>如果有多个的同名键，<code>set</code>会移除现存所有的键。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('?foo=1&amp;foo=2');
params.set('foo', 3);
params.toString() // &quot;foo=3&quot;
</code></pre></div><p>下面是一个替换当前 URL 的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>// URL: https://example.com?version=1.0
var params = new URLSearchParams(location.search.slice(1));
params.set('version', '2.0');

window.history.replaceState({}, '', location.pathname + `?` + params);
// URL: https://example.com?version=2.0
</code></pre></div><h4 id="urlsearchparams-get-urlsearchparams-getall"><a href="#urlsearchparams-get-urlsearchparams-getall" class="header-anchor">#</a> URLSearchParams.get()，URLSearchParams.getAll()</h4> <p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('?foo=1');
params.get('foo') // &quot;1&quot;
params.get('bar') // null
</code></pre></div><p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p> <p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('?foo=3&amp;foo=2&amp;foo=1');
params.get('foo') // &quot;3&quot;
</code></pre></div><p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p> <p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('?foo=1&amp;foo=2');
params.getAll('foo') // [&quot;1&quot;, &quot;2&quot;]
</code></pre></div><p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p> <h4 id="urlsearchparams-sort"><a href="#urlsearchparams-sort" class="header-anchor">#</a> URLSearchParams.sort()</h4> <p><code>sort()</code>方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。</p> <p>该方法没有返回值，或者说返回值是<code>undefined</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('c=4&amp;a=2&amp;b=3&amp;a=1');
params.sort();
params.toString() // &quot;a=2&amp;a=1&amp;b=3&amp;c=4&quot;
</code></pre></div><p>上面代码中，如果有两个同名的键<code>a</code>，它们之间不会排序，而是保留原始的顺序。</p> <h4 id="urlsearchparams-keys-urlsearchparams-values-urlsearchparams-entries"><a href="#urlsearchparams-keys-urlsearchparams-values-urlsearchparams-entries" class="header-anchor">#</a> URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h4> <p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p> <div class="language- extra-class"><pre class="language-text"><code>var params = new URLSearchParams('a=1&amp;b=2');

for(var p of params.keys()) {
  console.log(p);
}
// a
// b

for(var p of params.values()) {
  console.log(p);
}
// 1
// 2

for(var p of params.entries()) {
  console.log(p);
}
// [&quot;a&quot;, &quot;1&quot;]
// [&quot;b&quot;, &quot;2&quot;]
</code></pre></div><p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p> <div class="language- extra-class"><pre class="language-text"><code>for (var p of params) {}
// 等同于
for (var p of params.entries()) {}
</code></pre></div><h3 id="参考链接-3"><a href="#参考链接-3" class="header-anchor">#</a> 参考链接</h3> <ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Location" target="_blank" rel="noopener noreferrer">Location<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, by MDN</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" target="_blank" rel="noopener noreferrer">URL<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, by MDN</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener noreferrer">URLSearchParams<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, by MDN</li> <li><a href="https://developers.google.com/web/updates/2016/01/urlsearchparams?hl=en" target="_blank" rel="noopener noreferrer">Easy URL Manipulation with URLSearchParams<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, by Eric Bidelman</li></ul> <h2 id="arraybuffer对象-blob对象"><a href="#arraybuffer对象-blob对象" class="header-anchor">#</a> ArrayBuffer对象，Blob对象</h2> <h3 id="arraybuffer-对象"><a href="#arraybuffer-对象" class="header-anchor">#</a> ArrayBuffer 对象</h3> <p>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</p> <p>这个对象是 ES6 才写入标准的，普通的网页编程用不到它，为了教程体系的完整，下面只提供一个简略的介绍，详细介绍请看《ES6 标准入门》里面的章节。</p> <p>浏览器原生提供<code>ArrayBuffer()</code>构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。</p> <div class="language- extra-class"><pre class="language-text"><code>var buffer = new ArrayBuffer(8);
</code></pre></div><p>上面代码中，实例对象<code>buffer</code>占用8个字节。</p> <p>ArrayBuffer 对象有实例属性<code>byteLength</code>，表示当前实例占用的内存长度（单位字节）。</p> <div class="language- extra-class"><pre class="language-text"><code>var buffer = new ArrayBuffer(8);
buffer.byteLength // 8
</code></pre></div><p>ArrayBuffer 对象有实例方法<code>slice()</code>，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置），如果省略第二个参数，则表示一直复制到结束。</p> <div class="language- extra-class"><pre class="language-text"><code>var buf1 = new ArrayBuffer(8);
var buf2 = buf1.slice(0);
</code></pre></div><p>上面代码表示复制原来的实例。</p> <h3 id="blob-对象"><a href="#blob-对象" class="header-anchor">#</a> Blob 对象</h3> <h4 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> 简介</h4> <p>Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。</p> <p>浏览器原生提供<code>Blob()</code>构造函数，用来生成实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>new Blob(array [, options])
</code></pre></div><p><code>Blob</code>构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的<code>Blob</code>实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性<code>type</code>，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>var htmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;'];
var myBlob = new Blob(htmlFragment, {type : 'text/html'});
</code></pre></div><p>上面代码中，实例对象<code>myBlob</code>包含的是字符串。生成实例的时候，数据类型指定为<code>text/html</code>。</p> <p>下面是另一个例子，Blob 保存 JSON 数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = { hello: 'world' };
var blob = new Blob([ JSON.stringify(obj) ], {type : 'application/json'});
</code></pre></div><h4 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="header-anchor">#</a> 实例属性和实例方法</h4> <p><code>Blob</code>具有两个实例属性<code>size</code>和<code>type</code>，分别返回数据的大小和类型。</p> <div class="language- extra-class"><pre class="language-text"><code>var htmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;'];
var myBlob = new Blob(htmlFragment, {type : 'text/html'});

myBlob.size // 32
myBlob.type // &quot;text/html&quot;
</code></pre></div><p><code>Blob</code>具有一个实例方法<code>slice</code>，用来拷贝原来的数据，返回的也是一个<code>Blob</code>实例。</p> <div class="language- extra-class"><pre class="language-text"><code>myBlob.slice(start, end, contentType)
</code></pre></div><p><code>slice</code>方法有三个参数，都是可选的。它们依次是起始的字节位置（默认为0）、结束的字节位置（默认为<code>size</code>属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。</p> <h4 id="获取文件信息"><a href="#获取文件信息" class="header-anchor">#</a> 获取文件信息</h4> <p>文件选择器<code>&lt;input type=&quot;file&quot;&gt;</code>用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的<code>value</code>属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。</p> <p>文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了<code>name</code>和<code>lastModifiedDate</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;

function fileinfo(files) {
  for (var i = 0; i &lt; files.length; i++) {
    var f = files[i];
    console.log(
      f.name, // 文件名，不含路径
      f.size, // 文件大小，Blob 实例属性
      f.type, // 文件类型，Blob 实例属性
      f.lastModifiedDate // 文件的最后修改时间
    );
  }
}
</code></pre></div><p>除了文件选择器，拖放 API 的<code>dataTransfer.files</code>返回的也是一个FileList 对象，它的成员因此也是 File 实例对象。</p> <h4 id="下载文件"><a href="#下载文件" class="header-anchor">#</a> 下载文件</h4> <p>AJAX 请求时，如果指定<code>responseType</code>属性为<code>blob</code>，下载下来的就是一个 Blob 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>function getBlob(url, callback) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.responseType = 'blob';
  xhr.onload = function () {
    callback(xhr.response);
  }
  xhr.send(null);
}
</code></pre></div><p>上面代码中，<code>xhr.response</code>拿到的就是一个 Blob 对象。</p> <h4 id="生成-url"><a href="#生成-url" class="header-anchor">#</a> 生成 URL</h4> <p>浏览器允许使用<code>URL.createObjectURL()</code>方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以<code>blob://</code>开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与<code>data://URL</code>（URL 包含实际数据）和<code>file://URL</code>（本地文件系统里面的文件）都不一样。</p> <div class="language- extra-class"><pre class="language-text"><code>var droptarget = document.getElementById('droptarget');

droptarget.ondrop = function (e) {
  var files = e.dataTransfer.files;
  for (var i = 0; i &lt; files.length; i++) {
    var type = files[i].type;
    if (type.substring(0,6) !== 'image/')
      continue;
    var img = document.createElement('img');
    img.src = URL.createObjectURL(files[i]);
    img.onload = function () {
      this.width = 100;
      document.body.appendChild(this);
      URL.revokeObjectURL(this.src);
    }
  }
}
</code></pre></div><p>上面代码通过为拖放的图片文件生成一个 URL，产生它们的缩略图，从而使得用户可以预览选择的文件。</p> <p>浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</p> <h4 id="读取文件"><a href="#读取文件" class="header-anchor">#</a> 读取文件</h4> <p>取得 Blob 对象以后，可以通过<code>FileReader</code>对象，读取 Blob 对象的内容，即文件内容。</p> <p>FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</p> <ul><li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。</li> <li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。</li> <li><code>FileReader.readAsDataURL()</code>：返回 Data URL。</li> <li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。</li></ul> <p>下面是<code>FileReader.readAsText()</code>方法的例子，用来读取文本文件。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input type=&quot;file&quot; onchange=&quot;readfile(this.files[0])&quot;&gt;&lt;/input&gt;
// &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;
function readfile(f) {
  var reader = new FileReader();
  reader.readAsText(f);
  reader.onload = function () {
    var text = reader.result;
    var out = document.getElementById('output');
    out.innerHTML = '';
    out.appendChild(document.createTextNode(text));
  }
  reader.onerror = function(e) {
    console.log('Error', e);
  };
}
</code></pre></div><p>上面代码中，通过指定 FileReader 实例对象的<code>onload</code>监听函数，在实例的<code>result</code>属性上拿到文件内容。</p> <p>下面是<code>FileReader.readAsArrayBuffer()</code>方法的例子，用于读取二进制文件。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;
function typefile(file) {
  // 文件开头的四个字节，生成一个 Blob 对象
  var slice = file.slice(0, 4);
  var reader = new FileReader();
  // 读取这四个字节
  reader.readAsArrayBuffer(slice);
  reader.onload = function (e) {
    var buffer = reader.result;
    // 将这四个字节的内容，视作一个32位整数
    var view = new DataView(buffer);
    var magic = view.getUint32(0, false);
    // 根据文件的前四个字节，判断它的类型
    switch(magic) {
      case 0x89504E47: file.verified_type = 'image/png'; break;
      case 0x47494638: file.verified_type = 'image/gif'; break;
      case 0x25504446: file.verified_type = 'application/pdf'; break;
      case 0x504b0304: file.verified_type = 'application/zip'; break;
    }
    console.log(file.name, file.verified_type);
  };
}
</code></pre></div><h2 id="file-对象-filelist对象-filereader对象"><a href="#file-对象-filelist对象-filereader对象" class="header-anchor">#</a> File 对象，FileList对象，FileReader对象</h2> <h3 id="file-对象"><a href="#file-对象" class="header-anchor">#</a> File 对象</h3> <p>File 对象代表一个文件，用来读写文件信息。它继承了 Blob 对象，或者说是一种特殊的 Blob 对象，所有可以使用 Blob 对象的场合都可以使用它。</p> <p>最常见的使用场合是表单的文件上传控件（<code>&lt;input type=&quot;file&quot;&gt;</code>），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 File 实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;
var file = document.getElementById('fileItem').files[0];
file instanceof File // true
</code></pre></div><p>上面代码中，<code>file</code>是用户选中的第一个文件，它是 File 的实例。</p> <h4 id="构造函数-2"><a href="#构造函数-2" class="header-anchor">#</a> 构造函数</h4> <p>浏览器原生提供一个<code>File()</code>构造函数，用来生成 File 实例对象。</p> <div class="language- extra-class"><pre class="language-text"><code>new File(array, name [, options])
</code></pre></div><p><code>File()</code>构造函数接受三个参数。</p> <ul><li>array：一个数组，成员可以是二进制对象或字符串，表示文件的内容。</li> <li>name：字符串，表示文件名或文件路径。</li> <li>options：配置对象，设置实例的属性。该参数可选。</li></ul> <p>第三个参数配置对象，可以设置两个属性。</p> <ul><li>type：字符串，表示实例对象的 MIME 类型，默认值为空字符串。</li> <li>lastModified：时间戳，表示上次修改的时间，默认为<code>Date.now()</code>。</li></ul> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var file = new File(
  ['foo'],
  'foo.txt',
  {
    type: 'text/plain',
  }
);
</code></pre></div><h4 id="实例属性和实例方法-2"><a href="#实例属性和实例方法-2" class="header-anchor">#</a> 实例属性和实例方法</h4> <p>File 对象有以下实例属性。</p> <ul><li>File.lastModified：最后修改时间</li> <li>File.name：文件名或文件路径</li> <li>File.size：文件大小（单位字节）</li> <li>File.type：文件的 MIME 类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var myFile = new File([], 'file.bin', {
  lastModified: new Date(2018, 1, 1),
});
myFile.lastModified // 1517414400000
myFile.name // &quot;file.bin&quot;
myFile.size // 0
myFile.type // &quot;&quot;
</code></pre></div><p>上面代码中，由于<code>myFile</code>的内容为空，也没有设置 MIME 类型，所以<code>size</code>属性等于0，<code>type</code>属性等于空字符串。</p> <p>File 对象没有自己的实例方法，由于继承了 Blob 对象，因此可以使用 Blob 的实例方法<code>slice()</code>。</p> <h3 id="filelist-对象"><a href="#filelist-对象" class="header-anchor">#</a> FileList 对象</h3> <p><code>FileList</code>对象是一个类似数组的对象，代表一组选中的文件，每个成员都是一个 File 实例。它主要出现在两个场合。</p> <ul><li>文件控件节点（<code>&lt;input type=&quot;file&quot;&gt;</code>）的<code>files</code>属性，返回一个 FileList 实例。</li> <li>拖拉一组文件时，目标区的<code>DataTransfer.files</code>属性，返回一个 FileList 实例。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input id=&quot;fileItem&quot; type=&quot;file&quot;&gt;
var files = document.getElementById('fileItem').files;
files instanceof FileList // true
</code></pre></div><p>上面代码中，文件控件的<code>files</code>属性是一个 FileList 实例。</p> <p>FileList 的实例属性主要是<code>length</code>，表示包含多少个文件。</p> <p>FileList 的实例方法主要是<code>item()</code>，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。但是，由于 FileList 的实例是一个类似数组的对象，可以直接用方括号运算符，即<code>myFileList[0]</code>等同于<code>myFileList.item(0)</code>，所以一般用不到<code>item()</code>方法。</p> <h3 id="filereader-对象"><a href="#filereader-对象" class="header-anchor">#</a> FileReader 对象</h3> <p>FileReader 对象用于读取 File 对象或 Blob 对象所包含的文件内容。</p> <p>浏览器原生提供一个<code>FileReader</code>构造函数，用来生成 FileReader 实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var reader = new FileReader();
</code></pre></div><p>FileReader 有以下的实例属性。</p> <ul><li>FileReader.error：读取文件时产生的错误对象</li> <li>FileReader.readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，<code>0</code>表示尚未加载任何数据，<code>1</code>表示数据正在加载，<code>2</code>表示加载完成。</li> <li>FileReader.result：读取完成后的文件内容，有可能是字符串，也可能是一个 ArrayBuffer 实例。</li> <li>FileReader.onabort：<code>abort</code>事件（用户终止读取操作）的监听函数。</li> <li>FileReader.onerror：<code>error</code>事件（读取错误）的监听函数。</li> <li>FileReader.onload：<code>load</code>事件（读取操作完成）的监听函数，通常在这个函数里面使用<code>result</code>属性，拿到文件内容。</li> <li>FileReader.onloadstart：<code>loadstart</code>事件（读取操作开始）的监听函数。</li> <li>FileReader.onloadend：<code>loadend</code>事件（读取操作结束）的监听函数。</li> <li>FileReader.onprogress：<code>progress</code>事件（读取操作进行中）的监听函数。</li></ul> <p>下面是监听<code>load</code>事件的一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;input type=&quot;file&quot; onchange=&quot;onChange(event)&quot;&gt;

function onChange(event) {
  var file = event.target.files[0];
  var reader = new FileReader();
  reader.onload = function (event) {
    console.log(event.target.result)
  };

  reader.readAsText(file);
}
</code></pre></div><p>上面代码中，每当文件控件发生变化，就尝试读取第一个文件。如果读取成功（<code>load</code>事件发生），就打印出文件内容。</p> <p>FileReader 有以下实例方法。</p> <ul><li>FileReader.abort()：终止读取操作，<code>readyState</code>属性将变成<code>2</code>。</li> <li>FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后<code>result</code>属性将返回一个 ArrayBuffer 实例。</li> <li>FileReader.readAsBinaryString()：读取完成后，<code>result</code>属性将返回原始的二进制字符串。</li> <li>FileReader.readAsDataURL()：读取完成后，<code>result</code>属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于<code>&lt;img&gt;</code>元素的<code>src</code>属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀<code>data:*/*;base64,</code>从字符串里删除以后，再进行解码。</li> <li>FileReader.readAsText()：读取完成后，<code>result</code>属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。</li></ul> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>/* HTML 代码如下
  &lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;
  &lt;img src=&quot;&quot; height=&quot;200&quot;&gt;
*/

function previewFile() {
  var preview = document.querySelector('img');
  var file    = document.querySelector('input[type=file]').files[0];
  var reader  = new FileReader();

  reader.addEventListener('load', function () {
    preview.src = reader.result;
  }, false);

  if (file) {
    reader.readAsDataURL(file);
  }
}
</code></pre></div><p>上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给<code>&lt;img&gt;</code>元素的<code>src</code>属性，从而把图片展示出来。</p> <h2 id="表单-formdata对象"><a href="#表单-formdata对象" class="header-anchor">#</a> 表单，FormData对象</h2> <h3 id="表单概述"><a href="#表单概述" class="header-anchor">#</a> 表单概述</h3> <p>表单（<code>&lt;form&gt;</code>）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form action=&quot;/handling-page&quot; method=&quot;post&quot;&gt;
  &lt;div&gt;
    &lt;label for=&quot;name&quot;&gt;用户名：&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;user_name&quot; /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;passwd&quot;&gt;密码：&lt;/label&gt;
    &lt;input type=&quot;password&quot; id=&quot;passwd&quot; name=&quot;user_passwd&quot; /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;提交&quot; /&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre></div><p>上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。</p> <p>用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的<code>name</code>属性，键值是控件的<code>value</code>属性，键名和键值之间由等号连接。比如，用户名输入框的<code>name</code>属性是<code>user_name</code>，<code>value</code>属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对<code>user_name=张三</code>。</p> <p>所有的键值对都会提交到服务器。但是，提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如<code>/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 GET 请求的 HTTP 头信息。</p> <div class="language- extra-class"><pre class="language-text"><code>GET /handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交
Host: example.com
</code></pre></div><p>如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如<code>user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 POST 请求的头信息。</p> <div class="language- extra-class"><pre class="language-text"><code>POST /handling-page HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 74

user_name=张三&amp;user_passwd=123&amp;submit_button=提交
</code></pre></div><p>注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p> <p>点击<code>submit</code>控件，就可以提交表单。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre></div><p>上面表单就包含一个<code>submit</code>控件，点击这个控件，浏览器就会把表单数据向服务器提交。</p> <p>注意，表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form&gt;
  &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
</code></pre></div><p>上面表单的<code>&lt;button&gt;</code>元素，点击以后也会提交表单。</p> <p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p> <div class="language- extra-class"><pre class="language-text"><code>formElement.submit();
</code></pre></div><p>表单元素的<code>reset()</code>方法可以重置所有控件的值（重置为默认值）。</p> <div class="language- extra-class"><pre class="language-text"><code>formElement.reset()
</code></pre></div><h3 id="formdata-对象"><a href="#formdata-对象" class="header-anchor">#</a> FormData 对象</h3> <h4 id="概述-4"><a href="#概述-4" class="header-anchor">#</a> 概述</h4> <p>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。</p> <p><code>FormData()</code>首先是一个构造函数，用来生成表单的实例。</p> <div class="language- extra-class"><pre class="language-text"><code>var formdata = new FormData(form);
</code></pre></div><p><code>FormData()</code>构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。</p> <p>下面是一个表单。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form id=&quot;myForm&quot; name=&quot;myForm&quot;&gt;
  &lt;div&gt;
    &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;useracc&quot;&gt;账号：&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;useracc&quot; name=&quot;useracc&quot;&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;userfile&quot;&gt;上传文件：&lt;/label&gt;
    &lt;input type=&quot;file&quot; id=&quot;userfile&quot; name=&quot;userfile&quot;&gt;
  &lt;/div&gt;
&lt;input type=&quot;submit&quot; value=&quot;Submit!&quot;&gt;
&lt;/form&gt;
</code></pre></div><p>我们用<code>FormData()</code>处理上面这个表单。</p> <div class="language- extra-class"><pre class="language-text"><code>var myForm = document.getElementById('myForm');
var formData = new FormData(myForm);

// 获取某个控件的值
formData.get('username') // &quot;&quot;

// 设置某个控件的值
formData.set('username', '张三');

formData.get('username') // &quot;张三&quot;
</code></pre></div><h4 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h4> <p>FormData 提供以下实例方法。</p> <ul><li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li> <li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li> <li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li> <li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li> <li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li> <li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li> <li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li> <li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li> <li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li></ul> <p>下面是<code>get()</code>、<code>getAll()</code>、<code>set()</code>、<code>append()</code>方法的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var formData = new FormData();

formData.set('username', '张三');
formData.append('username', '李四');
formData.get('username') // &quot;张三&quot;
formData.getAll('username') // [&quot;张三&quot;, &quot;李四&quot;]

formData.append('userpic[]', myFileInput.files[0], 'user1.jpg');
formData.append('userpic[]', myFileInput.files[1], 'user2.jpg');
</code></pre></div><p>下面是遍历器的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

for (var key of formData.keys()) {
  console.log(key);
}
// &quot;key1&quot;
// &quot;key2&quot;

for (var value of formData.values()) {
  console.log(value);
}
// &quot;value1&quot;
// &quot;value2&quot;

for (var pair of formData.entries()) {
  console.log(pair[0] + ': ' + pair[1]);
}
// key1: value1
// key2: value2

// 等同于遍历 formData.entries()
for (var pair of formData) {
  console.log(pair[0] + ': ' + pair[1]);
}
// key1: value1
// key2: value2
</code></pre></div><h3 id="表单的内置验证"><a href="#表单的内置验证" class="header-anchor">#</a> 表单的内置验证</h3> <h4 id="自动校验"><a href="#自动校验" class="header-anchor">#</a> 自动校验</h4> <p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 必填 --&gt;
&lt;input required&gt;

&lt;!-- 必须符合正则表达式 --&gt;
&lt;input pattern=&quot;banana|cherry&quot;&gt;

&lt;!-- 字符串长度必须为6个字符 --&gt;
&lt;input minlength=&quot;6&quot; maxlength=&quot;6&quot;&gt;

&lt;!-- 数值必须在1到10之间 --&gt;
&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;

&lt;!-- 必须填入 Email 地址 --&gt;
&lt;input type=&quot;email&quot;&gt;

&lt;!-- 必须填入 URL --&gt;
&lt;input type=&quot;URL&quot;&gt;
</code></pre></div><p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p> <div class="language- extra-class"><pre class="language-text"><code>input:invalid {
  border-color: red;
}
input,
input:valid {
  border-color: #ccc;
}
</code></pre></div><h4 id="checkvalidity"><a href="#checkvalidity" class="header-anchor">#</a> checkValidity()</h4> <p>除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有<code>checkValidity()</code>方法，用于手动触发校验。</p> <div class="language- extra-class"><pre class="language-text"><code>// 触发整个表单的校验
form.checkValidity()

// 触发单个表单控件的校验
formControl.checkValidity()
</code></pre></div><p><code>checkValidity()</code>方法返回一个布尔值，<code>true</code>表示通过校验，<code>false</code>表示没有通过校验。因此，提交表单可以封装为下面的函数。</p> <div class="language- extra-class"><pre class="language-text"><code>function submitForm(action) {
  var form = document.getElementById('form');
  form.action = action;
  if (form.checkValidity()) {
    form.submit();
  }
}
</code></pre></div><h4 id="willvalidate-属性"><a href="#willvalidate-属性" class="header-anchor">#</a> willValidate 属性</h4> <p>控件元素的<code>willValidate</code>属性是一个布尔值，表示该控件是否会在提交时进行校验。</p> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;form novalidate&gt;
//   &lt;input id=&quot;name&quot; name=&quot;name&quot; required /&gt;
// &lt;/form&gt;

var input = document.querySelector('#name');
input.willValidate // true
</code></pre></div><h4 id="validationmessage-属性"><a href="#validationmessage-属性" class="header-anchor">#</a> validationMessage 属性</h4> <p>控件元素的<code>validationMessage</code>属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。</p> <ul><li>该控件不会在提交时自动校验</li> <li>该控件满足校验条件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// HTML 代码如下
// &lt;form&gt;&lt;input type=&quot;text&quot; required&gt;&lt;/form&gt;
document.querySelector('form input').validationMessage
// &quot;请填写此字段。&quot;
</code></pre></div><p>下面是另一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var myInput = document.getElementById('myinput');
if (!myInput.checkValidity()) {
  document.getElementById('prompt').innerHTML = myInput.validationMessage;
}
</code></pre></div><h4 id="setcustomvalidity"><a href="#setcustomvalidity" class="header-anchor">#</a> setCustomValidity()</h4> <p>控件元素的<code>setCustomValidity()</code>方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。</p> <p>这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form action=&quot;somefile.php&quot;&gt;
  &lt;input
    type=&quot;text&quot;
    name=&quot;username&quot;
    placeholder=&quot;Username&quot;
    pattern=&quot;[a-z]{1,15}&quot;
    id=&quot;username&quot;
  &gt;
  &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre></div><p>上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用<code>setCustomValidity()</code>方法替换掉报错信息。</p> <div class="language- extra-class"><pre class="language-text"><code>var input = document.getElementById('username');
input.oninvalid = function (event) {
  event.target.setCustomValidity(
    '用户名必须是小写字母，不能为空，最长不超过15个字符'
  );
}
</code></pre></div><p>上面代码中，<code>setCustomValidity()</code>方法是在<code>invalid</code>事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。</p> <div class="language- extra-class"><pre class="language-text"><code>/* HTML 代码如下
&lt;form&gt;
  &lt;p&gt;&lt;input type=&quot;file&quot; id=&quot;fs&quot;&gt;&lt;/p&gt;
  &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;
&lt;/form&gt;
*/

document.getElementById('fs').onchange = checkFileSize;

function checkFileSize() {
  var fs = document.getElementById('fs');
  var files = fs.files;
  if (files.length &gt; 0) {
     if (files[0].size &gt; 75 * 1024) {
       fs.setCustomValidity('文件不能大于 75KB');
       return;
     }
  }
  fs.setCustomValidity('');
}
</code></pre></div><p>上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。</p> <h4 id="validity-属性"><a href="#validity-属性" class="header-anchor">#</a> validity 属性</h4> <p>控件元素的属性<code>validity</code>属性返回一个<code>ValidityState</code>对象，包含当前校验状态的信息。</p> <p>该对象有以下属性，全部为只读属性。</p> <ul><li><code>ValidityState.badInput</code>：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。</li> <li><code>ValidityState.customError</code>：布尔值，表示是否已经调用<code>setCustomValidity()</code>方法，将校验信息设置为一个非空字符串。</li> <li><code>ValidityState.patternMismatch</code>：布尔值，表示用户输入的值是否不满足模式的要求。</li> <li><code>ValidityState.rangeOverflow</code>：布尔值，表示用户输入的值是否大于最大范围。</li> <li><code>ValidityState.rangeUnderflow</code>：布尔值，表示用户输入的值是否小于最小范围。</li> <li><code>ValidityState.stepMismatch</code>：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。</li> <li><code>ValidityState.tooLong</code>：布尔值，表示用户输入的字数超出了最长字数。</li> <li><code>ValidityState.tooShort</code>：布尔值，表示用户输入的字符少于最短字数。</li> <li><code>ValidityState.typeMismatch</code>：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。</li> <li><code>ValidityState.valid</code>：布尔值，表示用户是否满足所有校验条件。</li> <li><code>ValidityState.valueMissing</code>：布尔值，表示用户没有填入必填的值。</li></ul> <p>下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var input = document.getElementById('myinput');
if (input.validity.valid) {
  console.log('通过校验');
} else {
  console.log('校验失败');
}
</code></pre></div><p>下面是另外一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var txt = '';
if (document.getElementById('myInput').validity.rangeOverflow) {
  txt = '数值超过上限';
}
document.getElementById('prompt').innerHTML = txt;
</code></pre></div><p>如果想禁止浏览器弹出表单验证的报错信息，可以监听<code>invalid</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>var input = document.getElementById('username');
var form  = document.getElementById('form');

var elem = document.createElement('div');
elem.id  = 'notify';
elem.style.display = 'none';
form.appendChild(elem);

input.addEventListener('invalid', function (event) {
  event.preventDefault();
  if (!event.target.validity.valid) {
    elem.textContent   = '用户名必须是小写字母';
    elem.className     = 'error';
    elem.style.display = 'block';
    input.className    = 'invalid animated shake';
  }
});

input.addEventListener('input', function(event){
  if ( 'block' === elem.style.display ) {
    input.className = '';
    elem.style.display = 'none';
  }
});
</code></pre></div><p>上面代码中，一旦发生<code>invalid</code>事件（表单验证失败），<code>event.preventDefault()</code>用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。</p> <h4 id="表单的-novalidate-属性"><a href="#表单的-novalidate-属性" class="header-anchor">#</a> 表单的 novalidate 属性</h4> <p>表单元素的 HTML 属性<code>novalidate</code>，可以关闭浏览器的自动校验。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form novalidate&gt;
&lt;/form&gt;
</code></pre></div><p>这个属性也可以在脚本里设置。</p> <div class="language- extra-class"><pre class="language-text"><code>form.noValidate = true;
</code></pre></div><p>如果表单元素没有设置<code>novalidate</code>属性，那么提交按钮（<code>&lt;button&gt;</code>或<code>&lt;input&gt;</code>元素）的<code>formnovalidate</code>属性也有同样的作用。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form&gt;
  &lt;input type=&quot;submit&quot; value=&quot;submit&quot; formnovalidate&gt;
&lt;/form&gt;
</code></pre></div><h3 id="enctype-属性"><a href="#enctype-属性" class="header-anchor">#</a> enctype 属性</h3> <p>表单能够用四种编码，向服务器发送数据。编码格式由表单的<code>enctype</code>属性决定。</p> <p>假定表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值是一个分为两行的字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>The first line.
The second line.
</code></pre></div><p>下面四种格式，都可以将这个表单发送到服务器。</p> <p><strong>（1）GET 方法</strong></p> <p>如果表单使用<code>GET</code>方法发送数据，<code>enctype</code>属性无效。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form
  action=&quot;register.php&quot;
  method=&quot;get&quot;
  onsubmit=&quot;AJAXSubmit(this); return false;&quot;
&gt;
&lt;/form&gt;
</code></pre></div><p>数据将以 URL 的查询字符串发出。</p> <div class="language- extra-class"><pre class="language-text"><code>?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line.
</code></pre></div><p><strong>（2）application/x-www-form-urlencoded</strong></p> <p>如果表单用<code>POST</code>方法发送数据，并省略<code>enctype</code>属性，那么数据以<code>application/x-www-form-urlencoded</code>格式发送（因为这是默认值）。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form
  action=&quot;register.php&quot;
  method=&quot;post&quot;
  onsubmit=&quot;AJAXSubmit(this); return false;&quot;
&gt;
&lt;/form&gt;
</code></pre></div><p>发送的 HTTP 请求如下。</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Type: application/x-www-form-urlencoded

foo=bar&amp;baz=The+first+line.%0D%0AThe+second+line.%0D%0A
</code></pre></div><p>上面代码中，数据体里面的<code>%0D%0A</code>代表换行符（<code>\r\n</code>）。</p> <p><strong>（3）text/plain</strong></p> <p>如果表单使用<code>POST</code>方法发送数据，<code>enctype</code>属性为<code>text/plain</code>，那么数据将以纯文本格式发送。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form
  action=&quot;register.php&quot;
  method=&quot;post&quot;
  enctype=&quot;text/plain&quot;
  onsubmit=&quot;AJAXSubmit(this); return false;&quot;
&gt;
&lt;/form&gt;
</code></pre></div><p>发送的 HTTP 请求如下。</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Type: text/plain

foo=bar
baz=The first line.
The second line.
</code></pre></div><p><strong>（4）multipart/form-data</strong></p> <p>如果表单使用<code>POST</code>方法，<code>enctype</code>属性为<code>multipart/form-data</code>，那么数据将以混合的格式发送。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form
  action=&quot;register.php&quot;
  method=&quot;post&quot;
  enctype=&quot;multipart/form-data&quot;
  onsubmit=&quot;AJAXSubmit(this); return false;&quot;
&gt;
&lt;/form&gt;
</code></pre></div><p>发送的 HTTP 请求如下。</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Type: multipart/form-data; boundary=---------------------------314911788813839

-----------------------------314911788813839
Content-Disposition: form-data; name=&quot;foo&quot;

bar
-----------------------------314911788813839
Content-Disposition: form-data; name=&quot;baz&quot;

The first line.
The second line.

-----------------------------314911788813839--
</code></pre></div><p>这种格式也是文件上传的格式。</p> <h3 id="文件上传"><a href="#文件上传" class="header-anchor">#</a> 文件上传</h3> <p>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot;&gt;
</code></pre></div><p>此外，还需要将表单<code>&lt;form&gt;</code>元素的<code>method</code>属性设为<code>POST</code>，<code>enctype</code>属性设为<code>multipart/form-data</code>。其中，<code>enctype</code>属性决定了 HTTP 头信息的<code>Content-Type</code>字段的值，默认情况下这个字段的值是<code>application/x-www-form-urlencoded</code>，但是文件上传的时候要改成<code>multipart/form-data</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
  &lt;div&gt;
    &lt;label for=&quot;file&quot;&gt;选择一个文件&lt;/label&gt;
    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;myFile&quot; multiple&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type=&quot;submit&quot; id=&quot;submit&quot; name=&quot;submit_button&quot; value=&quot;上传&quot; /&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre></div><p>上面的 HTML 代码中，file 控件的<code>multiple</code>属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</p> <div class="language- extra-class"><pre class="language-text"><code>var fileSelect = document.getElementById('file');
var files = fileSelect.files;
</code></pre></div><p>然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</p> <div class="language- extra-class"><pre class="language-text"><code>var formData = new FormData();

for (var i = 0; i &lt; files.length; i++) {
  var file = files[i];

  // 只上传图片文件
  if (!file.type.match('image.*')) {
    continue;
  }

  formData.append('photos[]', file, file.name);
}
</code></pre></div><p>最后，使用 Ajax 向服务器上传文件。</p> <div class="language- extra-class"><pre class="language-text"><code>var xhr = new XMLHttpRequest();

xhr.open('POST', 'handler.php', true);

xhr.onload = function () {
  if (xhr.status !== 200) {
    console.log('An error occurred!');
  }
};

xhr.send(formData);
</code></pre></div><p>除了发送 FormData 实例，也可以直接 AJAX 发送文件。</p> <div class="language- extra-class"><pre class="language-text"><code>var file = document.getElementById('test-input').files[0];
var xhr = new XMLHttpRequest();

xhr.open('POST', 'myserver/uploads');
xhr.setRequestHeader('Content-Type', file.type);
xhr.send(file);
</code></pre></div><h3 id="参考链接-4"><a href="#参考链接-4" class="header-anchor">#</a> 参考链接</h3> <ul><li><a href="https://webdesign.tutsplus.com/tutorials/html5-form-validation-with-the-pattern-attribute--cms-25145" target="_blank" rel="noopener noreferrer">HTML5 Form Validation With the “pattern” Attribute<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, Thoriq Firdaus</li></ul> <h2 id="indexdb-api"><a href="#indexdb-api" class="header-anchor">#</a> IndexDB API</h2> <h3 id="概述-5"><a href="#概述-5" class="header-anchor">#</a> 概述</h3> <p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p> <p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p> <p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p> <p>IndexedDB 具有以下特点。</p> <p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p> <p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p> <p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p> <p><strong>（4）同源限制。</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p> <p><strong>（5）储存空间大。</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p> <p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p> <ul><li>数据库：IDBDatabase 对象</li> <li>对象仓库：IDBObjectStore 对象</li> <li>索引： IDBIndex 对象</li> <li>事务： IDBTransaction 对象</li> <li>操作请求：IDBRequest 对象</li> <li>指针： IDBCursor 对象</li> <li>主键集合：IDBKeyRange 对象</li></ul> <p>下面是一些主要的概念。</p> <p><strong>（1）数据库</strong></p> <p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p> <p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p> <p><strong>（2）对象仓库</strong></p> <p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p> <p><strong>（3）数据记录</strong></p> <p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p> <div class="language- extra-class"><pre class="language-text"><code>{ id: 1, text: 'foo' }
</code></pre></div><p>上面的对象中，<code>id</code>属性可以当作主键。</p> <p>数据体可以是任意数据类型，不限于对象。</p> <p><strong>（4）索引</strong></p> <p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p> <p><strong>（5）事务</strong></p> <p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p> <h3 id="操作流程"><a href="#操作流程" class="header-anchor">#</a> 操作流程</h3> <p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 放在后文介绍。</p> <h4 id="打开数据库"><a href="#打开数据库" class="header-anchor">#</a> 打开数据库</h4> <p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>var request = window.indexedDB.open(databaseName, version);
</code></pre></div><p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为<code>1</code>。</p> <p><code>indexedDB.open()</code>方法返回一个 IDBRequest 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p> <p><strong>（1）error 事件</strong></p> <p><code>error</code>事件表示打开数据库失败。</p> <div class="language- extra-class"><pre class="language-text"><code>request.onerror = function (event) {
  console.log('数据库打开报错');
};
</code></pre></div><p><strong>（2）success 事件</strong></p> <p><code>success</code>事件表示成功打开数据库。</p> <div class="language- extra-class"><pre class="language-text"><code>var db;

request.onsuccess = function (event) {
  db = request.result;
  console.log('数据库打开成功');
};
</code></pre></div><p>这时，通过<code>request</code>对象的<code>result</code>属性拿到数据库对象。</p> <p><strong>（3）upgradeneeded 事件</strong></p> <p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>upgradeneeded</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var db;

request.onupgradeneeded = function (event) {
  db = event.target.result;
}
</code></pre></div><p>这时通过事件对象的<code>target.result</code>属性，拿到数据库实例。</p> <h4 id="新建数据库"><a href="#新建数据库" class="header-anchor">#</a> 新建数据库</h4> <p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在<code>upgradeneeded</code>事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p> <p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p> <div class="language- extra-class"><pre class="language-text"><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore('person', { keyPath: 'id' });
}
</code></pre></div><p>上面代码中，数据库新建成功以后，新增一张叫做<code>person</code>的表格，主键是<code>id</code>。</p> <p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p> <div class="language- extra-class"><pre class="language-text"><code>request.onupgradeneeded = function (event) {
  db = event.target.result;
  var objectStore;
  if (!db.objectStoreNames.contains('person')) {
    objectStore = db.createObjectStore('person', { keyPath: 'id' });
  }
}
</code></pre></div><p>主键（key）是默认建立索引的属性。比如，数据记录是<code>{ id: 1, name: '张三' }</code>，那么<code>id</code>属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>{ foo: { bar: 'baz' } }</code>的<code>foo.bar</code>也可以指定为主键。</p> <p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p> <div class="language- extra-class"><pre class="language-text"><code>var objectStore = db.createObjectStore(
  'person',
  { autoIncrement: true }
);
</code></pre></div><p>上面代码中，指定主键为一个递增的整数。</p> <p>新建对象仓库以后，下一步可以新建索引。</p> <div class="language- extra-class"><pre class="language-text"><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore('person', { keyPath: 'id' });
  objectStore.createIndex('name', 'name', { unique: false });
  objectStore.createIndex('email', 'email', { unique: true });
}
</code></pre></div><p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p> <h4 id="新增数据"><a href="#新增数据" class="header-anchor">#</a> 新增数据</h4> <p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p> <div class="language- extra-class"><pre class="language-text"><code>function add() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });

  request.onsuccess = function (event) {
    console.log('数据写入成功');
  };

  request.onerror = function (event) {
    console.log('数据写入失败');
  }
}

add();
</code></pre></div><p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的<code>add()</code>方法，向表格写入一条记录。</p> <p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p> <h4 id="读取数据"><a href="#读取数据" class="header-anchor">#</a> 读取数据</h4> <p>读取数据也是通过事务完成。</p> <div class="language- extra-class"><pre class="language-text"><code>function read() {
   var transaction = db.transaction(['person']);
   var objectStore = transaction.objectStore('person');
   var request = objectStore.get(1);

   request.onerror = function(event) {
     console.log('事务失败');
   };

   request.onsuccess = function( event) {
      if (request.result) {
        console.log('Name: ' + request.result.name);
        console.log('Age: ' + request.result.age);
        console.log('Email: ' + request.result.email);
      } else {
        console.log('未获得数据记录');
      }
   };
}

read();
</code></pre></div><p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p> <h4 id="遍历数据"><a href="#遍历数据" class="header-anchor">#</a> 遍历数据</h4> <p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p> <div class="language- extra-class"><pre class="language-text"><code>function readAll() {
  var objectStore = db.transaction('person').objectStore('person');

   objectStore.openCursor().onsuccess = function (event) {
     var cursor = event.target.result;

     if (cursor) {
       console.log('Id: ' + cursor.key);
       console.log('Name: ' + cursor.value.name);
       console.log('Age: ' + cursor.value.age);
       console.log('Email: ' + cursor.value.email);
       cursor.continue();
    } else {
      console.log('没有更多数据了！');
    }
  };
}

readAll();
</code></pre></div><p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p> <h4 id="更新数据"><a href="#更新数据" class="header-anchor">#</a> 更新数据</h4> <p>更新数据要使用<code>IDBObject.put()</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>function update() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });

  request.onsuccess = function (event) {
    console.log('数据更新成功');
  };

  request.onerror = function (event) {
    console.log('数据更新失败');
  }
}

update();
</code></pre></div><p>上面代码中，<code>put()</code>方法自动更新了主键为<code>1</code>的记录。</p> <h4 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h4> <p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p> <div class="language- extra-class"><pre class="language-text"><code>function remove() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .delete(1);

  request.onsuccess = function (event) {
    console.log('数据删除成功');
  };
}

remove();
</code></pre></div><h4 id="使用索引"><a href="#使用索引" class="header-anchor">#</a> 使用索引</h4> <p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p> <p>假定新建表格的时候，对<code>name</code>字段建立了索引。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.createIndex('name', 'name', { unique: false });
</code></pre></div><p>现在，就可以从<code>name</code>找到对应的数据记录了。</p> <div class="language- extra-class"><pre class="language-text"><code>var transaction = db.transaction(['person'], 'readonly');
var store = transaction.objectStore('person');
var index = store.index('name');
var request = index.get('李四');

request.onsuccess = function (e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
}
</code></pre></div><h3 id="indexeddb-对象"><a href="#indexeddb-对象" class="header-anchor">#</a> indexedDB 对象</h3> <p>浏览器原生提供<code>indexedDB</code>对象，作为开发者的操作接口。</p> <h4 id="indexeddb-open"><a href="#indexeddb-open" class="header-anchor">#</a> indexedDB.open()</h4> <p><code>indexedDB.open()</code>方法用于打开数据库。这是一个异步操作，但是会立刻返回一个 IDBOpenDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var openRequest = window.indexedDB.open('test', 1);
</code></pre></div><p>上面代码表示，打开一个名为<code>test</code>、版本为<code>1</code>的数据库。如果该数据库不存在，则会新建该数据库。</p> <p><code>open()</code>方法的第一个参数是数据库名称，格式为字符串，不可省略；第二个参数是数据库版本，是一个大于<code>0</code>的正整数（<code>0</code>将报错），如果该参数大于当前版本，会触发数据库升级。第二个参数可省略，如果数据库已存在，将打开当前版本的数据库；如果数据库不存在，将创建该版本的数据库，默认版本为<code>1</code>。</p> <p>打开数据库是异步操作，通过各种事件通知客户端。下面是有可能触发的4种事件。</p> <ul><li><strong>success</strong>：打开成功。</li> <li><strong>error</strong>：打开失败。</li> <li><strong>upgradeneeded</strong>：第一次打开该数据库，或者数据库版本发生变化。</li> <li><strong>blocked</strong>：上一次的数据库连接还未关闭。</li></ul> <p>第一次打开数据库时，会先触发<code>upgradeneeded</code>事件，然后触发<code>success</code>事件。</p> <p>根据不同的需要，对上面4种事件监听函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var openRequest = indexedDB.open('test', 1);
var db;

openRequest.onupgradeneeded = function (e) {
  console.log('Upgrading...');
}

openRequest.onsuccess = function (e) {
  console.log('Success!');
  db = openRequest.result;
}

openRequest.onerror = function (e) {
  console.log('Error');
  console.log(e);
}
</code></pre></div><p>上面代码有两个地方需要注意。首先，<code>open()</code>方法返回的是一个对象（IDBOpenDBRequest），监听函数就定义在这个对象上面。其次，<code>success</code>事件发生后，从<code>openRequest.result</code>属性可以拿到已经打开的<code>IndexedDB</code>数据库对象。</p> <h3 id="indexeddb-deletedatabase"><a href="#indexeddb-deletedatabase" class="header-anchor">#</a> indexedDB.deleteDatabase()</h3> <p><code>indexedDB.deleteDatabase()</code>方法用于删除一个数据库，参数为数据库的名字。它会立刻返回一个<code>IDBOpenDBRequest</code>对象，然后对数据库执行异步删除。删除操作的结果会通过事件通知，<code>IDBOpenDBRequest</code>对象可以监听以下事件。</p> <ul><li><code>success</code>：删除成功</li> <li><code>error</code>：删除报错</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var DBDeleteRequest = window.indexedDB.deleteDatabase('demo');

DBDeleteRequest.onerror = function (event) {
  console.log('Error');
};

DBDeleteRequest.onsuccess = function (event) {
  console.log('success');
};
</code></pre></div><p>调用<code>deleteDatabase()</code>方法以后，当前数据库的其他已经打开的连接都会接收到<code>versionchange</code>事件。</p> <p>注意，删除不存在的数据库并不会报错。</p> <h3 id="indexeddb-cmp"><a href="#indexeddb-cmp" class="header-anchor">#</a> indexedDB.cmp()</h3> <p><code>indexedDB.cmp()</code>方法比较两个值是否为 indexedDB 的相同的主键。它返回一个整数，表示比较的结果：<code>0</code>表示相同，<code>1</code>表示第一个主键大于第二个主键，<code>-1</code>表示第一个主键小于第二个主键。</p> <div class="language- extra-class"><pre class="language-text"><code>window.indexedDB.cmp(1, 2) // -1
</code></pre></div><p>注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>window.indexedDB.cmp(1, true) // 报错
window.indexedDB.cmp({}, {}) // 报错
</code></pre></div><h2 id="idbrequest-对象"><a href="#idbrequest-对象" class="header-anchor">#</a> IDBRequest 对象</h2> <p>IDBRequest 对象表示打开的数据库连接，<code>indexedDB.open()</code>方法和<code>indexedDB.deleteDatabase()</code>方法会返回这个对象。数据库的操作都是通过这个对象完成的。</p> <p>这个对象的所有操作都是异步操作，要通过<code>readyState</code>属性判断是否完成，如果为<code>pending</code>就表示操作正在进行，如果为<code>done</code>就表示操作完成，可能成功也可能失败。</p> <p>操作完成以后，触发<code>success</code>事件或<code>error</code>事件，这时可以通过<code>result</code>属性和<code>error</code>属性拿到操作结果。如果在<code>pending</code>阶段，就去读取这两个属性，是会报错的。</p> <p>IDBRequest 对象有以下属性。</p> <ul><li><code>IDBRequest.readyState</code>：等于<code>pending</code>表示操作正在进行，等于<code>done</code>表示操作正在完成。</li> <li><code>IDBRequest.result</code>：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。</li> <li><code>IDBRequest.error</code>：请求失败时，返回错误对象。</li> <li><code>IDBRequest.source</code>：返回请求的来源（比如索引对象或 ObjectStore）。</li> <li><code>IDBRequest.transaction</code>：返回当前请求正在进行的事务，如果不包含事务，返回<code>null</code>。</li> <li><code>IDBRequest.onsuccess</code>：指定<code>success</code>事件的监听函数。</li> <li><code>IDBRequest.onerror</code>：指定<code>error</code>事件的监听函数。</li></ul> <p>IDBOpenDBRequest 对象继承了 IDBRequest 对象，提供了两个额外的事件监听属性。</p> <ul><li><code>IDBOpenDBRequest.onblocked</code>：指定<code>blocked</code>事件（<code>upgradeneeded</code>事件触发时，数据库仍然在使用）的监听函数。</li> <li><code>IDBOpenDBRequest.onupgradeneeded</code>：<code>upgradeneeded</code>事件的监听函数。</li></ul> <h2 id="idbdatabase-对象"><a href="#idbdatabase-对象" class="header-anchor">#</a> IDBDatabase 对象</h2> <p>打开数据成功以后，可以从<code>IDBOpenDBRequest</code>对象的<code>result</code>属性上面，拿到一个<code>IDBDatabase</code>对象，它表示连接的数据库。后面对数据库的操作，都通过这个对象完成。</p> <div class="language- extra-class"><pre class="language-text"><code>var db;
var DBOpenRequest = window.indexedDB.open('demo', 1);

DBOpenRequest.onerror = function (event) {
  console.log('Error');
};

DBOpenRequest.onsuccess = function(event) {
  db = DBOpenRequest.result;
  // ...
};
</code></pre></div><h3 id="属性-3"><a href="#属性-3" class="header-anchor">#</a> 属性</h3> <p>IDBDatabase 对象有以下属性。</p> <ul><li><code>IDBDatabase.name</code>：字符串，数据库名称。</li> <li><code>IDBDatabase.version</code>：整数，数据库版本。数据库第一次创建时，该属性为空字符串。</li> <li><code>IDBDatabase.objectStoreNames</code>：DOMStringList 对象（字符串的集合），包含当前数据的所有 object store 的名字。</li> <li><code>IDBDatabase.onabort</code>：指定 abort 事件（事务中止）的监听函数。</li> <li><code>IDBDatabase.onclose</code>：指定 close 事件（数据库意外关闭）的监听函数。</li> <li><code>IDBDatabase.onerror</code>：指定 error 事件（访问数据库失败）的监听函数。</li> <li><code>IDBDatabase.onversionchange</code>：数据库版本变化时触发（发生<code>upgradeneeded</code>事件，或调用<code>indexedDB.deleteDatabase()</code>）。</li></ul> <p>下面是<code>objectStoreNames</code>属性的例子。该属性返回一个 DOMStringList 对象，包含了当前数据库所有对象仓库的名称（即表名），可以使用 DOMStringList 对象的<code>contains</code>方法，检查数据库是否包含某个对象仓库。</p> <div class="language- extra-class"><pre class="language-text"><code>if (!db.objectStoreNames.contains('firstOS')) {
  db.createObjectStore('firstOS');
}
</code></pre></div><p>上面代码先判断某个对象仓库是否存在，如果不存在就创建该对象仓库。</p> <h3 id="方法-3"><a href="#方法-3" class="header-anchor">#</a> 方法</h3> <p>IDBDatabase 对象有以下方法。</p> <ul><li><code>IDBDatabase.close()</code>：关闭数据库连接，实际会等所有事务完成后再关闭。</li> <li><code>IDBDatabase.createObjectStore()</code>：创建存放数据的对象仓库，类似于传统关系型数据库的表格，返回一个 IDBObjectStore 对象。该方法只能在<code>versionchange</code>事件监听函数中调用。</li> <li><code>IDBDatabase.deleteObjectStore()</code>：删除指定的对象仓库。该方法只能在<code>versionchange</code>事件监听函数中调用。</li> <li><code>IDBDatabase.transaction()</code>：返回一个 IDBTransaction 事务对象。</li></ul> <p>下面是<code>createObjectStore()</code>方法的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var request = window.indexedDB.open('demo', 2);

request.onupgradeneeded = function (event) {
  var db = event.target.result;

  db.onerror = function(event) {
    console.log('error');
  };

  var objectStore = db.createObjectStore('items');

  // ...
};
</code></pre></div><p>上面代码创建了一个名为<code>items</code>的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。为了避免出错，需要用到下文的<code>objectStoreNames</code>属性，检查已有哪些对象仓库。</p> <p><code>createObjectStore()</code>方法还可以接受第二个对象参数，用来设置对象仓库的属性。</p> <div class="language- extra-class"><pre class="language-text"><code>db.createObjectStore('test', { keyPath: 'email' });
db.createObjectStore('test2', { autoIncrement: true });
</code></pre></div><p>上面代码中，<code>keyPath</code>属性表示主键（由于主键的值不能重复，所以上例存入之前，必须保证数据的<code>email</code>属性值都是不一样的），默认值为<code>null</code>；<code>autoIncrement</code>属性表示，是否使用自动递增的整数作为主键（第一个数据记录为1，第二个数据记录为2，以此类推），默认为<code>false</code>。一般来说，<code>keyPath</code>和<code>autoIncrement</code>属性只要使用一个就够了，如果两个同时使用，表示主键为递增的整数，且对象不得缺少<code>keyPath</code>指定的属性。</p> <p>下面是<code>deleteObjectStore()</code>方法的例子。</p> <div class="language- extra-class"><pre class="language-text"><code>var dbName = 'sampleDB';
var dbVersion = 2;
var request = indexedDB.open(dbName, dbVersion);

request.onupgradeneeded = function(e) {
  var db = request.result;
  if (e.oldVersion &lt; 1) {
    db.createObjectStore('store1');
  }

  if (e.oldVersion &lt; 2) {
    db.deleteObjectStore('store1');
    db.createObjectStore('store2');
  }

  // ...
};
</code></pre></div><p>下面是<code>transaction()</code>方法的例子，该方法用于创建一个数据库事务，返回一个 IDBTransaction 对象。向数据库添加数据之前，必须先创建数据库事务。</p> <div class="language- extra-class"><pre class="language-text"><code>var t = db.transaction(['items'], 'readwrite');
</code></pre></div><p><code>transaction()</code>方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：<code>readonly</code>（只读）和<code>readwrite</code>（读写）。添加数据使用<code>readwrite</code>，读取数据使用<code>readonly</code>。第二个参数是可选的，省略时默认为<code>readonly</code>模式。</p> <h2 id="idbobjectstore-对象"><a href="#idbobjectstore-对象" class="header-anchor">#</a> IDBObjectStore 对象</h2> <p>IDBObjectStore 对象对应一个对象仓库（object store）。<code>IDBDatabase.createObjectStore()</code>方法返回的就是一个 IDBObjectStore 对象。</p> <p>IDBDatabase 对象的<code>transaction()</code>返回一个事务对象，该对象的<code>objectStore()</code>方法返回 IDBObjectStore 对象，因此可以采用下面的链式写法。</p> <div class="language- extra-class"><pre class="language-text"><code>db.transaction(['test'], 'readonly')
  .objectStore('test')
  .get(X)
  .onsuccess = function (e) {}
</code></pre></div><h3 id="属性-4"><a href="#属性-4" class="header-anchor">#</a> 属性</h3> <p>IDBObjectStore 对象有以下属性。</p> <ul><li><code>IDBObjectStore.indexNames</code>：返回一个类似数组的对象（DOMStringList），包含了当前对象仓库的所有索引。</li> <li><code>IDBObjectStore.keyPath</code>：返回当前对象仓库的主键。</li> <li><code>IDBObjectStore.name</code>：返回当前对象仓库的名称。</li> <li><code>IDBObjectStore.transaction</code>：返回当前对象仓库所属的事务对象。</li> <li><code>IDBObjectStore.autoIncrement</code>：布尔值，表示主键是否会自动递增。</li></ul> <h3 id="方法-4"><a href="#方法-4" class="header-anchor">#</a> 方法</h3> <p>IDBObjectStore 对象有以下方法。</p> <p><strong>（1）IDBObjectStore.add()</strong></p> <p><code>IDBObjectStore.add()</code>用于向对象仓库添加数据，返回一个 IDBRequest 对象。该方法只用于添加数据，如果主键相同会报错，因此更新数据必须使用<code>put()</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.add(value, key)
</code></pre></div><p>该方法接受两个参数，第一个参数是键值，第二个参数是主键，该参数可选，如果省略默认为<code>null</code>。</p> <p>创建事务以后，就可以获取对象仓库，然后使用<code>add()</code>方法往里面添加数据了。</p> <div class="language- extra-class"><pre class="language-text"><code>var db;
var DBOpenRequest = window.indexedDB.open('demo', 1);

DBOpenRequest.onsuccess = function (event) {
  db = DBOpenRequest.result;
  var transaction = db.transaction(['items'], 'readwrite');

  transaction.oncomplete = function (event) {
    console.log('transaction success');
  };

  transaction.onerror = function (event) {
    console.log('transaction error: ' + transaction.error);
  };

  var objectStore = transaction.objectStore('items');
  var objectStoreRequest = objectStore.add({ foo: 1 });

  objectStoreRequest.onsuccess = function (event) {
    console.log('add data success');
  };

};
</code></pre></div><p><strong>（2）IDBObjectStore.put()</strong></p> <p><code>IDBObjectStore.put()</code>方法用于更新某个主键对应的数据记录，如果对应的键值不存在，则插入一条新的记录。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.put(item, key)
</code></pre></div><p>该方法接受两个参数，第一个参数为新数据，第二个参数为主键，该参数可选，且只在自动递增时才有必要提供，因为那时主键不包含在数据值里面。</p> <p><strong>（3）IDBObjectStore.clear()</strong></p> <p><code>IDBObjectStore.clear()</code>删除当前对象仓库的所有记录。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.clear()
</code></pre></div><p>该方法不需要参数。</p> <p><strong>（4）IDBObjectStore.delete()</strong></p> <p><code>IDBObjectStore.delete()</code>方法用于删除指定主键的记录。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.delete(Key)
</code></pre></div><p>该方法的参数为主键的值。</p> <p><strong>（5）IDBObjectStore.count()</strong></p> <p><code>IDBObjectStore.count()</code>方法用于计算记录的数量。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>IDBObjectStore.count(key)
</code></pre></div><p>不带参数时，该方法返回当前对象仓库的所有记录数量。如果主键或 IDBKeyRange 对象作为参数，则返回对应的记录数量。</p> <p><strong>（6）IDBObjectStore.getKey()</strong></p> <p><code>IDBObjectStore.getKey()</code>用于获取主键。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.getKey(key)
</code></pre></div><p>该方法的参数可以是主键值或 IDBKeyRange 对象。</p> <p><strong>（7）IDBObjectStore.get()</strong></p> <p><code>IDBObjectStore.get()</code>用于获取主键对应的数据记录。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.get(key)
</code></pre></div><p><strong>（8）IDBObjectStore.getAll()</strong></p> <p><code>DBObjectStore.getAll()</code>用于获取对象仓库的记录。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>// 获取所有记录
objectStore.getAll()

// 获取所有符合指定主键或 IDBKeyRange 的记录
objectStore.getAll(query)

// 指定获取记录的数量
objectStore.getAll(query, count)
</code></pre></div><p><strong>（9）IDBObjectStore.getAllKeys()</strong></p> <p><code>IDBObjectStore.getAllKeys()</code>用于获取所有符合条件的主键。该方法返回一个 IDBRequest 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>// 获取所有记录的主键
objectStore.getAllKeys()

// 获取所有符合条件的主键
objectStore.getAllKeys(query)

// 指定获取主键的数量
objectStore.getAllKeys(query, count)
</code></pre></div><p><strong>（10）IDBObjectStore.index()</strong></p> <p><code>IDBObjectStore.index()</code>方法返回指定名称的索引对象 IDBIndex。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.index(name)
</code></pre></div><p>有了索引以后，就可以针对索引所在的属性读取数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var t = db.transaction(['people'], 'readonly');
var store = t.objectStore('people');
var index = store.index('name');

var request = index.get('foo');
</code></pre></div><p>上面代码打开对象仓库以后，先用<code>index()</code>方法指定获取<code>name</code>属性的索引，然后用<code>get()</code>方法读取某个<code>name</code>属性(<code>foo</code>)对应的数据。如果<code>name</code>属性不是对应唯一值，这时<code>get()</code>方法有可能取回多个数据对象。另外，<code>get()</code>是异步方法，读取成功以后，只能在<code>success</code>事件的监听函数中处理数据。</p> <p><strong>（11）IDBObjectStore.createIndex()</strong></p> <p><code>IDBObjectStore.createIndex()</code>方法用于新建当前数据库的一个索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.createIndex(indexName, keyPath, objectParameters)
</code></pre></div><p>该方法可以接受三个参数。</p> <ul><li>indexName：索引名</li> <li>keyPath：主键</li> <li>objectParameters：配置对象（可选）</li></ul> <p>第三个参数可以配置以下属性。</p> <ul><li>unique：如果设为<code>true</code>，将不允许重复的值</li> <li>multiEntry：如果设为<code>true</code>，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。</li></ul> <p>假定对象仓库中的数据记录都是如下的<code>person</code>类型。</p> <div class="language- extra-class"><pre class="language-text"><code>var person = {
  name: name,
  email: email,
  created: new Date()
};
</code></pre></div><p>可以指定这个对象的某个属性来建立索引。</p> <div class="language- extra-class"><pre class="language-text"><code>var store = db.createObjectStore('people', { autoIncrement: true });

store.createIndex('name', 'name', { unique: false });
store.createIndex('email', 'email', { unique: true });
</code></pre></div><p>上面代码告诉索引对象，<code>name</code>属性不是唯一值，<code>email</code>属性是唯一值。</p> <p><strong>（12）IDBObjectStore.deleteIndex()</strong></p> <p><code>IDBObjectStore.deleteIndex()</code>方法用于删除指定的索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p> <div class="language- extra-class"><pre class="language-text"><code>objectStore.deleteIndex(indexName)
</code></pre></div><p><strong>（13）IDBObjectStore.openCursor()</strong></p> <p><code>IDBObjectStore.openCursor()</code>用于获取一个指针对象。</p> <div class="language- extra-class"><pre class="language-text"><code>IDBObjectStore.openCursor()
</code></pre></div><p>指针对象可以用来遍历数据。该对象也是异步的，有自己的<code>success</code>和<code>error</code>事件，可以对它们指定监听函数。</p> <div class="language- extra-class"><pre class="language-text"><code>var t = db.transaction(['test'], 'readonly');
var store = t.objectStore('test');

var cursor = store.openCursor();

cursor.onsuccess = function (event) {
  var res = event.target.result;
  if (res) {
    console.log('Key', res.key);
    console.dir('Data', res.value);
    res.continue();
  }
}
</code></pre></div><p>监听函数接受一个事件对象作为参数，该对象的<code>target.result</code>属性指向当前数据记录。该记录的<code>key</code>和<code>value</code>分别返回主键和键值（即实际存入的数据）。<code>continue()</code>方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向<code>null</code>。</p> <p><code>openCursor()</code>方法的第一个参数是主键值，或者一个 IDBKeyRange 对象。如果指定该参数，将只处理包含指定主键的记录；如果省略，将处理所有的记录。该方法还可以接受第二个参数，表示遍历方向，默认值为<code>next</code>，其他可能的值为<code>prev</code>、<code>nextunique</code>和<code>prevunique</code>。后两个值表示如果遇到重复值，会自动跳过。</p> <p><strong>（14）IDBObjectStore.openKeyCursor()</strong></p> <p><code>IDBObjectStore.openKeyCursor()</code>用于获取一个主键指针对象。</p> <div class="language- extra-class"><pre class="language-text"><code>IDBObjectStore.openKeyCursor()
</code></pre></div><h2 id="idbtransaction-对象"><a href="#idbtransaction-对象" class="header-anchor">#</a> IDBTransaction 对象</h2> <p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p> <p><code>IDBDatabase.transaction()</code>方法返回的就是一个 IDBTransaction 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var db;
var DBOpenRequest = window.indexedDB.open('demo', 1);

DBOpenRequest.onsuccess = function(event) {
  db = DBOpenRequest.result;
  var transaction = db.transaction(['demo'], 'readwrite');

  transaction.oncomplete = function (event) {
    console.log('transaction success');
  };

  transaction.onerror = function (event) {
    console.log('transaction error: ' + transaction.error);
  };

  var objectStore = transaction.objectStore('demo');
  var objectStoreRequest = objectStore.add({ foo: 1 });

  objectStoreRequest.onsuccess = function (event) {
    console.log('add data success');
  };

};
</code></pre></div><p>事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p> <div class="language- extra-class"><pre class="language-text"><code>var trans1 = db.transaction('foo', 'readwrite');
var trans2 = db.transaction('foo', 'readwrite');
var objectStore2 = trans2.objectStore('foo')
var objectStore1 = trans1.objectStore('foo')
objectStore2.put('2', 'key');
objectStore1.put('1', 'key');
</code></pre></div><p>上面代码中，<code>key</code>对应的键值最终是<code>2</code>，而不是<code>1</code>。因为事务<code>trans1</code>先于<code>trans2</code>创建，所以首先执行。</p> <p>注意，事务有可能失败，只有监听到事务的<code>complete</code>事件，才能保证事务操作成功。</p> <p>IDBTransaction 对象有以下属性。</p> <ul><li><code>IDBTransaction.db</code>：返回当前事务所在的数据库对象 IDBDatabase。</li> <li><code>IDBTransaction.error</code>：返回当前事务的错误。如果事务没有结束，或者事务成功结束，或者被手动终止，该方法返回<code>null</code>。</li> <li><code>IDBTransaction.mode</code>：返回当前事务的模式，默认是<code>readonly</code>（只读），另一个值是<code>readwrite</code>。</li> <li><code>IDBTransaction.objectStoreNames</code>：返回一个类似数组的对象 DOMStringList，成员是当前事务涉及的对象仓库的名字。</li> <li><code>IDBTransaction.onabort</code>：指定<code>abort</code>事件（事务中断）的监听函数。</li> <li><code>IDBTransaction.oncomplete</code>：指定<code>complete</code>事件（事务成功）的监听函数。</li> <li><code>IDBTransaction.onerror</code>：指定<code>error</code>事件（事务失败）的监听函数。</li></ul> <p>IDBTransaction 对象有以下方法。</p> <ul><li><code>IDBTransaction.abort()</code>：终止当前事务，回滚所有已经进行的变更。</li> <li><code>IDBTransaction.objectStore(name)</code>：返回指定名称的对象仓库 IDBObjectStore。</li></ul> <h2 id="idbindex-对象"><a href="#idbindex-对象" class="header-anchor">#</a> IDBIndex 对象</h2> <p>IDBIndex 对象代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认就是带有索引，IDBIndex 对象主要用于通过除主键以外的其他键，建立索引获取对象。</p> <p>IDBIndex 是持久性的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p> <p><code>IDBObjectStore.index()</code>方法可以获取 IDBIndex 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>var transaction = db.transaction(['contactsList'], 'readonly');
var objectStore = transaction.objectStore('contactsList');
var myIndex = objectStore.index('lName');

myIndex.openCursor().onsuccess = function (event) {
  var cursor = event.target.result;
  if (cursor) {
    var tableRow = document.createElement('tr');
    tableRow.innerHTML =   '&lt;td&gt;' + cursor.value.id + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.lName + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.fName + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.jTitle + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.company + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.eMail + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.phone + '&lt;/td&gt;'
                         + '&lt;td&gt;' + cursor.value.age + '&lt;/td&gt;';
    tableEntry.appendChild(tableRow);

    cursor.continue();
  } else {
    console.log('Entries all displayed.');
  }
};
</code></pre></div><p>IDBIndex 对象有以下属性。</p> <ul><li><code>IDBIndex.name</code>：字符串，索引的名称。</li> <li><code>IDBIndex.objectStore</code>：索引所在的对象仓库。</li> <li><code>IDBIndex.keyPath</code>：索引的主键。</li> <li><code>IDBIndex.multiEntry</code>：布尔值，针对<code>keyPath</code>为数组的情况，如果设为<code>true</code>，创建数组时，每个数组成员都会有一个条目，否则每个数组都只有一个条目。</li> <li><code>IDBIndex.unique</code>：布尔值，表示创建索引时是否允许相同的主键。</li></ul> <p>IDBIndex 对象有以下方法，它们都是异步的，立即返回的都是一个 IDBRequest 对象。</p> <ul><li><code>IDBIndex.count()</code>：用来获取记录的数量。它可以接受主键或 IDBKeyRange 对象作为参数，这时只返回符合主键的记录数量，否则返回所有记录的数量。</li> <li><code>IDBIndex.get(key)</code>：用来获取符合指定主键的数据记录。</li> <li><code>IDBIndex.getKey(key)</code>：用来获取指定的主键。</li> <li><code>IDBIndex.getAll()</code>：用来获取所有的数据记录。它可以接受两个参数，都是可选的，第一个参数用来指定主键，第二个参数用来指定返回记录的数量。如果省略这两个参数，则返回所有记录。由于获取成功时，浏览器必须生成所有对象，所以对性能有影响。如果数据集比较大，建议使用 IDBCursor 对象。</li> <li><code>IDBIndex.getAllKeys()</code>：该方法与<code>IDBIndex.getAll()</code>方法相似，区别是获取所有主键。</li> <li><code>IDBIndex.openCursor()</code>：用来获取一个 IDBCursor 对象，用来遍历索引里面的所有条目。</li> <li><code>IDBIndex.openKeyCursor()</code>：该方法与<code>IDBIndex.openCursor()</code>方法相似，区别是遍历所有条目的主键。</li></ul> <h2 id="idbcursor-对象"><a href="#idbcursor-对象" class="header-anchor">#</a> IDBCursor 对象</h2> <p>IDBCursor 对象代表指针对象，用来遍历数据仓库（IDBObjectStore）或索引（IDBIndex）的记录。</p> <p>IDBCursor 对象一般通过<code>IDBObjectStore.openCursor()</code>方法获得。</p> <div class="language- extra-class"><pre class="language-text"><code>var transaction = db.transaction(['rushAlbumList'], 'readonly');
var objectStore = transaction.objectStore('rushAlbumList');

objectStore.openCursor(null, 'next').onsuccess = function(event) {
  var cursor = event.target.result;
  if (cursor) {
    var listItem = document.createElement('li');
    listItem.innerHTML = cursor.value.albumTitle + ', ' + cursor.value.year;
    list.appendChild(listItem);

    console.log(cursor.source);
    cursor.continue();
  } else {
    console.log('Entries all displayed.');
  }
};
</code></pre></div><p>IDBCursor 对象的属性。</p> <ul><li><code>IDBCursor.source</code>：返回正在遍历的对象仓库或索引。</li> <li><code>IDBCursor.direction</code>：字符串，表示指针遍历的方向。共有四个可能的值：next（从头开始向后遍历）、nextunique（从头开始向后遍历，重复的值只遍历一次）、prev（从尾部开始向前遍历）、prevunique（从尾部开始向前遍历，重复的值只遍历一次）。该属性通过<code>IDBObjectStore.openCursor()</code>方法的第二个参数指定，一旦指定就不能改变了。</li> <li><code>IDBCursor.key</code>：返回当前记录的主键。</li> <li><code>IDBCursor.value</code>：返回当前记录的数据值。</li> <li><code>IDBCursor.primaryKey</code>：返回当前记录的主键。对于数据仓库（objectStore）来说，这个属性等同于 IDBCursor.key；对于索引，IDBCursor.key 返回索引的位置值，该属性返回数据记录的主键。</li></ul> <p>IDBCursor 对象有如下方法。</p> <ul><li><code>IDBCursor.advance(n)</code>：指针向前移动 n 个位置。</li> <li><code>IDBCursor.continue()</code>：指针向前移动一个位置。它可以接受一个主键作为参数，这时会跳转到这个主键。</li> <li><code>IDBCursor.continuePrimaryKey()</code>：该方法需要两个参数，第一个是<code>key</code>，第二个是<code>primaryKey</code>，将指针移到符合这两个参数的位置。</li> <li><code>IDBCursor.delete()</code>：用来删除当前位置的记录，返回一个 IDBRequest 对象。该方法不会改变指针的位置。</li> <li><code>IDBCursor.update()</code>：用来更新当前位置的记录，返回一个 IDBRequest 对象。它的参数是要写入数据库的新的值。</li></ul> <h2 id="idbkeyrange-对象"><a href="#idbkeyrange-对象" class="header-anchor">#</a> IDBKeyRange 对象</h2> <p>IDBKeyRange 对象代表数据仓库（object store）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。</p> <p>IDBKeyRange 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。</p> <ul><li><code>IDBKeyRange.lowerBound()</code>：指定下限。</li> <li><code>IDBKeyRange.upperBound()</code>：指定上限。</li> <li><code>IDBKeyRange.bound()</code>：同时指定上下限。</li> <li><code>IDBKeyRange.only()</code>：指定只包含一个值。</li></ul> <p>下面是一些代码实例。</p> <div class="language- extra-class"><pre class="language-text"><code>// All keys ≤ x
var r1 = IDBKeyRange.upperBound(x);

// All keys &lt; x
var r2 = IDBKeyRange.upperBound(x, true);

// All keys ≥ y
var r3 = IDBKeyRange.lowerBound(y);

// All keys &gt; y
var r4 = IDBKeyRange.lowerBound(y, true);

// All keys ≥ x &amp;&amp; ≤ y
var r5 = IDBKeyRange.bound(x, y);

// All keys &gt; x &amp;&amp;&lt; y
var r6 = IDBKeyRange.bound(x, y, true, true);

// All keys &gt; x &amp;&amp; ≤ y
var r7 = IDBKeyRange.bound(x, y, true, false);

// All keys ≥ x &amp;&amp;&lt; y
var r8 = IDBKeyRange.bound(x, y, false, true);

// The key = z
var r9 = IDBKeyRange.only(z);
</code></pre></div><p><code>IDBKeyRange.lowerBound()</code>、<code>IDBKeyRange.upperBound()</code>、<code>IDBKeyRange.bound()</code>这三个方法默认包括端点值，可以传入一个布尔值，修改这个属性。</p> <p>与之对应，IDBKeyRange 对象有四个只读属性。</p> <ul><li><code>IDBKeyRange.lower</code>：返回下限</li> <li><code>IDBKeyRange.lowerOpen</code>：布尔值，表示下限是否为开区间（即下限是否排除在范围之外）</li> <li><code>IDBKeyRange.upper</code>：返回上限</li> <li><code>IDBKeyRange.upperOpen</code>：布尔值，表示上限是否为开区间（即上限是否排除在范围之外）</li></ul> <p>IDBKeyRange 实例对象生成以后，将它作为参数输入 IDBObjectStore 或 IDBIndex 对象的<code>openCursor()</code>方法，就可以在所设定的范围内读取数据。</p> <div class="language- extra-class"><pre class="language-text"><code>var t = db.transaction(['people'], 'readonly');
var store = t.objectStore('people');
var index = store.index('name');

var range = IDBKeyRange.bound('B', 'D');

index.openCursor(range).onsuccess = function (e) {
  var cursor = e.target.result;
  if (cursor) {
    console.log(cursor.key + ':');

    for (var field in cursor.value) {
      console.log(cursor.value[field]);
    }
    cursor.continue();
  }
}
</code></pre></div><p>IDBKeyRange 有一个实例方法<code>includes(key)</code>，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。</p> <div class="language- extra-class"><pre class="language-text"><code>var keyRangeValue = IDBKeyRange.bound('A', 'K', false, false);

keyRangeValue.includes('F') // true
keyRangeValue.includes('W') // false
</code></pre></div><h2 id="参考链接-5"><a href="#参考链接-5" class="header-anchor">#</a> 参考链接</h2> <ul><li>Raymond Camden, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/working-with-indexeddb/" target="_blank" rel="noopener noreferrer">Working With IndexedDB – Part 1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Raymond Camden, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/working-with-indexeddb-part-2/" target="_blank" rel="noopener noreferrer">Working With IndexedDB – Part 2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Raymond Camden, <a href="https://code.tutsplus.com/tutorials/working-with-indexeddb-part-3--net-36220" target="_blank" rel="noopener noreferrer">Working With IndexedDB - Part 3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>Tiffany Brown, <a href="https://dev.opera.com/articles/introduction-to-indexeddb/" target="_blank" rel="noopener noreferrer">An Introduction to IndexedDB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>David Fahlander, <a href="https://hacks.mozilla.org/2014/06/breaking-the-borders-of-indexeddb/" target="_blank" rel="noopener noreferrer">Breaking the Borders of IndexedDB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>TutorialsPoint, <a href="https://www.tutorialspoint.com/html5/html5_indexeddb.htm" target="_blank" rel="noopener noreferrer">HTML5 - IndexedDB<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> Web Worker</h2> <h2 id="概述-6"><a href="#概述-6" class="header-anchor">#</a> 概述</h2> <p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p> <p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p> <p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p> <p>Web Worker 有以下几个使用注意点。</p> <p>（1）<strong>同源限制</strong></p> <p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p> <p>（2）<strong>DOM 限制</strong></p> <p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p> <p>（3）<strong>全局对象限制</strong></p> <p>Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p> <p>（4）<strong>通信联系</strong></p> <p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p> <p>（5）<strong>脚本限制</strong></p> <p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p> <p>（6）<strong>文件限制</strong></p> <p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p> <h2 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h2> <h3 id="主线程"><a href="#主线程" class="header-anchor">#</a> 主线程</h3> <p>主线程采用<code>new</code>命令，调用<code>Worker()</code>构造函数，新建一个 Worker 线程。</p> <div class="language- extra-class"><pre class="language-text"><code>var worker = new Worker('work.js');
</code></pre></div><p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p> <p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。</p> <div class="language- extra-class"><pre class="language-text"><code>worker.postMessage('Hello World');
worker.postMessage({method: 'echo', args: ['Work']});
</code></pre></div><p><code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p> <p>接着，主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p> <div class="language- extra-class"><pre class="language-text"><code>worker.onmessage = function (event) {
  doSomething(event.data);
}

function doSomething() {
  // 执行任务
  worker.postMessage('Work done!');
}
</code></pre></div><p>上面代码中，事件对象的<code>data</code>属性可以获取 Worker 发来的数据。</p> <p>Worker 完成任务以后，主线程就可以把它关掉。</p> <div class="language- extra-class"><pre class="language-text"><code>worker.terminate();
</code></pre></div><h3 id="worker-线程"><a href="#worker-线程" class="header-anchor">#</a> Worker 线程</h3> <p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>self.addEventListener('message', function (e) {
  self.postMessage('You said: ' + e.data);
}, false);
</code></pre></div><p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p> <div class="language- extra-class"><pre class="language-text"><code>// 写法一
this.addEventListener('message', function (e) {
  this.postMessage('You said: ' + e.data);
}, false);

// 写法二
addEventListener('message', function (e) {
  postMessage('You said: ' + e.data);
}, false);
</code></pre></div><p>除了使用<code>self.addEventListener()</code>指定监听函数，也可以使用<code>self.onmessage</code>指定。监听函数的参数是一个事件对象，它的<code>data</code>属性包含主线程发来的数据。<code>self.postMessage()</code>方法用来向主线程发送消息。</p> <p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>self.addEventListener('message', function (e) {
  var data = e.data;
  switch (data.cmd) {
    case 'start':
      self.postMessage('WORKER STARTED: ' + data.msg);
      break;
    case 'stop':
      self.postMessage('WORKER STOPPED: ' + data.msg);
      self.close(); // Terminates the worker.
      break;
    default:
      self.postMessage('Unknown command: ' + data.msg);
  };
}, false);
</code></pre></div><p>上面代码中，<code>self.close()</code>用于在 Worker 内部关闭自身。</p> <h3 id="worker-加载脚本"><a href="#worker-加载脚本" class="header-anchor">#</a> Worker 加载脚本</h3> <p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>importScripts('script1.js');
</code></pre></div><p>该方法可以同时加载多个脚本。</p> <div class="language- extra-class"><pre class="language-text"><code>importScripts('script1.js', 'script2.js');
</code></pre></div><h3 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h3> <p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>worker.onerror = function (event) {
  console.log(
    'ERROR: Line ', event.lineno, ' in ', event.filename, ': ', event.message
  );
};

// 或者
worker.addEventListener('error', function (event) {
  // ...
});
</code></pre></div><p>Worker 内部也可以监听<code>error</code>事件。</p> <h3 id="关闭-worker"><a href="#关闭-worker" class="header-anchor">#</a> 关闭 Worker</h3> <p>使用完毕，为了节省系统资源，必须关闭 Worker。</p> <div class="language- extra-class"><pre class="language-text"><code>// 主线程
worker.terminate();

// Worker 线程
self.close();
</code></pre></div><h2 id="数据通信"><a href="#数据通信" class="header-anchor">#</a> 数据通信</h2> <p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p> <p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p> <div class="language- extra-class"><pre class="language-text"><code>// 主线程
var uInt8Array = new Uint8Array(new ArrayBuffer(10));
for (var i = 0; i &lt; uInt8Array.length; ++i) {
  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]
}
worker.postMessage(uInt8Array);

// Worker 线程
self.onmessage = function (e) {
  var uInt8Array = e.data;
  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());
  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);
};
</code></pre></div><p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a href="https://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects" target="_blank" rel="noopener noreferrer">Transferable Objects<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p> <p>如果要直接转移数据的控制权，就要使用下面的写法。</p> <div class="language- extra-class"><pre class="language-text"><code>// Transferable Objects 格式
worker.postMessage(arrayBuffer, [arrayBuffer]);

// 例子
var ab = new ArrayBuffer(1);
worker.postMessage(ab, [ab]);
</code></pre></div><h2 id="同页面的-web-worker"><a href="#同页面的-web-worker" class="header-anchor">#</a> 同页面的 Web Worker</h2> <p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
  &lt;body&gt;
    &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt;
      addEventListener('message', function () {
        postMessage('some message');
      }, false);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>上面是一段嵌入网页的脚本，注意必须指定<code>&lt;script&gt;</code>标签的<code>type</code>属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p> <p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p> <div class="language- extra-class"><pre class="language-text"><code>var blob = new Blob([document.querySelector('#worker').textContent]);
var url = window.URL.createObjectURL(blob);
var worker = new Worker(url);

worker.onmessage = function (e) {
  // e.data === 'some message'
};
</code></pre></div><p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p> <h2 id="实例-worker-线程完成轮询"><a href="#实例-worker-线程完成轮询" class="header-anchor">#</a> 实例：Worker 线程完成轮询</h2> <p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p> <div class="language- extra-class"><pre class="language-text"><code>function createWorker(f) {
  var blob = new Blob(['(' + f.toString() + ')()']);
  var url = window.URL.createObjectURL(blob);
  var worker = new Worker(url);
  return worker;
}

var pollingWorker = createWorker(function (e) {
  var cache;

  function compare(new, old) { ... };

  setInterval(function () {
    fetch('/my-api-endpoint').then(function (res) {
      var data = res.json();

      if (!compare(data, cache)) {
        cache = data;
        self.postMessage(data);
      }
    })
  }, 1000)
});

pollingWorker.onmessage = function () {
  // render data
}

pollingWorker.postMessage('init');
</code></pre></div><p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p> <h2 id="实例-worker-新建-worker"><a href="#实例-worker-新建-worker" class="header-anchor">#</a> 实例： Worker 新建 Worker</h2> <p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p> <p>主线程代码如下。</p> <div class="language- extra-class"><pre class="language-text"><code>var worker = new Worker('worker.js');
worker.onmessage = function (event) {
  document.getElementById('result').textContent = event.data;
};
</code></pre></div><p>Worker 线程代码如下。</p> <div class="language- extra-class"><pre class="language-text"><code>// worker.js

// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i &lt; num_workers; i += 1) {
  var worker = new Worker('core.js');
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i + 1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += event.data;
  pending_workers -= 1;
  if (pending_workers &lt;= 0)
    postMessage(result); // finished!
}
</code></pre></div><p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p> <div class="language- extra-class"><pre class="language-text"><code>// core.js
var start;
onmessage = getStart;
function getStart(event) {
  start = event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i &lt; end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}
</code></pre></div><h2 id="api"><a href="#api" class="header-anchor">#</a> API</h2> <h3 id="主线程-2"><a href="#主线程-2" class="header-anchor">#</a> 主线程</h3> <p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p> <div class="language- extra-class"><pre class="language-text"><code>var myWorker = new Worker(jsUrl, options);
</code></pre></div><p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p> <div class="language- extra-class"><pre class="language-text"><code>// 主线程
var myWorker = new Worker('worker.js', { name : 'myWorker' });

// Worker 线程
self.name // myWorker
</code></pre></div><p><code>Worker()</code>构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p> <ul><li>Worker.onerror：指定 error 事件的监听函数。</li> <li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在<code>Event.data</code>属性中。</li> <li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li> <li>Worker.postMessage()：向 Worker 线程发送消息。</li> <li>Worker.terminate()：立即终止 Worker 线程。</li></ul> <h3 id="worker-线程-2"><a href="#worker-线程-2" class="header-anchor">#</a> Worker 线程</h3> <p>Web Worker 有自己的全局对象，不是主线程的<code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在<code>window</code>上面的对象和方法不是全部都可以使用。</p> <p>Worker 线程有一些自己的全局属性和方法。</p> <ul><li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li> <li>self.onmessage：指定<code>message</code>事件的监听函数。</li> <li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li> <li>self.close()：关闭 Worker 线程。</li> <li>self.postMessage()：向产生这个 Worker 的线程发送消息。</li> <li>self.importScripts()：加载 JS 脚本。</li></ul> <p>（完）</p></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/01/15, 11:11:38</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/ffb0a1/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">浏览器模型(二)</div></a> <a href="/pages/610238/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">浏览器模型(四)</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/ffb0a1/" class="prev">浏览器模型(二)</a></span> <span class="next"><a href="/pages/610238/">浏览器模型(四)</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/610238/"><div>浏览器模型(四)</div></a> <span>12-12</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/229568/"><div>浏览器模型(一)</div></a> <span>12-11</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/ffb0a1/"><div>浏览器模型(二)</div></a> <span>12-11</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1390128154@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wuKongNotNull" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2022
    <span>悟空非空也 | <a href="https://github.com/WuKongNotNull/wukong-post/blob/main/LICENSE" target="_blank">Apache License 2.0</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0772105c.js" defer></script><script src="/assets/js/2.6497fd29.js" defer></script><script src="/assets/js/220.5c5efc16.js" defer></script>
  </body>
</html>